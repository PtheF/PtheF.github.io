<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JIT即时编译器</title>
    <url>/2022/06/02/JIT/</url>
    <content><![CDATA[<p>最早我们说运行时数据区的时候有一张图，就是runtime的构造，里面有PC，堆，栈，方法区，本地方法栈啥的，还有一个东西，叫JIT编译产物 CodeCache，这时啥玩意？我们这里就来介绍一下JIT是啥东西。</p>
<span id="more"></span>

<h1 id="1-JIT-即时编译器"><a href="#1-JIT-即时编译器" class="headerlink" title="1. JIT 即时编译器"></a>1. JIT 即时编译器</h1><p>首先明确几个概念：</p>
<ul>
<li><p>Java 运行在 JVM上，JVM 类似 物理机，二者都有指令，比如物理机有 汇编 机器码 JVM 就有JVM指令。</p>
</li>
<li><p>Java 是半解释半编译语言</p>
</li>
<li><p>这个编译，分为两部分：</p>
<ul>
<li><p>前端编译：javac 编译代码变成 class 文件</p>
</li>
<li><p>后端编译: JIT 编译代码为 计算机认识的指令</p>
</li>
</ul>
</li>
<li><p>翻译，指的是 JVM 通过 PC寄存器，逐条执行class文件里面的指令</p>
</li>
<li><p>JIT 是即时编译器，也就是在程序运行时编译，是否编译取决于热点探测，这个后面会说到。</p>
</li>
</ul>
<h1 id="2-Java代码的执行分类"><a href="#2-Java代码的执行分类" class="headerlink" title="2. Java代码的执行分类"></a>2. Java代码的执行分类</h1><p>如下图：</p>
<p><img src="/images/runtime/JIT.png"></p>
<p><img src="/images/runtime/JIT2.png" alt="jit2"></p>
<p>上图两个就是Java编译的方式。</p>
<p>途中，黄色的路线：程序源码一直到抽象语法树，都是javac 给我们处理， 目的是生成线性的指令集合，然后 要么是 JVM直接翻译运行，要么就是 JIT 编译成机器码 运行。</p>
<p>即时编译：</p>
<p>就是JIT编译完以后，机器码存起来了，如果再次调用这个方法，他就会直接去找机器码运行。</p>
<h1 id="3-HotSpot-采用的方式"><a href="#3-HotSpot-采用的方式" class="headerlink" title="3. HotSpot 采用的方式"></a>3. HotSpot 采用的方式</h1><p>HotSpot 是两种方式都在使用，在运行时 即时编译和翻译是同步进行，二者协调进行。</p>
<p>即时编译的好处就是一次编译，以后运行速度快，但是编译也耗费时间。</p>
<p>翻译的好处就是不需要翻译，直接运行。</p>
<p>当虚拟机启动时，翻译器会首先工作，省去编译的时间，然后随着时间的推移， 即时编译器开始起作用，将一些有价值的代码编译成机器指令，提高速度。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>生产环境中，热机能承受的负载大于冷机，如果项目体量大，流量大，那么吧一个项目部署到一个JVM刚刚启动的机器上，可能导致宕机。</p>
<h1 id="4-细说JIT"><a href="#4-细说JIT" class="headerlink" title="4. 细说JIT"></a>4. 细说JIT</h1><ul>
<li><p>java 语言的 “编译期” 其实是一段不确定的操作过程，因为他有三种情况：</p>
</li>
<li><p>既可能指的是前端编译 也就是 javac 编译，把java文件转化为class文件</p>
</li>
<li><p>也可能是后端编译，将JVM指令转化为机器码</p>
</li>
<li><p>还有可能是静态提前编译器(AOT 编辑器， Ahead Of Time Compiler) 直接吧 Java 编译成机器码</p>
</li>
</ul>
<p>问题来了，前面提到，Hotspot 虚拟机是 编译和翻译同时进行的，</p>
<p>那么jvm如何选择哪些编译哪些翻译？就用到了下面的东西</p>
<h1 id="5-热点代码及探测方法"><a href="#5-热点代码及探测方法" class="headerlink" title="5. 热点代码及探测方法"></a>5. 热点代码及探测方法</h1><p>是否需要启动JIT去编译代码取决于这个代码的执行频率，如果执行频率高，则启动JIT进行编译，同时JIT对其进行 <em>深度优化</em> ，然后编译成机器码，那么这部分执行频率高的代码，也叫做 <em>热点代码</em> 。</p>
<ul>
<li><p>一个被多起的方法，或者是一个方法题内循环册数比较大多的循环体，都可以称为 <em>热点代码</em> 。因为这个过程发生在方法执行过程中，所以这个方法也成为 <em>栈上替换</em> 简称 OSR(On Stack Replacement)</p>
</li>
<li><p>那么一个代码被执行多少次就算是热点代码了？这主要依赖<em>热点探测功能</em>。</p>
</li>
<li><p>Hotspot 的热点探测方式是基于计数器的热点探测</p>
</li>
<li><p>采用计数器，Hotspot VM 将给每一个方法都建立2个不同的计数器，分别是：</p>
<ul>
<li><p>方法调用计数器：统计方法调用次数</p>
</li>
<li><p>回边计数器：统计循环体执行的循环次数</p>
</li>
</ul>
</li>
<li><p>阈值：VM 的client模式下是 1500次，server 模式下 10000 次</p>
<blockquote>
<p>即便我们的是PC，个人电脑，但是VM也是server 模式，</p>
<p>可以 <code>java --version</code> 看一看.</p>
</blockquote>
</li>
<li><p>这个阈值可以通过 <code>-XX:CompileThreshold</code> 来人为设定。</p>
</li>
<li><p>超过阈值，就会提交编译请求，然后JIT编译，最后的编译结果，也就是机器指令，他会存在方法区里面，我们之前也说过 方法区里面有JIT的代码缓存 <em>CodeCache</em> 。</p>
</li>
</ul>
<p>具体流程如下图：</p>
<p><img src="/images/runtime/JIT3.png" alt="jit3"></p>
<hr>
<h2 id="热度衰减"><a href="#热度衰减" class="headerlink" title="热度衰减"></a>热度衰减</h2><ul>
<li><p>如果不做任何设置，方法调用计数器记录的并不是一个绝对的次数，而是一个相对的频率，也就是一段时间内的调用次数，如果超过了这个一段时间，方法的调用次数还不足以提交便已请求，那么调用计数器的值就会减半，这个过程称为程序计数器的<strong>热度衰减</strong>，这段时间叫<strong>半衰期</strong>。</p>
</li>
<li><p>热度衰减是 JVM在垃圾回收的时候顺便进行的行为，可以通过参数 <code>-XX:-UseCounterDecay</code> 来关闭热度衰减，这个时候，调用计数器记录的就是一个绝对的调用次数，只要运行时间够长，绝大多数的方法都可以被编译。</p>
</li>
<li><p>可以通过 <code>-XX:CounterHalfLifeTime</code>来设置半衰期时间，单位是秒。</p>
</li>
</ul>
<h1 id="6-JVM-关于JIT的参数"><a href="#6-JVM-关于JIT的参数" class="headerlink" title="6. JVM 关于JIT的参数"></a>6. JVM 关于JIT的参数</h1><ul>
<li><p><code>-Xint</code> 代码全部解释执行，也可以 java -Xint –version 我们会看到 interpreted mod，也就是解释执行</p>
</li>
<li><p><code>-Xcomp</code> 代码全部编译执行，同理上面，看到 compile mode 编译执行</p>
</li>
<li><p><code>-Xmixed</code> 代码混合执行，一边翻译一边编译。</p>
</li>
</ul>
<h1 id="7-JVM模式"><a href="#7-JVM模式" class="headerlink" title="7. JVM模式"></a>7. JVM模式</h1><p>我们之前说过，JVM分为两种模式：client 模式 和 server 模式，client 模式里面调用计数器阈值是1500 次 server 是 10000次，同事JIT也分为两种，一个 Client Compiler(简称C1)，一个 Server Compiler (简称C2)如何修改这两种模式：</p>
<ul>
<li><p><code>-client</code> 开启 client 模式，使用C1，优化比较简单，耗时短，达到最快的编译速度。</p>
</li>
<li><p><code>-server</code> 开启 server模式，使用C2，64位电脑是支持server模式的，同时默认开启，server模式优化的更深一点，所以得到的机器码比client 更快，但是编译时间更长。</p>
</li>
</ul>
<h1 id="8-扩展：AOT提前编译器"><a href="#8-扩展：AOT提前编译器" class="headerlink" title="8. 扩展：AOT提前编译器"></a>8. 扩展：AOT提前编译器</h1><p>AOT 提前编译器，不同于即时编译器是运行时编译，他是在运行之前编译。</p>
<p>jdk9 引入了实验性的 aot编译工具 jaotc，将java 类文件直接编译成机器码，存放到生成的代码共享库中。</p>
<p>具体流程：.java -&gt; .class — jaotc —&gt; .os</p>
<p>好处就是第一次运行快了，坏处就是降低了 Java 链接过程的动态性，破坏了 java 一次编译到处运行的原则。</p>
<h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h1><p>可以看出这一章东西倒不是很多，比较简单，就是一些简单的概念，了解我觉得就行了。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-类加载子系统</title>
    <url>/2022/05/22/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>从这里开始正式开始JVM，首先我们要对类加载有一个大致的认识。类加载子系统 就是将 类 从磁盘中读取到 内存中的一个东西，包括 加载 链接 初始化 三个阶段。</p>
<span id="more"></span>

<h1 id="1-类加载三阶段"><a href="#1-类加载三阶段" class="headerlink" title="1. 类加载三阶段"></a>1. 类加载三阶段</h1><h2 id="1-1-加载"><a href="#1-1-加载" class="headerlink" title="1.1 加载"></a>1.1 加载</h2><ol>
<li><p>通过一个类的全限定命名，获取这个类的二进制流。</p>
<blockquote>
<p>class 文件来源：<br>Class文件；applet 网络；计算生成也就是动态代理；JSP；压缩文件(jar war)。。。</p>
</blockquote>
</li>
<li><p>将字节流代表的静态存储结构转化为方法区的运行时数据结构。</p>
</li>
<li><p>在内存中生成代表这个类的反射(java.lang.Class)，作为方法区这个类的各种数据访问入口。</p>
</li>
</ol>
<h2 id="1-2-链接"><a href="#1-2-链接" class="headerlink" title="1.2 链接"></a>1.2 链接</h2><h3 id="1-2-1-验证-verify"><a href="#1-2-1-验证-verify" class="headerlink" title="1.2.1 验证 verify"></a>1.2.1 验证 verify</h3><p>保证加载类的字节流包含的数据符合规范，不会危害到JVM。<br>主要验证：文件格式 元数据 字节码 符号引用</p>
<blockquote>
<p>这里举个例子，Java 的字节码文件有一个规范，二进制都以 CA FE BA BE 开头</p>
</blockquote>
<h3 id="1-2-2-准备阶段"><a href="#1-2-2-准备阶段" class="headerlink" title="1.2.2 准备阶段"></a>1.2.2 准备阶段</h3><p>给 类变量设置初始值为零值，仅限于类变量，也就是 static,不包含 final static，因为 final 的零值在编译的时候就已经分配了。</p>
<h3 id="1-2-3-解析"><a href="#1-2-3-解析" class="headerlink" title="1.2.3 解析"></a>1.2.3 解析</h3><p>常量池中的符号引用改为直接引用,举个例子，我们就写一个类里面有一个主方法，他就需要加载一大堆类，其实就是 lang 底下的各种类，总不能说都放到out目录下，所以就需要引用他们。</p>
<p>详细的以后细说，这里大致了解一下。</p>
<h2 id="1-3-初始化阶段"><a href="#1-3-初始化阶段" class="headerlink" title="1.3 初始化阶段"></a>1.3 初始化阶段</h2><ol>
<li><p>调用类的 clinit 方法，这个方法会把 所有对 static 成员的赋值操作收集起来，<br>写成一个方法 clinit(按顺序，按顺序，按顺序)，对 static 进行重新赋值</p>
<blockquote>
<p>这里举一个例子：<br> static{num &#x3D; 20;} private static int num &#x3D; 10;<br>首先因为链接阶段的 prepare，num 在初始化前就是 0，所以在初始化的时候，按照顺序生成 clinit，也就是先 num &#x3D; 20，再 num &#x3D; 10，所以最后，num &#x3D;&#x3D; 10 </p>
</blockquote>
</li>
<li><p>如果说 我们的类 里面没有 static，那么就不存在 clinit</p>
</li>
<li><p>clinit 不同于 构造函数，clinit 在 构造之前执行，在JVM 的角度，构造函数 是 &lt;init&gt;() 方法，在 &lt;clinit&gt;() 之后。</p>
</li>
<li><p>子类执行 clinint 之前，必须执行 超类 的 clinit</p>
</li>
<li><p>JVM 保证多线程下 clinit 方法被枷锁</p>
</li>
</ol>
<h1 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2. 类加载器"></a>2. 类加载器</h1><h2 id="2-1-概括"><a href="#2-1-概括" class="headerlink" title="2.1 概括"></a>2.1 概括</h2><p>JVM 支持两种类加载器：</p>
<ul>
<li><p>引导类加载器 Bootstrap ClassLoader</p>
</li>
<li><p>自定义类加载器 User-defined Class Loader</p>
<blockquote>
<p>这个自定义类加载器不是说我们自己写的，而是只要派生了抽象类ClassLoader的，<br>都叫自定义类加载器。</p>
</blockquote>
</li>
</ul>
<p>必须注意的是，Bootstrap ClassLoader 并没有继承 ClassLoader，它使用 C 实现的。</p>
<p>各个类加载器之间是包含关系，不是上下级，更不是继承。</p>
<pre><code>                  BootstrapClassLoader
                           |
                  ExtensionClassLoader
                           |
                    SystemClassLoader
                           |
              |------------+-----------|                      
     User-def ClassLoader     User-def ClassLoader
             ...                      ...
</code></pre>
<p>我们可以通过代码来验证这种关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 sun.misc.Launcher$AppClassLoader 表明得到了 SystemClassLoader</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">sysLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 sun.misc.Launcher$ExtClassLoader 表明ExtClassLoader包含 SystemClassLoader</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">extLoader</span> <span class="operator">=</span> sysLoader.getParent();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法得到 ExtClassLoader 的parent，因为他的上层 BootstrapClassLoader 不是Java写的。返回null</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">bootLoader</span> <span class="operator">=</span> extLoader.getParent();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类的类加载器，返回 AppClassLoader，也就是系统类加载器加载自定义类。</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">myClassLoader</span> <span class="operator">=</span> MyClass.class.getClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 由引导类加载器加载，返回 null 所以 Java 的核心类都被引导加载器加载</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">stringLoader</span> <span class="operator">=</span> String.class.getClassLoader();</span><br></pre></td></tr></table></figure>

<h2 id="2-2-JVM自带的类加载器"><a href="#2-2-JVM自带的类加载器" class="headerlink" title="2.2 JVM自带的类加载器"></a>2.2 JVM自带的类加载器</h2><h3 id="2-2-1-启动类加载器"><a href="#2-2-1-启动类加载器" class="headerlink" title="2.2.1 启动类加载器"></a>2.2.1 启动类加载器</h3><p>也叫引导类加载器 BootstrapClassLoader</p>
<ul>
<li><p>用 C&#x2F;C++ 实现，嵌套在JVM内部</p>
</li>
<li><p>用来加载Java核心类库</p>
<blockquote>
<p>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar resources.jar 或者<br>sun.boot.class.path 下的内容，用于提供JVM自身需要的类</p>
</blockquote>
</li>
<li><p>并没有继承ClassLoader，没有父加载器</p>
</li>
<li><p>加载扩展类和应用程序类加载器(ExtClassLoader &amp; AppClassLoader)，并制定他们的父加载器</p>
</li>
<li><p>出于安全考虑，只加载包名开头是 java javax sun 的类。</p>
</li>
</ul>
<h3 id="2-2-2-扩展类加载器"><a href="#2-2-2-扩展类加载器" class="headerlink" title="2.2.2 扩展类加载器"></a>2.2.2 扩展类加载器</h3><ul>
<li><p>用 Java 编写</p>
</li>
<li><p>派生于 ClassLoader，sun.misc.Launcher$ExtClassLoader</p>
</li>
<li><p>父加载器是 启动类加载器</p>
</li>
<li><p>从 java.ext.dirs系统属性指定的目录中加载，或者 加载 jre&#x2F;lib&#x2F;ext 下的类库。</p>
<blockquote>
<p>如果用户写的 jar文件放在这里，也被他加载。</p>
</blockquote>
</li>
</ul>
<h3 id="2-2-3-应用程序加载器"><a href="#2-2-3-应用程序加载器" class="headerlink" title="2.2.3 应用程序加载器"></a>2.2.3 应用程序加载器</h3><ul>
<li>Java 编写</li>
<li>派生于 ClassLoader， sun.misc.Launcher$AppClassLoader 实现</li>
<li>父加载器是 扩展类加载器</li>
<li>家在环境变量 classpath或系统属性 java.class.path目录下的类库</li>
<li>程序默认的类加载器，Java 应用程序都被他加载</li>
<li>调用 ClassLoader.getSystemClassLoader() 可以得到</li>
</ul>
<h3 id="2-2-4-自定义类加载"><a href="#2-2-4-自定义类加载" class="headerlink" title="2.2.4 自定义类加载"></a>2.2.4 自定义类加载</h3><ul>
<li>一般来说，类加载几乎都是上面三个 类加载器加载的，情况特殊我们可以用自己的。</li>
<li>什么时候需要自定义：<ul>
<li>隔离加载类 比如框架之间用 Jar包，为了相互不冲突，自定义类加载器</li>
<li>修改类的加载方式</li>
<li>扩展加载源，比如我们可以从数据库中加载</li>
<li>防止源码泄露，先对源码进行加密，然后自定义类加载器进行解密。</li>
</ul>
</li>
<li>如何自定义类加载器，以后再说，大致需要实现 继承 ClassLoader 重写 findClass</li>
</ul>
<h2 id="2-3-关于-ClassLoader"><a href="#2-3-关于-ClassLoader" class="headerlink" title="2.3 关于 ClassLoader"></a>2.3 关于 ClassLoader</h2><p>是一个抽象类，我们以后自己要实现类加载器的话可以继承这个类来实现一些我们自己的功能。</p>
<h1 id="3-双亲委派机制"><a href="#3-双亲委派机制" class="headerlink" title="3. 双亲委派机制"></a>3. 双亲委派机制</h1><p>一个类加载器接收到类加载请求后，并不会立马进行加载，而是把加载请求传给父加载器（虽然说父加载器，但是一直说 三个类加载器之间没有继承关系），然后一直递归，一直往上，最终给了 引导类加载器。如果父加载器可以完成加载，则返回结果，如果不能，再传回子加载器</p>
<p>举个例子：</p>
<p>加载我们的自定义类 User，首先AppClassLoader 收到加载请求，将请求发给ExtClassLoader，然后ExtClassLoader 再发给BootstrapClassLoader，BootstrapClassLoader 一看，我只负责加载 java javax 等，你这个 pri.entity.User 我不负责，将请求发回 ExtClassLoader，ext 也不管，则返回App，最终App进行加载。</p>
<p>再举个栗子：</p>
<p>我们自定义一个 java.lang.String，然后在别的地方 <code>String str = new String();</code> 那么加载的是哪个类，是我们自定义的，还是Java 的。根据这个机制，这个请求最终发给了 BootstrapClassLoader，那么很显然就会加载 系统的 String,而不是我们自己的String，因为我们自己的 String 需要 AppClassLoader 加载。</p>
<p>然后我们在我们自己的 String 里面定义main 方法，可不可3以运行？显然不行，因为执行main方法需要先进性类加载，直接加载 系统的 String。系统的String 很显然没有main</p>
<h2 id="3-1-优势"><a href="#3-1-优势" class="headerlink" title="3.1 优势"></a>3.1 优势</h2><ul>
<li>避免类的重复加载。</li>
<li>保护核心api不被破坏，比如上面的例子</li>
</ul>
<h2 id="3-2-如何判断两个Class-相同"><a href="#3-2-如何判断两个Class-相同" class="headerlink" title="3.2 如何判断两个Class 相同"></a>3.2 如何判断两个Class 相同</h2><ul>
<li>全限定命名一样</li>
<li>所用的类加载器一样</li>
</ul>
<h2 id="3-3-Java加载类的两种方式"><a href="#3-3-Java加载类的两种方式" class="headerlink" title="3.3 Java加载类的两种方式"></a>3.3 Java加载类的两种方式</h2><p>Java加载类就是两种方式：主动加载和被加载，下面是主动加载</p>
<ul>
<li>创建实例</li>
<li>访问静态变量或者赋值</li>
<li>调用静态方法</li>
<li>反射，比如 Class.forName()</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK7开始的同台语言支持，不知道啥意思</li>
</ul>
<p>除此之外，全是被动加载，被动加载不会进行初始化。我们上面说过，类加载经理加载链接初始化，只有主动加载一个类，这个类才会经历初始化过程，否则不会经历。那么不会初始化会导致什么后果？以后再说。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署</title>
    <url>/2022/05/22/hexo%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>整个博客使用Hexo搭建，需要电脑上有 node + git 环境，如果没有，请移步下面的教程：</p>
<p><a href="https://www.bilibili.com/video/BV1q4411i7gL">hugo博客搭建</a></p>
<span id="more"></span>

<h1 id="1-Github-Page"><a href="#1-Github-Page" class="headerlink" title="1. Github Page"></a>1. Github Page</h1><p>干嘛的？就是github会给你一个域名，比如 xxx.github.io，这个域名你可以用来部署一些静态页面，步骤也很简单，只要仓库里面是静态页面的文件就可以了。有了这个我们就可以搭建个人博客。</p>
<p><strong><font color='red'>步骤如下：</font></strong></p>
<p>在github创建仓库，仓库名必须是 xxxx.github.io，而且这个xxx，最好是你的用户名，必须遵从这个规范。创建完以后，只要你这个仓库里面有静态页面的东西，那 page 就会生效。可以选择用READMD初始化一下仓库，然后在仓库的 settings 里面，找到 Pages，会发现里面给你提供了一个可访问的网址，说明page已经生效。</p>
<p>如果settings-page里面没有那个网址，说明空仓库，没关系，待会就有了。</p>
<h1 id="2-Hexo"><a href="#2-Hexo" class="headerlink" title="2. Hexo"></a>2. Hexo</h1><p>我们这里选择Hexo来搭建仓库，这里提供一个视频，可以跟着视频搭：</p>
<p><a href="https://www.bilibili.com/video/BV1Yb411a7ty">Hexo搭建教程</a></p>
<h2 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h2><p>所以这个hexo是个什么原理？其实很简单。我们在博客项目下编写md文档，然后hexo会帮我们自动把md文档转化为html，然后连同hexo这个网站一起，打包，发到你配置的git仓库实现自动部署。</p>
<p>所以这也是我之前的一个错误理解，我以为hexo是一个后端服务，需要把他部署在服务器上，github page 帮我们跑这个服务器。其实不该是这么用的，而是hexo安装在我们本地，我们在博客里面写好文章，然后通过命令让hexo帮我们打包发送到git，然后git帮我们部署打包好的静态页面。</p>
<p>当然啦，如果你和我一样弱智的话，也可以把hexo当后端服务跑，hexo提供了一个本机预览的功能，有点类似Vue 的 npm run serve，你大可以找个服务器然后 <code>nohup hexo s &amp;</code>。</p>
<h2 id="2-2-安装流程"><a href="#2-2-安装流程" class="headerlink" title="2.2 安装流程"></a>2.2 安装流程</h2><blockquote>
<p>这里必须要有 node.js 环境，没有的话去装 hugo，同时必须要有git</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 hexo</span></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化 hexo 项目，你自己找一个目录，然后在里面执行这条命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注：这里强烈建议配置一下 github 加速，因为这一步要从github拉东西，太慢的话可能会报错</span></span><br><span class="line">hexo init blog</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等待初始化结束，本地启动hexo</span></span><br><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<p>然后，正常情况下，会提示这么一句：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<p>如果没有这句，那么不出意外地话应该是出意外了，把错误信息百度一下看看 :)</p>
<p>OK，到这里算是安装完了，但是我们还需要配置一下这个玩意。</p>
<h2 id="2-3-配置基本信息"><a href="#2-3-配置基本信息" class="headerlink" title="2.3 配置基本信息"></a>2.3 配置基本信息</h2><p>博客根目录下有个 _config.yml 文件，打开他，改几个地方：</p>
<h3 id="2-3-1-配置博客基本信息"><a href="#2-3-1-配置博客基本信息" class="headerlink" title="2.3.1 配置博客基本信息"></a>2.3.1 配置博客基本信息</h3><p>配置文件中会找到这么几行：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">博客网站的题目</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;博客小标题&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;描述信息&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">用户名</span></span><br><span class="line"><span class="comment"># 配置语言-简中</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br><span class="line"><span class="comment"># 时区</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-配置仓库"><a href="#2-3-2-配置仓库" class="headerlink" title="2.3.2 配置仓库"></a>2.3.2 配置仓库</h3><p>往后找，找到这么几行：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="comment"># 这里写你的git仓库地址</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">http://xxxxx@github.com/user_name/user_name.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-小坑"><a href="#2-3-3-小坑" class="headerlink" title="2.3.3 小坑"></a>2.3.3 小坑</h3><p>如果这里你配置的是github的仓库地址，那可能需要麻烦点，这里直接写 <a href="https://github.com/xxx/xxx.github.io.git">https://github.com/xxx/xxx.github.io.git</a> 的话，push 的时候会让你输入用户名密码，然后，很可能告诉你现在已经不支持密码验证了，要你配置token。</p>
<p>我这里就不展开说了，百度一下如何获取github的token，然后把这个地址写成 <code>https://your_token@github.com//xxx/xxx.github.io.git</code> 即可。</p>
<h2 id="2-4-安装主题"><a href="#2-4-安装主题" class="headerlink" title="2.4 安装主题"></a>2.4 安装主题</h2><p>我这里选择使用 NexT主题，同样的，在博客项目中执行如下命令，切记必须是博客根目录，就是有 node_modules 那个目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">克隆主题源码到 博客的themes 目录下</span></span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next.git themes/next</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装一个包，不安装的话可能会乱码</span></span><br><span class="line">npm install hexo-renderer-swig</span><br></pre></td></tr></table></figure>

<p>然后配置根目录下的 _config.yml 文件，找到 theme，修改为: <code>theme: next</code> 即可，然后执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo g</span><br></pre></td></tr></table></figure>

<p>访问 localhost:4000 看看效果。希望没有乱码。</p>
<h2 id="2-5-Tags-amp-Categories-amp-About"><a href="#2-5-Tags-amp-Categories-amp-About" class="headerlink" title="2.5 Tags &amp; Categories &amp; About"></a>2.5 Tags &amp; Categories &amp; About</h2><p>我们的博客里面的文章得有分类和标签吧？还得有个关于页面吧？怎么配置呢？</p>
<p>在博客根目录下执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line">hexo new page about</span><br><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>然后，进入source目录，会发现里面有了三个目录，分别是 categories  tags  about。我们挨个改：</p>
<p>首先是进入 categories 目录，编辑 index.md，固定写法，其实就是在date下面，线上面，加一个 <code>type: &quot;categories&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: Categories</span><br><span class="line">date: 2022-05-21 11:43:02</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure>

<p>同理Tags，编辑里面的 index.md ，在date 下面，线上面，加一个 <code>type: &quot;tags&quot;</code> 即可。</p>
<p>同理about，编辑index.md，里面写上你想写的东西就行了。</p>
<p>然后，这三个页面以后都不要管了。</p>
<h2 id="2-6-主题配置"><a href="#2-6-主题配置" class="headerlink" title="2.6 主题配置"></a>2.6 主题配置</h2><p>这可就麻烦了，比如 配置头像，配置github，配置主题的主题，配置搜索功能 等等。这里给个博客自己看吧：</p>
<p><a href="https://blog.csdn.net/weixin_42665200/article/details/104633560">NexT配置</a></p>
<h1 id="3-部署"><a href="#3-部署" class="headerlink" title="3. 部署"></a>3. 部署</h1><p>这个倒是出奇的简单，直接 hexo d 即可。这一步他就会把项目打包，然后传给github，然后github就会给你部署你的静态页面。</p>
<p>当然啦，只要是支持git page 的git网站应该都行，比如gitee，但是gitee申请page挺麻烦的，还得实名认证，不想琢磨。</p>
]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>深入字符串</title>
    <url>/2022/06/02/String/</url>
    <content><![CDATA[<p>字符串，嗯，面试的重点，多少都会涉及。而且字符串看似简单，其实要深入JVM理解字符串还是有些难度的，所以这一章就来单独说一下字符串的小坑。</p>
<span id="more"></span>

<h1 id="1-String基础"><a href="#1-String基础" class="headerlink" title="1. String基础"></a>1. String基础</h1><h2 id="1-1-String基本特性"><a href="#1-1-String基本特性" class="headerlink" title="1.1 String基本特性"></a>1.1 String基本特性</h2><ul>
<li><p>String 不是基础数据类型，即便他能 String x &#x3D; “” 直接赋值</p>
</li>
<li><p>String 实现了 Comparable 和 Serializable，也就是可以序列化和比大小</p>
</li>
<li><p>String 被final 修饰不能继承</p>
</li>
<li><p>String 在 jdk8之前他的底层是char[] value,jdk9 以后修改成了byte[] value，为啥？</p>
</li>
</ul>
<h2 id="1-2-jdk8-9-对于String底层的修改"><a href="#1-2-jdk8-9-对于String底层的修改" class="headerlink" title="1.2 jdk8 9 对于String底层的修改"></a>1.2 jdk8 9 对于String底层的修改</h2><p>jdk8以前String底层是char数组，jdk9就变成了byte数组，为啥？</p>
<p>首先，可以去官网看：<u><span spellcheck="false" class="md-link md-pair-s"><a href="http://openjdk.java.net/jeps/254">JEP 254: Compact Strings</a></span></u> 里面的motivation详细说了，这里概括一下：</p>
<p>以前的java实现String 里面采用 char[] value的形式存储字符串，一个字符 占两个字节，然后String 是堆空间里面主要的存储单位，数量特别多。但是他们发现，大部分的字符串包含的都是一些 Latin-1(拉丁，简单理解，拼音) 字符，这些字符其实一个字节就可以表示了，也就是说，大部分情况下，字符串里面一半的空间都被浪费了。</p>
<p>那么问题又来了，有的时候的确要存非拉丁字符，比如汉字，这咋整，他们在String里面又存储了charset 字段用来保存这个字符的编码，按照编码来分配是一个字节存还是两个字节存。</p>
<p>凡是和String有关系的类，比如 StringBuilder StringBuffer 底层都变成了 byte[]。</p>
<h2 id="1-3-String-的不可变"><a href="#1-3-String-的不可变" class="headerlink" title="1.3 String 的不可变"></a>1.3 String 的不可变</h2><p>什么鬼，忘得特别干净，复习一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字面量赋值：  </span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 创建字符串，只要是这种通过字面量创建出来的字符串，他们的值都是存在字符串常量池中的，而且字符串常量池中不允许重复  </span></span><br><span class="line"><span class="comment">// 所以如果两个字符串通过字面量赋值相同，那么这两个字符串其实指向的是同一个地址，俩字符串的hashcode 相同。  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  </span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// 这里肯定是 true  </span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 如果对这种字符串进行重新赋值，他并不会修改常量池中的值，而是重新造一个值，然后改变指向，这就体现了字符串的不可变  </span></span><br><span class="line"><span class="comment">// 同理 字符串拼接，也是一个道理，并不是修改值，而是重新造一个值并修改指向  </span></span><br><span class="line"><span class="comment">// 包括 String.replace(old, new)，这个也是新造，不是修改。  </span></span><br><span class="line">s1 = <span class="string">&quot;hello&quot;</span>;  </span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// 这回就是 false，因为s1 已经改变了指向  </span></span><br><span class="line">​  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 下面这个，s 还是 hello，别问，不知道为啥，但是如果直接在main 方法里面设置 s = &quot;test&quot;，他是可以修改成功的  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);  </span><br><span class="line">    change(s);  </span><br><span class="line">    System.out.println(s);  </span><br><span class="line">&#125;  </span><br><span class="line">​  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String s)</span>&#123;  </span><br><span class="line">    s = <span class="string">&quot;test&quot;</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-字符串常量池"><a href="#1-4-字符串常量池" class="headerlink" title="1.4 字符串常量池"></a>1.4 字符串常量池</h2><ul>
<li><p>字符串常量池：String Pool 或者也叫 StringTable 是一个固定大小的HashMap，HashMap 总学过吧。默认大小是 1009 (jdk6)，如果存入的字符串过多，那么得到的HashKey也就会很多，从而导致链表过长，然后效率降低。</p>
</li>
<li><p>使用 <code>-XX:StringTableSize</code> 来指定常量池的大小。</p>
</li>
<li><p>jdk6中默认是 1009，固定的，可以通过参数修改，如果字符串过多则效率降低</p>
</li>
<li><p>jdk7以后默认就是60013，1009 是设置的最小长度</p>
</li>
</ul>
<h1 id="2-字符串拼接"><a href="#2-字符串拼接" class="headerlink" title="2. 字符串拼接"></a>2. 字符串拼接</h1><p>详细的说一说字符串拼接的操作, 当然也是介绍概念：</p>
<ul>
<li><p>常量和常量拼接结果在常量池，原理是编译期优化</p>
</li>
<li><p>常量池中不会重复</p>
</li>
<li><p>只要拼接的东西里面有一个是变量，那么拼接结果就放在堆里面，变量拼接原理是StringBuilder</p>
</li>
<li><p>如果拼接的结果调用inturn() 方法，则主动将常量池中还没有的字符串对象放入池中，返回地址</p>
</li>
</ul>
<p>然后我们一个一个说：</p>
<h2 id="2-1-常量拼接常量结果在常量池"><a href="#2-1-常量拼接常量结果在常量池" class="headerlink" title="2.1 常量拼接常量结果在常量池"></a>2.1 常量拼接常量结果在常量池</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s1 是常量拼接字符串，所以他的结果在常量池里面，所以s1 == s2 是 true  </span></span><br><span class="line"><span class="comment">// 而且，如果我们把编译出来的class文件在idea里面打开，让idea 给我们做反编译，我们就会看到  </span></span><br><span class="line"><span class="comment">// s1 里面写的根本不是拼接操作，而是直接 String s1 = &quot;abc&quot;;  </span></span><br><span class="line"><span class="comment">// 这个就是编译期优化，他在编译的时候，发现你常量拼接，他就直接给你转化成拼接结果了。  </span></span><br><span class="line">​  </span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>+<span class="string">&quot;c&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  </span><br><span class="line">System.out.println(s1 == s2);  </span><br><span class="line">System.out.println(s1.equals(s2));</span><br></pre></td></tr></table></figure>

<h2 id="2-2-拼接变量结果入堆"><a href="#2-2-拼接变量结果入堆" class="headerlink" title="2.2 拼接变量结果入堆"></a>2.2 拼接变量结果入堆</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;  </span><br><span class="line">​  </span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javahadoop&quot;</span>;  </span><br><span class="line"><span class="comment">// 什么是编译期优化，就是两个字面值的字符串做拼接，在javac编译的时候就已经可以知道拼接结果了</span></span><br><span class="line"><span class="comment">// 那么他就会在编译的时候就给你把值赋好</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span> + <span class="string">&quot;hadoop&quot;</span>; <span class="comment">// 编译期优化，等同于 s4 = &quot;javahadoop&quot;;  </span></span><br><span class="line"></span><br><span class="line">s3 == s4  <span class="comment">// true，且 s3 和 s4 都指向了字符串常量池中的javahadoop</span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 这里拼接出现了变量，如果我们去看字节码就会发现，他这里会创建一个StringBuilder给你进行拼接操作</span></span><br><span class="line"><span class="comment">// 然后拼接完成后给你return StringBuilder.toString(); </span></span><br><span class="line"><span class="comment">// 然后这个 toString() 方法会new String().</span></span><br><span class="line"><span class="comment">// 所以四舍五入就相当于在堆中 new String(),拼接结果位 javahadoop  </span></span><br><span class="line"><span class="comment">// 也就是，下面三个，都是独立的对象，那肯定是不相等了。  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span> + s2;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;  </span><br><span class="line"></span><br><span class="line">s3 == s5; <span class="comment">// false，而且s3和 s5 s6 s7 都不相等，愿意你很简单，一个是字符串常量池，另外的是堆中对象</span></span><br><span class="line">s5 == s6; <span class="comment">// false  </span></span><br><span class="line">s5 == s7; <span class="comment">// false  </span></span><br><span class="line">s6 == s7; <span class="comment">// false</span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// s6 是 javahadoop 是吧，很好，intern()就是判断常量池里面有没有 javahadoop，  </span></span><br><span class="line"><span class="comment">// 如果存在，则返回他的地址，如果不存在，则在常量池中创建一个，然后返回他的地址。  </span></span><br><span class="line"><span class="comment">// 至于这个intern方法后面会专门说。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();   </span><br><span class="line">​  </span><br><span class="line">s3 == s8; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="3-变量拼接的底层原理"><a href="#3-变量拼接的底层原理" class="headerlink" title="3. 变量拼接的底层原理"></a>3. 变量拼接的底层原理</h1><p>我们写一个变量拼接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="string">&quot;def&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">a3</span> <span class="operator">=</span> a1 + a2;</span><br></pre></td></tr></table></figure>

<p>然后我们看他的字节码文件，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">00 ldc #10 &lt;abc&gt;</span><br><span class="line">02 astore_0</span><br><span class="line">03 ldc #11 &lt;def&gt;</span><br><span class="line">05 astore_1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面就对应a1 和 a2 的赋值操作，不说了，主要是下面：</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先new一个StringBuilder</span></span><br><span class="line">06 new #12 &lt;java/lang/StringBuilder&gt;</span><br><span class="line">09 dup</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后调用构造函数</span></span><br><span class="line">10 invokespecial #13 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取局表的0位也就是 a1</span></span><br><span class="line">13 aload_0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用了StringBuilder的 append 方法，把a1传入</span></span><br><span class="line">14 invokevirtual #14 &lt;java/lang/StringBuilder.append :...;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取局表1位也就是a2</span></span><br><span class="line">17 aload_1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同理调用append方法</span></span><br><span class="line">18 invokevirtual #14 &lt;java/lang/StringBuilder.append : ...;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再调用toString 方法,这个toString 方法比较特殊，他的实现是 <span class="built_in">return</span> new String();</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所以 toString 约等于 new String() 为啥说约等于，以后再说。</span></span><br><span class="line">21 invokevirtual #15 &lt;java/lang/StringBuilder.toString : ...;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把结果存储到局表2位</span></span><br><span class="line">24 astore_2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">剩下就是输出了</span></span><br><span class="line">25 getstatic #2 &lt;java/lang/System.out :...;&gt;</span><br><span class="line">28 aload_2</span><br></pre></td></tr></table></figure>

<p>注意，用StringBuilder底层去拼接的，必须是变量，可不是说必须是引用，举个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span> + <span class="string">&quot;def&quot;</span>;  </span><br><span class="line">​  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 这个，它仅仅是应用，而不是变量，所以这种情况下他也不会用StringBuilder来构建  </span></span><br><span class="line"><span class="comment">// 所以这里仍旧会进行编译期优化  </span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  </span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;def&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + s2;</span><br></pre></td></tr></table></figure>

<h2 id="3-1-执行效率问题"><a href="#3-1-执行效率问题" class="headerlink" title="3.1 执行效率问题"></a>3.1 执行效率问题</h2><p>直接创建StringBuilder来拼接肯定是快，而且快很多，所以我们要字符串拼接我们不如直接创建一个StringBuilder或者StringBuffer来得实在。</p>
<p>默认情况下 StringBuilder的容量是16，如果不够了会进行扩容，也消耗性能，所以我们尽可能的给他确定一下容量。</p>
<h2 id="3-2-创建对象数"><a href="#3-2-创建对象数" class="headerlink" title="3.2 创建对象数"></a>3.2 创建对象数</h2><p>我们创建一个字符串：<code>new String(&quot;abc&quot;)</code>，这行代码创建了几个对象。很好，遇事不决字节码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一步，创建一个 String，也就是 new</span></span><br><span class="line">00 new #16 &lt;java/lang/String&gt;</span><br><span class="line">03 dup</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后，在常量池里面创建字符串 <span class="string">&quot;abc&quot;</span>,然后把 abc 传入 构造函数</span></span><br><span class="line">04 ldc #10 &lt;abc&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用构造，根据常量池里面的字符串在堆中创建对象</span></span><br><span class="line">06 invokespecial #17 &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;</span><br><span class="line">09 astore_0</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure>

<p>所以这么来看创建了几个对象？很显然是两个：一个是堆中的String，一个是常量池中的abc。</p>
<p>然后再说一下这个常量池的问题，为啥这里创建String的时候会在常量池中也创建一个？我个人觉得是因为我们传入的是一个字面量的字符串，所以他会把这个字面量存入常量池。</p>
<h2 id="3-3-更高级的对象数问题"><a href="#3-3-更高级的对象数问题" class="headerlink" title="3.3 更高级的对象数问题"></a>3.3 更高级的对象数问题</h2><p>一行代码：<code>String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code> ，这行代码创建了几个对象。同理，于是不决字节码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 创建 StringBuilder 对象，用来待会的拼接操作</span></span><br><span class="line">00 new #5 &lt;java/lang/StringBuilder&gt;</span><br><span class="line">03 dup</span><br><span class="line">04 invokespecial #6 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.创建 String 对象，对应 new String(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line">07 new #2 &lt;java/lang/String&gt;</span><br><span class="line">10 dup</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.在字符串常量池里面创建 <span class="string">&quot;a&quot;</span></span></span><br><span class="line">11 ldc #7 &lt;a&gt;</span><br><span class="line">13 invokespecial #4 &lt;java/lang/String.&lt;init&gt; :...&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里 StringBuilder 进行了 append操作。</span></span><br><span class="line">16 invokevirtual #8 &lt;java/lang/StringBuilder.append :...;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.创建String对象，对应 new String(<span class="string">&quot;b&quot;</span>);</span></span><br><span class="line">19 new #2 &lt;java/lang/String&gt;</span><br><span class="line">22 dup</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5.常量池里面创建 <span class="string">&quot;b&quot;</span></span></span><br><span class="line">23 ldc #9 &lt;b&gt;</span><br><span class="line">25 invokespecial #4 &lt;java/lang/String.&lt;init&gt; : ...&gt;</span><br><span class="line">28 invokevirtual #8 &lt;java/lang/StringBuilder.append :  ...;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6.StringBuilder 调用 toString 方法，这里又创建一个 String</span></span><br><span class="line">31 invokevirtual #10 &lt;java/lang/StringBuilder.toString : ...;&gt;</span><br><span class="line">34 astore_0</span><br><span class="line">35 return</span><br></pre></td></tr></table></figure>

<p>根据上面的解析，可以知道，一个语句总共创建了6个对象，只得注意的是，最终结果是 “ab”，但是直到最后 常量池里面也没有 “ab” 这个字符串，虽然说在toString 里面创建了字符串，通过 new String() ，我们之前说 new String(xxx) 会在pool中创建xxx，但是这里为啥就不创建了？我觉得是因为构造函数里面传入的不是字面量了，而是变量，所以不会再创建ab常量了。</p>
<h1 id="4-intern方法"><a href="#4-intern方法" class="headerlink" title="4. intern方法"></a>4. intern方法</h1><p>可以去String类里面看看他的注释，全英语的，反正我看不懂，所以下面大致给说一下</p>
<h2 id="intern-方法介绍"><a href="#intern-方法介绍" class="headerlink" title="intern 方法介绍"></a>intern 方法介绍</h2><p>首先，本地方法。</p>
<p>一个不是用字面量创建的字符串(注意，不是字面量创建的)，调用这个方法，他就会去 pool 里面找，有没有和当前字符串相等的字符串常量，如果有，则返回这个字符串的引用；如果没有，则在pool里面创建一个，然后返回引用。</p>
<p>如果有两个字符串 s t, s.intern() &#x3D;&#x3D; t.intern() 成立，当且仅当 s.equals(t) 成立。</p>
<p>举个例子：</p>
<p><code>String s = new String(&quot;hello world&quot;).intern()</code></p>
<p>这行代码就是：堆中创建了一个 字符串 “hello world”，然后调用 intern 去看 StringTable 里面有没有 helloworld，如果没有，则创建一个，然后返回引用给s。</p>
<p>再看一个例子：</p>
<p><code>(&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;</code></p>
<p>这个必然是 true，因为在 最前面拼接的时候，就已经在pool里面创建了”abc”。</p>
<p>所以总结一下，就是去字符串常量池中找有没有当前字符串的字面量常量，如果有则返回，如果没有则创建后返回。总之执行完这个方法，可以保证返回的东西指向了字符串常量池。</p>
<h1 id="5-一道String面试题"><a href="#5-一道String面试题" class="headerlink" title="5. 一道String面试题"></a>5. 一道String面试题</h1><p>上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">// 首先，创建了 s1，堆中一个，pool中一个，都是 &quot;a&quot;  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 这条代码是在pool中创建对象，但是已经有了，所以这行没用，同时他没有接收，s1 不变。  </span></span><br><span class="line">s1.intern();  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 又创建了一个对象，指向pool中的 &quot;a&quot;  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 所以这个没有异议，肯定是 false  </span></span><br><span class="line"><span class="comment">// jdk6/7/8   false  </span></span><br><span class="line">System.out.println(s1 == s2);            </span><br><span class="line">​  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 这里就开始扯淡了，看这行代码，创建了一堆对象，常量池中的 &quot;a&quot; 堆中的 &quot;a&quot;,  </span></span><br><span class="line"><span class="comment">// s3 是堆中的 aa，但常量池中可没有aa，老生常谈了，上面就重点说过。  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 然后在常量池中创建 &quot;aa&quot;,这里就开始有区别了，  </span></span><br><span class="line"><span class="comment">// jdk6 中，常量池在永久代里面，和堆没半毛钱关系，所以就是你想的那样，在pool中创建了 &quot;aa&quot;  </span></span><br><span class="line"><span class="comment">// 然后s4是常量池中的，s3 是堆中的，没关系，所以结果是 false。  </span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 而jdk7/8 不一样，jdk7/8的常量池在堆中，他在常量池创建对象的时候，一看，哎，  </span></span><br><span class="line"><span class="comment">// 堆里面已经有了一个对象(注意是堆中，不是常量池中)，所以他为了节省资源，他不会在常量池中再次创建对象，  </span></span><br><span class="line"><span class="comment">// 而是在常量池中创建一个引用，这个引用指向堆中，在这里就是s3,  </span></span><br><span class="line"><span class="comment">// 最后的结果就是，s4 指向常量池中的那个值，结果常量池中的值指向了s3，相当于 s4 变相的指向了 s3.  </span></span><br><span class="line"><span class="comment">// 所以结果是 true  </span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 但是注意，jdk7/8 中这种从常量池指向堆这种行为，只有 intern() 才会触发，  </span></span><br><span class="line"><span class="comment">// 你正常的 s5 = &quot;aa&quot;; 他是不会触发这种指向的，他还是会正常的在常量池中创建。  </span></span><br><span class="line">s3.intern();  </span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;  </span><br><span class="line"><span class="comment">// jdk6 false   jdk7/8 true  </span></span><br><span class="line">System.out.println(s3 == s4);</span><br></pre></td></tr></table></figure>

<h2 id="变式"><a href="#变式" class="headerlink" title="变式"></a>变式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这回的结果就是 false，原因很简单，根据上面的叙述，常量池引用堆只有intern才会触发，  </span></span><br><span class="line"><span class="comment">// 这里改变顺序，先创建 s2，这里就会在常量池中创建 &quot;aa&quot;,然后intern() 就会发现已经存在 &quot;aa&quot;，就不会指向堆。  </span></span><br><span class="line"><span class="comment">// 所以 s1 和 s2 是两个不同的对象，结果是false  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);  </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;  </span><br><span class="line">s1.intern();  </span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>

<h2 id="总结-intern-的使用："><a href="#总结-intern-的使用：" class="headerlink" title="总结 intern 的使用："></a>总结 intern 的使用：</h2><h3 id="jdk6"><a href="#jdk6" class="headerlink" title="jdk6"></a>jdk6</h3><ul>
<li><p>如果池中有，则不会创建，而是返回地址</p>
</li>
<li><p>池中没有，把当前字符串拷贝一份放入池中</p>
</li>
</ul>
<h3 id="jdk7-x2F-8"><a href="#jdk7-x2F-8" class="headerlink" title="jdk7&#x2F;8"></a>jdk7&#x2F;8</h3><ul>
<li><p>池中有，则返回地址，和上面一样</p>
</li>
<li><p>池中没有，则拷贝当前字符串的地址放到池中，让池指向堆，节约空间，然后返回地址。</p>
</li>
</ul>
<h1 id="6-G1的String去重行为"><a href="#6-G1的String去重行为" class="headerlink" title="6. G1的String去重行为"></a>6. G1的String去重行为</h1><blockquote>
<p>首先说一下G1，简单说，就是jdk7以后jvm里面的一个垃圾回收器。</p>
<p>这个gc并不分minor gc 还是 major gc，我查了一下，他似乎是一个整体的垃圾回收器，然后里面细分为回收年轻代 老年代等的行为。所以G1(G First) 就是一个全局的垃圾回收器。</p>
</blockquote>
<p>明确一个概念，这里的去重，当然不是指的字符串常量池中去重，pool中本来就没有重复对象，这个去重指的是堆中去重。</p>
<h2 id="6-1-去重的背景"><a href="#6-1-去重的背景" class="headerlink" title="6.1 去重的背景"></a>6.1 去重的背景</h2><p>对于许多java应用，经过测试发现如下：</p>
<ul>
<li><p>堆存活数据集合里面String 对象占25%</p>
</li>
<li><p>堆存活数据集合里面重复的String 占 13%</p>
</li>
<li><p>String 平均长度 45</p>
</li>
</ul>
<h2 id="6-2-实现"><a href="#6-2-实现" class="headerlink" title="6.2 实现"></a>6.2 实现</h2><ul>
<li><p>当垃圾收集器工作时会访问堆上的存活对象，检查是否是候选的去重字符串</p>
</li>
<li><p>如果是，把字符串加入一个队列，一个去重的后台线程对这个队列进行处理，处理就是删除队列元素然后尝试进行去重操作</p>
</li>
<li><p>使用一个hashtable来记录所有被String使用的不重复的char数组(就是String底层的char数组，去重主要是去重这个)，进行去重的时候会去查这个char数组，来检查堆上是否已经存在了一个一模一样的char数组。</p>
</li>
<li><p>如果存在，那么当前String就会改为引用已有的那个char数组，它本身的那个char数组会被释放。</p>
</li>
<li><p>如果不存在，那么当前char数组进入hashtable，然后对下一个String去重。</p>
</li>
</ul>
<h2 id="6-3-开启"><a href="#6-3-开启" class="headerlink" title="6.3 开启"></a>6.3 开启</h2><p>UseStringDeduplication(boolean) 开启String去重，默认是不开启的。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-页面跳转</title>
    <url>/2022/05/22/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<blockquote>
<p>create by 陈HL_pthef on 2022&#x2F;05&#x2F;22</p>
</blockquote>
<p>自从宣布开始做课设到现在，各种问题层出不穷，尤其页面跳转这个问题仍旧困扰着很多人。那在这里就详细说说 这个微信小程序到底如何实现页面跳转。</p>
<p><strong><font color="red">注意：</font></strong></p>
<p><strong>下面的内容不要深究原因，不要深究原因，不要深究原因</strong>，跟着做就可以了。</p>
<span id="more"></span>

<h2 id="1-页面"><a href="#1-页面" class="headerlink" title="1. 页面"></a>1. 页面</h2><p>想要页面跳转肯定先得有页面，所以如何创建页面呢？我这里用一个新的微信小程序模板：<br><img src="http://49.232.218.190/p1.png" alt="weixin_app"></p>
<p>首先，我们右键pages，那个红色的图标，右键他，然后选择新建文件夹，起一个合适的名字，我这里就叫 tempPage 。创建完以后如下所示：</p>
<p><img src="http://49.232.218.190/p2.png" alt="new_dir"></p>
<p>然后，我们右键你新建的这个文件夹，选择新建Page，要求你起个Page名称，我这里强烈建议：<strong><font color='red'>Page名称和文件夹名称保持一致</font></strong>。新建以后，就会出现4个文件，如下图：</p>
<p><img src="http://49.232.218.190/p3.png" alt="new_page"></p>
<p>呐，看好了，Page名和文件夹名一致。</p>
<p>而且，新建的这个文件夹，和文件夹里面这个和文件夹同名的Page，他们的名称必须<br><strong><font color='red'>全是英文！！！</font></strong>，这一点特别重要，否则待会跳转直接喜提 not found 异常。</p>
<p>然后我们在这个新页面上写点东西，打开 xxx.wxml 这个文件（xxx就是你Page的名），随你写点啥，我这里就写：</p>
<p><img src="http://49.232.218.190/p4.png" alt="temp_page_content"></p>
<p>很好，到这里，新页面准备完成，下一步我们需要实现从index.wxml 页面跳转到你的这个新页面。</p>
<h2 id="2-跳转"><a href="#2-跳转" class="headerlink" title="2. 跳转"></a>2. 跳转</h2><p>首先要想跳转，你得有个触发跳转的东西对吧，这里统一使用按钮也就是button，当然可以是别的，比如图片，view，啥的，都可以，但这里我就用button举例子了。所以我们的目标就是，在页面上放一个按钮，我们一点他，页面就会跳转到新页面。</p>
<p>第一步就是创建按钮，在 index.wxml 文件里面写一个button。</p>
<p><img src="http://49.232.218.190/p5.png" alt="button"></p>
<p>我这里的 index.wxml 啥也没有，你们的肯定有东西，根据你们的情况，把这个button放到合适的地方。同时可以看到左边 button 也显示出来了。</p>
<p>然后我们给这个button 绑定一个事件，在button标签里面写如下内容：</p>
<p><img src="http://49.232.218.190/p6.png" alt="button_bind"></p>
<p>其实就里面加了一个bindtap，bindtap后面跟着的那个东西，名字还真不能随便起，有如下规则：</p>
<ul>
<li>只能出现英文字母，数字和下划线（减号下面那个符号，我劝你别用）</li>
<li>数字不能开头</li>
</ul>
<p>我这里就叫jump了，你那叫啥都行，比如 toPage，toMyPage，甚至abc，都可以，但是决不能是 123, 1bc 甚至各种emoji，肯定报错。</p>
<p>然后，我们去这个页面对应的js文件下，因为我这个button是在index页面下写的，所以当前页面的js文件也就是index.js，在这个文件里加这么一段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我这里叫jump，你那还真不一定叫jump</span></span><br><span class="line"><span class="comment">// 你上面bindtap后面起的啥名，这里就写啥</span></span><br><span class="line"><span class="title function_">jump</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同理，我这里的url 写的是 ../tempPage/tempPage</span></span><br><span class="line">    <span class="comment">// 你那里不一定，这里应该写 ../你新页面的文件夹名/Page名</span></span><br><span class="line">    <span class="comment">// 而且特别注意，这里前里两个点一定不能丢。</span></span><br><span class="line">    <span class="comment">// 而且最后面的Page，没有后缀，不是 tempPage.js </span></span><br><span class="line">    <span class="comment">// 也不是 tempPage.wxml，就是tempPage</span></span><br><span class="line">    wx.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;../tempPage/tempPage&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>现在js文件的整体效果如下：</p>
<p><img src="http://49.232.218.190/p7.png" alt="js"></p>
<p>也就是这段代码，至少写在Page里面，你别写到Page外面了。</p>
<p>写完以后，保存，然后点击那个按钮，如果不出意外的话应该是可以跳转了。</p>
<h2 id="3-意外"><a href="#3-意外" class="headerlink" title="3. 意外"></a>3. 意外</h2><p>如果没跳转，看看是不是如下原因：</p>
<ul>
<li>跳转后页面一片大白：卡了，重启一下程序，或者看看你的新页面是不是就没写东西，那肯定白</li>
<li>页面白还有一种情况，那就是你把跳转页面的js文件里的东西都删了，切记切记：<strong><font color="red">新Page的js文件里的东西已经是最简形式，千万不要删任何东西</font></strong>。否则恭喜你喜提大白屏.</li>
<li>点击按钮没有反应：<ul>
<li>查看 bindtap 后面那个名字和代码里面那个名字是否一致，我的都叫jump</li>
<li>卡了，重启</li>
</ul>
</li>
<li>跳转后告诉你 not found：这个原因就多了，归根到底就是微信没找到页面<ul>
<li>检查跳转路径：必须是 <code>../跳转页面所在文件夹名/跳转页面名</code>，且页面名没有任何后缀</li>
<li>检查页面路径，两个页面是否都在文件夹里面包着，然后这个文件夹都在红色的pages下。只有满足这个要求，上面的跳转路径才能生效。</li>
<li>别是用了中文吧？？！！</li>
</ul>
</li>
</ul>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>我这里是用了 index页面往别的页面跳转做示范，但是实际做课设的时候真不一定就是从index页面跳，可能是你自己的A页面往你自己的B页面跳，咋办？？照猫画虎呗。</p>
<p>现在你要从A页面跳到B页面：</p>
<ul>
<li>首先确认两件事：<ul>
<li>AB两页面是否都在文件夹里面，文件夹是否都在 pages 下，也就是说两文件夹同层</li>
<li>Ab两页面的文件夹和页面名是否有中文，确认没有</li>
</ul>
</li>
<li>在A页面中写一个button，并照猫画虎写个bindtap，后面的名字按规范起</li>
<li>在A页面的js文件中，插入上述那段代码，名字必须和你的bindtap一致，url改成<code>../B页面的所在文件夹名称/B页面名称(切记没有后缀)</code></li>
<li>完成</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>运行时数据区概述</title>
    <url>/2022/05/27/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>从这里开始正式进入运行时数据区，运行时数据区是JVM非常核心的一部分，各种内存模型各种垃圾回收都将从这里展开。</p>
<span id="more"></span>

<h1 id="1-运行时数据区"><a href="#1-运行时数据区" class="headerlink" title="1. 运行时数据区"></a>1. 运行时数据区</h1><p>运行时数据区，非常之核心，JVM运行时大部分数据都存在运行时数据区，所以后面大部分的展开，比如各种的字符串，常量池，GC，等等等等一系列的故事都将发生在这里。</p>
<p>首先看一下运行时数据区的图：</p>
<p><img src="/images/runtime/Runtime_data_area.png" alt="runtime"></p>
<p>主要就是包含了：程序计数器、本地方法栈、虚拟机栈、堆、元空间。其中这里先介绍几个简单的，比如程序计数器和本地方法这种的，剩下的虚拟机栈和堆和元空间，都是重点中的重点。</p>
<p>同时扩展一点东西：</p>
<ul>
<li><p>PC寄存器：不涉及 Error 不涉及 GC</p>
</li>
<li><p>虚拟机栈：涉及 Error，比如 StackOverFlowError，不涉及GC，直接弹栈即可。</p>
</li>
<li><p>本地方法栈：涉及 Error，不涉及 GCasd</p>
</li>
<li><p>堆 和 方法区：都涉及 Error 和 GC</p>
</li>
</ul>
<p>这5种东西，一部分是和Java程序共存亡，随着JVM启动而启动，随着JVM销毁而销毁另外的，和线程共存亡。</p>
<p>方法区 和 堆，线程之间公用，剩下的，每一个线程都会有自己独一份的这些东西。</p>
<p>对应的对象就是 Runtime，每一个Java 应用，或者说，一个jvm就对应着一个Runtime对象。</p>
<p>其中，JVM内部还有一些线程：</p>
<ul>
<li><p>虚拟机线程，特别复杂，不说了</p>
</li>
<li><p>周期任务线程，一般用于周期性操作的调度执行</p>
</li>
<li><p>GC线程，支持不同种类的垃圾收集行为</p>
</li>
<li><p>编译线程，将字节码编译成本地代码</p>
</li>
<li><p>信号调度线程，接收信号发给JVM处理</p>
</li>
</ul>
<p>这些东西似乎就没有啥用了，应该不会用到吧。</p>
<h1 id="2-PC寄存器"><a href="#2-PC寄存器" class="headerlink" title="2. PC寄存器"></a>2. PC寄存器</h1><p>所谓PC寄存器，全称 Program Counter Register，也叫程序计数器，主要用于存储下一条要执行的指令的地址。</p>
<p>我们随便写一个程序，然后我们反编译他的 class文件，会看到如下文字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0:bipush   10  </span><br><span class="line">2:istore_1  </span><br><span class="line">3:bipush   20  </span><br><span class="line">4:istore_2</span><br></pre></td></tr></table></figure>

<p>这种的，第一列的数字就是指令地址，第二列以及后面的东西就叫指令，pc寄存器会存储下一条指令的地址，也就是 比如 0 2 这种东西，然后执行引擎会读取pc寄存器里面存储的指令地址所对应的指令，去运行这个指令。</p>
<p>具体流程下图所示：</p>
<p><img src="/images/runtime/pc_register.png" alt="pc_process"></p>
<h2 id="为什幺用PC寄存器"><a href="#为什幺用PC寄存器" class="headerlink" title="为什幺用PC寄存器"></a>为什幺用PC寄存器</h2><p>记录执行位置，并发(CPU轮转)状态下，每个线程都会抢时间片，那么抢到了就会接着执行，这个时候就需要记录当前状态下，该执行那条指令了，PC寄存器就是记录执行状态的。</p>
<p>JVM字节码解释器通过改变PC寄存器的值来记录执行状态。</p>
<h1 id="3-本地方法接口"><a href="#3-本地方法接口" class="headerlink" title="3. 本地方法接口"></a>3. 本地方法接口</h1><p>我们前面一直在说Runtime的事，我们先跳出Runtime，先来看一个东西：本地方法。</p>
<p>首先我们来看一眼JVM的整体结构：</p>
<p><img src="/images/runtime/jvm_structure.jpg" alt="jvm_stu"></p>
<p>看到右下角的两个东西了么：NativeMethodInterface和 NativeMethodLibrary，这两个东西要和 运行时数据区里面的 本地方法栈进行联系，所以我们现看这两块内容。</p>
<h2 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h2><h3 id="什么是本地方法"><a href="#什么是本地方法" class="headerlink" title="什么是本地方法"></a>什么是本地方法</h3><p>何为本地方法，Java 调用一个非Java 实现的方法的接口，这个接口就是本地方法，也就是 NativeMethod，(Native 是个关键字);</p>
<p>再简单说，本地方法就是一个Java方法，但是这个方法的具体实现并不是 Java，多数情况下是 C&#x2F;C++。本地接口的作用就是融合不同语言来为Java所用，最主要还是融合 C&#x2F;C++.</p>
<p>需要注意的是，native 方法因为它本身就是 Java 方法，所以Java 方法上有的东西他都有，比如可以进行权限控制，可以使用同步代码，可以抛出异常，可以有static 修饰等。</p>
<h3 id="为什么要用本地方法"><a href="#为什么要用本地方法" class="headerlink" title="为什么要用本地方法"></a>为什么要用本地方法</h3><p>有时Java需要和外部环境交互，比如操作系统，创建 Thread这种的，或者说有些时候需要特别在以效率，就需要用到NativeMethod</p>
<h3 id="和操作系统的交互"><a href="#和操作系统的交互" class="headerlink" title="和操作系统的交互"></a>和操作系统的交互</h3><p>JVM毕竟不是真是的操作系统，他是要依赖于本地环境，这就不可避免的有C代码，同时如果我们关注效率，也需要C，比如 创建线程，这个就是一个本地方法，调用了操作系统的api，去创建线程。</p>
<p>Sun’s Java 的解释器有一部分就是C写的，JVM内部就已经植入了一部分C代码，所以不可避免的需要和C交互。</p>
<h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>目前Java已经很少用到Native了，除非是一些底层操作，比如调用打印机这种的，还是需要用到C。</p>
<h1 id="4-本地方法栈"><a href="#4-本地方法栈" class="headerlink" title="4. 本地方法栈"></a>4. 本地方法栈</h1><p>至于本地方法栈，这个东西 简单说，似乎不怎么用。这里涉及到了一些虚拟机栈的知识，后面会说。</p>
<ul>
<li><p>Java虚拟机栈使用管理Java方法的，那么很显然本地方法栈就是用来管理本地方法的。</p>
</li>
<li><p>和虚拟机栈同理，本地方法栈也是线程独有的。</p>
</li>
<li><p>同样可以扩展本地方法栈，同样会抛出 StackOverflowError 和 OutOfMemoryError。</p>
</li>
<li><p>当某个线程调用了一个本地方法后，这个本地方法就会进入一个权限的不受虚拟机限制的世界。他和虚拟机有同样的权限。</p>
<ul>
<li><p>本地方法可以调用本地方法接口来访问虚拟机内部的运行时数据区。</p>
</li>
<li><p>可以直接使用本机处理器中的寄存器。</p>
</li>
<li><p>可以直接分配本地内存</p>
</li>
</ul>
</li>
<li><p>并不是所有的 JVM 都支持本地方法，因为虚拟机规范并没有规定本地方法的实现语言等， 所以如果虚拟机不打算使用本地方法，也就无需本地方法栈</p>
</li>
<li><p>Hotspot JVM中，直接把本地方法栈和虚拟机栈合二为一。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收</title>
    <url>/2022/06/02/garbage-collect/</url>
    <content><![CDATA[<p>这章开始进入垃圾回收，只是这一章不讲垃圾回收的具体回收器，而是讲一下垃圾回收的一些基本概念。</p>
<span id="more"></span>

<h1 id="1-GC-垃圾收集"><a href="#1-GC-垃圾收集" class="headerlink" title="1. GC 垃圾收集"></a>1. GC 垃圾收集</h1><p>同理，首先明确几个概念：</p>
<ul>
<li><p>什么是垃圾</p>
</li>
<li><p>为啥要清理垃圾</p>
</li>
<li><p>垃圾回收机制</p>
</li>
</ul>
<h2 id="1-1-什么是垃圾"><a href="#1-1-什么是垃圾" class="headerlink" title="1.1 什么是垃圾"></a>1.1 什么是垃圾</h2><p>垃圾指的是，在程序运行期间没有任何指针指向的对象，这个对象就是垃圾。</p>
<p>如果不及时清理垃圾，这些垃圾对象就会一直存在占用空间，可能导致内存溢出。</p>
<h2 id="1-2-为什么要GC"><a href="#1-2-为什么要GC" class="headerlink" title="1.2 为什么要GC"></a>1.2 为什么要GC</h2><ul>
<li><p>对于高级语言来说，如果不进行GC，内存迟早消耗完，所以需要不断地分配内存和回收内存</p>
</li>
<li><p>除了垃圾回收，GC同时还能整理内存碎片，碎片整理把堆内存移到堆的一端，给新对象腾地方</p>
</li>
<li><p>业务越来越庞大，没有GC程序就没法运行，而经常GC会导致频繁地STW，所以就需要不断的对GC进行优化。</p>
</li>
</ul>
<h2 id="1-3-Java垃圾回收机制"><a href="#1-3-Java垃圾回收机制" class="headerlink" title="1.3 Java垃圾回收机制"></a>1.3 Java垃圾回收机制</h2><ul>
<li><p>自动内存管理，无需开发人员手动分配和释放，降低了内存溢出的可能性。</p>
</li>
<li><p>能让我们更专注于 业务逻辑的开发</p>
</li>
</ul>
<h1 id="2-GC-机制与算法-标记阶段"><a href="#2-GC-机制与算法-标记阶段" class="headerlink" title="2. GC 机制与算法-标记阶段"></a>2. GC 机制与算法-标记阶段</h1><p>大纲：</p>
<ul>
<li><p>标记阶段：引用计数算法</p>
</li>
<li><p>标记阶段：可达性分析算法</p>
</li>
<li><p>对象的 finalization 机制</p>
</li>
<li><p>MAT和JProfiler 的 GC roots 溯源</p>
</li>
<li><p>清除阶段：标记清除算法</p>
</li>
<li><p>清除阶段：复制算法</p>
</li>
<li><p>清除阶段：标记-压缩 算法</p>
</li>
</ul>
<h2 id="2-1-垃圾标记阶段"><a href="#2-1-垃圾标记阶段" class="headerlink" title="2.1 垃圾标记阶段"></a>2.1 垃圾标记阶段</h2><ul>
<li><p>在堆中存放着几乎所有的Java实例，在回收之前，首先要区分哪些是存活对象，哪些对象已经死了，只有已经死亡的对象，GC才会在收集的时候释放他们的内存，这个区分死活的阶段就是<strong>垃圾标记阶段</strong></p>
</li>
<li><p>如何判断一个对象已经死了？就是，没有任何指针指向他，不被任何存活对象引用，那他就死了</p>
</li>
<li><p>判断没有引用的算法有两个：<strong>引用计数算法</strong> 和 <strong>可达性分析算法</strong></p>
</li>
</ul>
<h3 id="2-1-1-引用计数算法"><a href="#2-1-1-引用计数算法" class="headerlink" title="2.1.1 引用计数算法"></a>2.1.1 引用计数算法</h3><ul>
<li><p>Reference Counting，比较简单，就是给每一个对象保留一个引用计数器来记录被引用的情况</p>
</li>
<li><p>当一个对象引用A对象，A的计数器+1，同理，引用失效，计数器 - 1</p>
</li>
<li><p>优点：实现简单，垃圾对象便于标识；判定效率高，没有延迟</p>
</li>
<li><p>缺点：</p>
<ul>
<li><p>需要另外的字段存储计数器，有额外存储空间开销</p>
</li>
<li><p>每次操作都需要更新计数器，伴随着 - + 操作，额外时间开销</p>
</li>
<li><p>无法处理循环引用问题，导致 Java 垃圾回收器不使用这个东西</p>
<blockquote>
<p>什么叫循环引用：</p>
<p><img src="/images/gc/gc_ref_counting.png"></p>
<p>如上图第二种情况，如果三个对象循环引用，那么根据技术算法，他们的计数器都是1，不是0，但是其实，这三个对象已经是垃圾了，但是由于算法问题，这个垃圾不被回收。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>小结：</p>
<ul>
<li><p>引用计数算法是很多语言的标记算法，比如python</p>
</li>
<li><p>具体场景下，可能还会使用引用计数，来提高系统的吞吐量</p>
</li>
<li><p>Java没有选择引用计数是因为循环依赖不好处理</p>
</li>
<li><p>python如何解决循环依赖：1. 解除相互之间的引用；2.引入强引用和弱引用</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-1-2-可达性分析算法-根搜索，追踪性垃圾收集"><a href="#2-1-2-可达性分析算法-根搜索，追踪性垃圾收集" class="headerlink" title="2.1.2 可达性分析算法(根搜索，追踪性垃圾收集)"></a>2.1.2 可达性分析算法(根搜索，追踪性垃圾收集)</h3><ul>
<li><p>相对引用计数来说，可达算法同样简单高效，而且这个算法可以很好的解决循环引用问题</p>
</li>
<li><p>Java C# 都采用可达算法</p>
</li>
</ul>
<p>说先说一个基本概念：GC Roots：一个必须活跃的引用集合，在这个基础上，进行可达性分析算法的基本思路</p>
<ul>
<li><p>以GC Roots 为起始点，往下<strong>搜索被根对象集合连接的目标对象是否可达</strong></p>
</li>
<li><p>经过可达性分析后，内存中存活的对象直接或间接的被根对象集合连接着，搜索过的路径就叫做 <strong>引用链</strong></p>
</li>
<li><p>如果目标对象没有被任何引用链相连，则不可达，说明对象已经死亡，需要被收集</p>
</li>
<li><p>可达算法中，只有被根对象集合直接或间接引用的对象，才是存活对象</p>
</li>
<li><p>可达性分析必须在数据的快照中进行，来保证数据一致性</p>
</li>
<li><p>这个算法会导致 STW，即使是号称不会STW的CMS(新的垃圾回收器)，在枚举根节点的时候也是会停顿的。</p>
</li>
</ul>
<h2 id="2-2-详细说说-GC-Roots"><a href="#2-2-详细说说-GC-Roots" class="headerlink" title="2.2 详细说说 GC Roots"></a>2.2 详细说说 GC Roots</h2><p>GC Roots 中包含一下内容：</p>
<ul>
<li><p>虚拟机栈中引用的对象，比如方法参数和局部变量</p>
</li>
<li><p>本地方法栈中 JNI(本地方法) 中引用的对象</p>
</li>
<li><p>方法区中，类的静态属性引用的对象</p>
</li>
<li><p>方法区中，常量引用的对象</p>
</li>
<li><p>被同步锁 synchronized 所持有的对象</p>
</li>
<li><p>JVM内部的引用，比如基本数据类型的 Class，各种异常等常驻对象</p>
</li>
<li><p>除了这些以外，根据用户所选用的垃圾收集器和和内存区域不同，还可能有其他的对象临时加入roots，举个例子就是 分代收集和局部回收。就是说，你要收集堆中年轻代的数据，那么年轻代外面，老年代的数据也可能被认为是roots。</p>
</li>
<li><p>可以这么认为，如果一个指针指向堆中的一个对象，但是这个指针不在堆中，那么他就可能是 root，那么根据上面所说的分代回收，我认为可以这么理解，指针指向了一个待回收区域但是指针不在这个区域，对于这个区域来说，这个指针就是 root。当然，这个区域一般都是堆，毕竟只有 堆 和 方法区有垃圾收集，而且方法区一般不收集。</p>
</li>
</ul>
<p>我觉得可以这么理解，如果GC区域不同，那么GC Roots 也就不确定，GC Roots归根到底就是除了这个被回收区域以外有可能用到这个区域中对象的地方，就是GC Roots，比如我们要收集堆，那么堆中的对象大多被栈指向，所以栈在这里就是堆的GC Roots，那么如果我们要回收年轻代，那么老年代也有可能是GC Roots。</p>
<h2 id="2-3-对象的-finalize机制"><a href="#2-3-对象的-finalize机制" class="headerlink" title="2.3 对象的 finalize机制"></a>2.3 对象的 finalize机制</h2><p>对象Object内有一个方法：finalize() 方法，这个方法是对象被GC的时候，释放之前，会调用这么一个方法，有那么点类似于析构函数，我们最好不要手动去调用他，最好让JVM去调用他。</p>
<p>就是因为finalize的存在，导致一个对象在虚拟机中存在三种状态：</p>
<ul>
<li><p>可触及的：GC Roots 连接的对象，肯定是存活的</p>
</li>
<li><p>可复活的：对象的所有引用都被释放，但是对象可能在 finalize方法中复活</p>
</li>
<li><p>不可触及的：对象的finalize方法被调用，且对象没有复活，那么这个对象就是不可触及的，一个不可触及的对象肯定不能复活，因为一个对象的finalize方法只能调用一次。</p>
</li>
</ul>
<p>只有不可触及的对象，才会被回收。</p>
<h2 id="2-4-总结标记过程"><a href="#2-4-总结标记过程" class="headerlink" title="2.4 总结标记过程"></a>2.4 总结标记过程</h2><p>就因为有finalize方法的存在，gc不能仅仅通过引用链来判断是否回收，总共需要两次标记：</p>
<ul>
<li><p>如果对象到GC Roots 之间没有引用链，进行第一次标记</p>
</li>
<li><p>进行筛选，判断该对象的finalize方法有没有必要执行：</p>
<ul>
<li><p>如果对象没有重写 finalize 方法或者 finalize方法已经被调用过了，则被判定位不可触及对象</p>
</li>
<li><p>如果对象重写了finalize方法，且还未执行过，则会把这个对象插入F-Queue 中，一个被虚拟机自动创建的，低优先级的线程 Finalizer，挨个触发队列里面的finalize方法。</p>
</li>
<li><p>finalize方法是对象最后逃离死亡的机会，稍后GC会对 F-Queue里面的对象进行第二次标记，如果调用finalize，方法里面和引用链中任何一个对象建立了联系，那么这个对象就被移出“即将回收集合”。之后，如果对象再次没有引用的情况，这时finalize方法不会调用，finalize方法只执行一次，然后对象直接变成不可触及。</p>
</li>
</ul>
</li>
</ul>
<h2 id="省略"><a href="#省略" class="headerlink" title="省略"></a>省略</h2><p>中间差了一堆东西，有堆相关工具的使用，以后有需要看 P144 - P146</p>
<h1 id="3-GC-清理阶段"><a href="#3-GC-清理阶段" class="headerlink" title="3. GC -清理阶段"></a>3. GC -清理阶段</h1><p>成功区分出存活对象和死亡对象后，JVM要进行下一步，也就是清理垃圾，释放内存，给下面的对象腾地方</p>
<p>具体算法下面三个：</p>
<ul>
<li><p>复制算法 Copying</p>
</li>
<li><p>标记-清除 算法 Mark-Sweep</p>
</li>
<li><p>标记-压缩 算法 Mark-Compact</p>
</li>
</ul>
<h2 id="3-1-标记清除算法"><a href="#3-1-标记清除算法" class="headerlink" title="3.1 标记清除算法"></a>3.1 标记清除算法</h2><p>标记清除是一个比较低级，常见的垃圾回收算法，第一次被用在 Lisp语言上(Lisp：世界上第一个有GC的语言)。</p>
<h3 id="3-1-1-执行过程"><a href="#3-1-1-执行过程" class="headerlink" title="3.1.1 执行过程"></a>3.1.1 执行过程</h3><p>当内存满了以后，就会停止整个程序(包括用户线程，这个停止就叫 Stop The World，也就是我们说的 STW)，然后进行下面两件事：</p>
<ul>
<li><p>Collector进行标记，从GCRoots 开始遍历可达对象(很显然就是我们前面说的可达性分析算法)，在对象头header中标记这是个可达对象，被引用对象，注意，标记的不是垃圾，没被标记的才是垃圾。</p>
</li>
<li><p>Collector进行清理，遍历对象，检查对象头的可达标记，如果没有，则被回收。</p>
</li>
</ul>
<h3 id="3-1-2-缺点"><a href="#3-1-2-缺点" class="headerlink" title="3.1.2 缺点"></a>3.1.2 缺点</h3><ul>
<li><p>效率不高，主要原因就是需要遍历，怎么遍历的？递归</p>
</li>
<li><p>在GC的时候需要停止整个程序，用户体验不好</p>
</li>
<li><p>清理出来的内存不是连续的，所以同时还需要维护一个内存空闲列表，我们之前说对象内存分配的时候 Chapter07-23 下说过。</p>
</li>
</ul>
<h3 id="3-1-3-注-清除到底指的啥"><a href="#3-1-3-注-清除到底指的啥" class="headerlink" title="3.1.3 注:清除到底指的啥"></a>3.1.3 注:清除到底指的啥</h3><p>清除指的不是说直接这块内存上的东西就清空了，并非。</p>
<p>垃圾还会留着，但是内存地址会写到空闲列表中，如果再次分配对象，新对象会覆盖垃圾对象。</p>
<h2 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h2><p>为了解决标记清除算法低效的问题，提出的复制算法，这个算法同理 堆中年轻代的GC。</p>
<p>思路：</p>
<p>将内存分为两半，一半空着，另一半放数据，当数据区进行垃圾回收时，同理先进行可达性分析，但是，在分析的同时，如果发现对象是可达的，就会把对象复制到另一半内存中，不是复制内存地址，而是整个对象拷贝(拷贝肯定是规整的拷贝)。然后可达性分析完成，数据也就全部复制到另一半，就说明当前这块内存已经没有有用数据了，全都是垃圾，所以直接清理这一半内存即可。然后下一次GC，把对象全都复制到这里即可。</p>
<h3 id="3-2-1-优点"><a href="#3-2-1-优点" class="headerlink" title="3.2.1 优点"></a>3.2.1 优点</h3><ul>
<li><p>简单，快速</p>
</li>
<li><p>复制以后内存连续，不会出现内存碎片</p>
</li>
</ul>
<h3 id="3-2-2-缺点"><a href="#3-2-2-缺点" class="headerlink" title="3.2.2 缺点"></a>3.2.2 缺点</h3><ul>
<li>需要两倍大的内存空间</li>
</ul>
<h3 id="3-2-3-注意"><a href="#3-2-3-注意" class="headerlink" title="3.2.3 注意"></a>3.2.3 注意</h3><p>如果空间的存活对象多，那一次直接全盘复制一轮，垃圾没几个，就会导致效率过低。</p>
<p>这个算法的应用场景最好是存活对象不太多的时候。垃圾多，复制的少，就会效率高。所以这就解释了为啥新生代采用类似这个算法来GC，原因就是新生代的对象大多数朝生暮死。</p>
<h2 id="3-3-标记-压缩-整理-算法"><a href="#3-3-标记-压缩-整理-算法" class="headerlink" title="3.3 标记-压缩(整理) 算法"></a>3.3 标记-压缩(整理) 算法</h2><h3 id="3-3-1-背景"><a href="#3-3-1-背景" class="headerlink" title="3.3.1 背景"></a>3.3.1 背景</h3><p>复制算法适用于存活对象少，垃圾多的地方，比如新生代，所以新生代采用复制算法，但是老年代普遍对象比较大，岁数大，复制算法不再适用，所以基于老年代，就需要其他的垃圾收集算法。</p>
<p>标记清除算法可以用在老年代，但是效率底下，会产生内存碎片，所以JVM在次基础上，退出了 标记压缩算法。</p>
<h3 id="3-3-2-执行过程"><a href="#3-3-2-执行过程" class="headerlink" title="3.3.2 执行过程"></a>3.3.2 执行过程</h3><p>第一阶段和标记清除算法一样，也是需要进行遍历标记。</p>
<p>然后，将所有存活对象按顺序压缩到内存的一端，然后这一端以外的对象全部清除。</p>
<h3 id="3-3-3-优点"><a href="#3-3-3-优点" class="headerlink" title="3.3.3 优点"></a>3.3.3 优点</h3><ul>
<li><p>解决了标记清除算法中 内存碎片的问题</p>
</li>
<li><p>解决了复制算法中内存双倍的问题</p>
</li>
</ul>
<h3 id="3-3-4-缺点"><a href="#3-3-4-缺点" class="headerlink" title="3.3.4 缺点"></a>3.3.4 缺点</h3><ul>
<li><p>效率低于复制算法</p>
</li>
<li><p>移动数据时，指针的指向需要修改</p>
</li>
<li><p>移动过程中 STW</p>
</li>
</ul>
<h1 id="4-垃圾收集拓展"><a href="#4-垃圾收集拓展" class="headerlink" title="4. 垃圾收集拓展"></a>4. 垃圾收集拓展</h1><p>拓展两个东西：</p>
<ul>
<li><p>增量收集算法</p>
</li>
<li><p>分区算法</p>
</li>
</ul>
<p>这两个算法都是为了提高垃圾收集效率，降低STW。</p>
<h2 id="4-1-增量收集算法"><a href="#4-1-增量收集算法" class="headerlink" title="4.1 增量收集算法"></a>4.1 增量收集算法</h2><p>我们之前看三种垃圾收集算法，有个共同的特点，就是STW时间长，垃圾攒的太多了，一次收集有点费劲，所以出现了增量收集算法。</p>
<p>思想如下：</p>
<p>弄一个GC线程，一个用户线程，咱们也别等到他内存沾满了GC，咱们直接 用户线程和GC线程交替执行，这样就会节省GC时间，减短STW时间，特别好。</p>
<p>然而问题就是：切换线程也很消耗资源。</p>
<h2 id="4-2-分区算法"><a href="#4-2-分区算法" class="headerlink" title="4.2 分区算法"></a>4.2 分区算法</h2><p>众所周知，堆空间越大，收集的区域越大，收集就越费劲，所以我们干脆把堆分成n多不同小区域，分开收集，这样就可以降低消耗时间，降低STW。</p>
<p>分代算法把对象分为了年轻代和老年代，分区算法就是把整个堆分成了若干小区域。</p>
<p>每个区域独立分配，独立回收，好处就是可以控制一次收集多少个区域。</p>
<p>缺点：可能会导致GC 频繁，线程切换频率提高，降低吞吐量。</p>
<h1 id="5-垃圾回收的相关概念"><a href="#5-垃圾回收的相关概念" class="headerlink" title="5. 垃圾回收的相关概念"></a>5. 垃圾回收的相关概念</h1><ul>
<li><p>System.gc() 的理解</p>
</li>
<li><p>内存溢出与泄露</p>
</li>
<li><p>Stop The World</p>
</li>
<li><p>垃圾回收的并行与并发</p>
</li>
<li><p>安全点与安全区域：只有在安全点才能停止用户线程</p>
</li>
</ul>
<h2 id="5-1-System-gc"><a href="#5-1-System-gc" class="headerlink" title="5.1 System.gc()"></a>5.1 System.gc()</h2><blockquote>
<p>本地方法，System.gc() 调用 Runtime.getRuntime().gc()</p>
</blockquote>
<p>我们可以通过 System.gc() 和 Runtime.getRuntime().gc() 来显式调用 FullGC(对整个堆进行回收)。</p>
<p>但是同时，JVM附带一个免责声明，JVM不保证你调用gc() 就一定能执行GC。</p>
<p>一般情况下，GC应该是自动进行的，不应该是我们手动进行，否则就太麻烦了，有一种应用场景是我们要写一个性能基准，我们手动调用gc。</p>
<p>所以说，我们可以认为 System.gc() 是提醒JVM进行垃圾收集，至于JVM干不干活？不知道。</p>
<p>详细请看：pri.TestSystemGC 和 pri.LocalVarGC</p>
<h2 id="5-2-内存溢出-Out-Of-Memory"><a href="#5-2-内存溢出-Out-Of-Memory" class="headerlink" title="5.2 内存溢出(Out Of Memory)"></a>5.2 内存溢出(Out Of Memory)</h2><p>首先，什么叫内存溢出：java给的解释是，内存不够了，而且gc完了也不够，那就内存溢出</p>
<p>为什么会内存溢出：</p>
<ul>
<li><p>堆空间大小设置的不够</p>
</li>
<li><p>大对象太多而且不能回收，最后就会沾满。jdk7中会抛出：java.lang.OutOfMemory: PermGen space; jdk8中则会抛出：java.lang.OutOfMemory: Metaspace</p>
</li>
</ul>
<p>这里可以看出，再抛出 OOM 之前，肯定要触发一次GC，去尽可能腾出空间</p>
<ul>
<li>比如：他会尝试去回收软引用指向的对象</li>
</ul>
<p>但是，也并非任何情况下都会进行GC，如果我们要分配一个超大的对象，JVM判断整个堆压根就不够用，GC没有意义，就不会GC，直接抛出OOM。</p>
<h2 id="5-3-内存泄露-Memory-Leak"><a href="#5-3-内存泄露-Memory-Leak" class="headerlink" title="5.3 内存泄露(Memory Leak)"></a>5.3 内存泄露(Memory Leak)</h2><p>总的来说，就是一个对象，程序不会再用到他了，但是GC又不能把它回收，这就很恶心，这就是内存泄露.</p>
<p>实际情况是，我们的一些代码习惯不好，导致一些对象有了特别长的生命周期，最终导致 OOM，这个也可以理解成<strong>宽泛意义上的内存泄露。</strong></p>
<p>尽管发生内存泄露不会立马导致程序崩溃，但是会逐步侵蚀内存，最终有可能导致内存溢出。</p>
<blockquote>
<p>注意：这里说的所有内存不是真实内存，而是虚拟机内存，虚拟机内存取决于物理内存。</p>
</blockquote>
<p>尤其注意：要举内存泄露的例子，不要举循环引用。循环引用是不是内存泄露？是，但是Java不会发生这种情况，因为Java没有采用引用计数算法。</p>
<p>具体举几个例子：</p>
<ul>
<li><p>单例模式的某些对象，因为是单例，所以可能生命周期特别长，然后单例里面引用了外部的一些生命周期短的对象，用完了不释放</p>
</li>
<li><p>各种流，比如 socket，io 等东西，用完了不close</p>
</li>
<li><p>看弹幕说有ThreadLocal？</p>
</li>
</ul>
<h2 id="5-4-并发和并行"><a href="#5-4-并发和并行" class="headerlink" title="5.4 并发和并行"></a>5.4 并发和并行</h2><p>并发：就是单核CPU，来回切换时间片，来达到宏观并行，看似同时操作，实际频繁切换。同一个时间段上同时发生。</p>
<p>并行：多核CPU，每个CPU都在干活，好多任务同时进行，就是并行。同一个时间点上同时发生</p>
<h2 id="5-5-垃圾回收的并发与并行"><a href="#5-5-垃圾回收的并发与并行" class="headerlink" title="5.5 垃圾回收的并发与并行"></a>5.5 垃圾回收的并发与并行</h2><p>并行(Parallel)的垃圾回收器：</p>
<p><strong>多条垃圾回收线程并行工作</strong>，但是用户线程仍然停止，比如：ParNew，Parallel Scavenge，Parallel Old</p>
<p>串行(Serial) 的垃圾回收器：</p>
<p>与并行的对应，只有一个垃圾回收线程工作，同样STW</p>
<p>并发(Concurrent)的垃圾回收器：</p>
<p>回收线程和用户线程同时进行，但是不一定是并行的。得看你CPU，单核CPU那就是靠线程切换来达到并发效果，多核那就是GC和用户在两个CPU上。这样看起来不会暂停用户线程(只要是GC，就必定需要暂停用户线程)。</p>
<p>比如G1,CMS。</p>
<h2 id="5-6-安全点-Safe-Point"><a href="#5-6-安全点-Safe-Point" class="headerlink" title="5.6 安全点 Safe Point"></a>5.6 安全点 Safe Point</h2><p>并非任何时间都可以停下来GC，只有在特定的时间点才会进行GC，STW，那么这个时间点就是 sp。</p>
<p>sp的选择挺重要的，如果sp过少，那么gc次数少，如果sp多，那么经常gc就会导致性能下降。大多数指令的执行时间都比较短。那么选择sp的一个标准就是 “是否具有让程序长时间执行的特征”。选择一个执行时间长的指令作为sp，比如 方法调用 循环跳转 异常跳转。</p>
<p>所以，如果保证所有线程都走到了安全点？两种办法：</p>
<ul>
<li><p>抢先式中断：先让所有线程停下来，然后让没有到达安全点的线程继续跑到安全点。然后这种方法已经不用了</p>
</li>
<li><p>主动式中断：设置一个中断标志，线程跑到安全点主动轮询这个标志，如果标志是true，说明JVM现在要GC，那么线程停止。</p>
</li>
</ul>
<h2 id="5-7-安全区域-Safe-Region"><a href="#5-7-安全区域-Safe-Region" class="headerlink" title="5.7 安全区域 Safe Region"></a>5.7 安全区域 Safe Region</h2><p>安全点确保了正在执行的线程可以停止进行GC，如果一个线程sleep了，他没法运行，咋办，这时候引入安全区域。</p>
<p>在一个区域内，引用不会发生改变，就说明在这个区域内任何地方都是安全的，那么就可以进行GC。这个区域就是sr。sr可以看作是sp的扩展。</p>
<h1 id="6-四种引用"><a href="#6-四种引用" class="headerlink" title="6. 四种引用"></a>6. 四种引用</h1><p>我们希望有这么一类对象，当我们内存不够的时候，触发GC，然后GC完了还是不够，那么JVM就会根据引用的不同，自动抛弃一些对象来腾地方。那么这里就涉及到了四种引用：强 软 弱 虚。四种引用的强度依次递减。</p>
<p>涉及到的对象：</p>
<p>父类：java.lang.ref.Reference 这是个抽象类</p>
<p>实现：WeakReference(弱), SoftReference(软), PhantomReference(虚)</p>
<h2 id="6-1-概括的说一下四种引用："><a href="#6-1-概括的说一下四种引用：" class="headerlink" title="6.1 概括的说一下四种引用："></a>6.1 概括的说一下四种引用：</h2><ul>
<li><p>强引用 StrongReference：最传统的引用方式，代码中最普遍存在的引用赋值，Object o &#x3D; new Object() 这种引用关系，只要引用关系还在，任何情况下GC都不能释放对象。</p>
</li>
<li><p>软引用 SoftReference：在系统要内存溢出之前，会把这些引用指向的对象进行二次回收，如果还是不够，才会抛出OOM</p>
</li>
<li><p>弱引用 WeakReference：被弱引用关联的对象只能活到下一次GC，下一次GC无论内存够不够，都会回收</p>
</li>
<li><p>虚引用 PhantomReference：一个对象是否存在虚引用，完全不会影响他的生存时间，我们也无法通过虚引用获取实例，设置虚引用的<strong>唯一目的就是他关联的对象被收集了以后得到一个系统通知</strong>。</p>
</li>
</ul>
<h2 id="6-2-强引用"><a href="#6-2-强引用" class="headerlink" title="6.2 强引用"></a>6.2 强引用</h2><p>这种引用在程序中最常见，我们直接通过new直接创建一个对象，然后直接把这个对象赋值给一个变量，那么就构成了强引用。</p>
<p>强引用是可触及的(还有指向的时候，我们手动置为null不算)，GC 永远不会回收他。</p>
<p>对于一个普通的对象，只要对象超过了作用域，或者我们手动把变量变为null，则对象会被GC。</p>
<p>相对的，我们把软 弱 虚 表示为：软可触及，弱可触及，虚可触及。他们都是在一定情景下可以被回收，只有强可达不可能被回收。</p>
<p>所以强引用是造成内存泄漏的主要原因.</p>
<h2 id="6-3-软引用-Soft-Reference"><a href="#6-3-软引用-Soft-Reference" class="headerlink" title="6.3 软引用 Soft Reference"></a>6.3 软引用 Soft Reference</h2><p>软引用用来描述一些虽然存活，但是不重要的对象，如果要发生内存泄漏，GC会先回收所有的软引用指向的对象，如果内存还是不够，则会抛出OOM异常。一句话概括：内存不足即回收。</p>
<p>软引用使用场景：高速缓存，如果还有内存，则会使用缓存，提高速度，如果内存没了，就会清除缓存，免得因为缓存而导致内存溢出。</p>
<p>虚拟机在某一时刻决定清理软可达的对象时，就会清理软引用。我们也可以把软引用放入一个队列，依次清理。</p>
<p>类似弱引用，区别就是JVM迫不得已才会回收软科大对象，弱引用是直接就回收了。</p>
<h2 id="6-4-弱引用-Weak-Reference"><a href="#6-4-弱引用-Weak-Reference" class="headerlink" title="6.4 弱引用 Weak Reference"></a>6.4 弱引用 Weak Reference</h2><p>只被弱引用关联的对象只能活到下一次GC，无论下一次GC是否有空间，弱引用关联的对象都会被回收。一句话概括：发现即回收。</p>
<p>但是，由于GC线程的优先级比较低，所以可能不能马上发现弱引用，所以弱引用可能也能存活很长时间。</p>
<p>这个东西同理和软引用一样，我们也可以弄一个队列，把弱引用放入队列中进行处理。</p>
<p>弱引用和软引用适合做缓存，如果内存不够了就释放内存，内存够就放缓存。</p>
<h2 id="6-5-虚引用-Phantom-Reference"><a href="#6-5-虚引用-Phantom-Reference" class="headerlink" title="6.5 虚引用 Phantom Reference"></a>6.5 虚引用 Phantom Reference</h2><p>这东西，完全不决定对象的生命周期，有跟没有一个样，甚至我们没法像前两种引用一样去get。</p>
<p>这东西唯一的作用，就是对象被回收的时候我们会收到一个系统通知。</p>
<p>同时这个引用在创建的时候必须传入一个回收队列。</p>
<p>因为，系统回收一个对象如果发现这个对象有一个虚引用，就会回收后把这个虚引用放入引用队列，来进行通知。</p>
<h2 id="6-6-代码"><a href="#6-6-代码" class="headerlink" title="6.6 代码"></a>6.6 代码</h2><p>上面说的十分抽象，这里给一段代码看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对于强 软 弱 引用 代码如下：</span></span><br><span class="line"><span class="comment"> * 软和弱引用好歹可以通过get得到他们指向的对象，我们gc以后通过get去获取对象看看情况，</span></span><br><span class="line"><span class="comment"> * 但是对于虚引用那就是另外一种情况了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 强引用，除非null才回收</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 软引用，内存不足及回收</span></span><br><span class="line">        SoftReference&lt;User&gt; u2 = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 弱引用，发现及回收</span></span><br><span class="line">        WeakReference&lt;User&gt; u3 = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// u1 还在，u2 看情况，如果内存满了就没了，u3 八成是没了</span></span><br><span class="line">        u1.get();</span><br><span class="line">        u2.get();</span><br><span class="line">        u3.get();</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面仅仅是强软弱引用的情况，对于虚引用，那得下面专门说了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//package pri;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> PhantomReferenceTest obj;</span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个线程用于监听ReferenceQueue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckReferenceQueue</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(queue != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 前面我们说到了第二次gc会把obj对象彻底清理掉，因为finlize已经执行过了</span></span><br><span class="line">                    <span class="comment">// 所以虚引用指向的对象被回收时，是怎么个流程？</span></span><br><span class="line">                    <span class="comment">// 我们创建虚引用的时候传入了一个队列，回收时，这个队列就会接收到这个虚引用，</span></span><br><span class="line">                    <span class="comment">// 但是注意，虚引用和软弱引用不一样，虚引用压根就没法get到他指向的那个对象</span></span><br><span class="line">                    <span class="comment">// 所以这里其实仅仅就是通知一下这个队列：ok，现在有一个虚引用指向的对象被我gc回收了，</span></span><br><span class="line">                    <span class="comment">// 虚引用就是充当一个信号的作用</span></span><br><span class="line"></span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="comment">// 从引用队列中得到虚引用，如果得到了，说明gc的时候obj被回收了，</span></span><br><span class="line">                        <span class="comment">// 因为只有真正被回收，才会把虚引用传给队列。</span></span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) queue.remove();</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;objt=&quot;</span> + objt);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 最后判断一下，虚引用不为null，说明回收成功,然后回到108行</span></span><br><span class="line">                    <span class="keyword">if</span>(objt != <span class="literal">null</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;objt != null,队列中可以得到虚引用，证明回收成功&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finlize start&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;重新给obj赋值为this，finlize中把obj救活了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先创建一个自己的强引用</span></span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">PhantomReferenceTest</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建引用队列，这个玩意待会儿会接收gc信息</span></span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个监听ReferenceQueue的线程，同时设置为守护线程，也就是这个线程不会随着main线程的结束而结束</span></span><br><span class="line">        <span class="type">CheckReferenceQueue</span> <span class="variable">checkReferenceQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckReferenceQueue</span>();</span><br><span class="line">        checkReferenceQueue.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        checkReferenceQueue.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给obj添加虚引用，创建虚引用的同时需要指定引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; ref = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, queue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 很好，我们先试试虚引用能不能像软弱引用一样get，发现不行，也就是说虚引用仅仅就充当一个信号的作用</span></span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;第一次GC&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 我们进行第一轮gc，我们给强引用置空，这个时候虚引用指向的这个对象就没有强引用，</span></span><br><span class="line">            <span class="comment">// 按理说会直接回收掉</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            System.gc();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 但是我们发现这个时候obj居然不为空，居然还是this，这是为啥？</span></span><br><span class="line">            <span class="comment">// 因为我们上面重写了finlize方法，这个方法里面复活了obj，让obj重新回到了可触及的状态</span></span><br><span class="line">            <span class="comment">// 所以第一轮gc并没有清理掉obj</span></span><br><span class="line">            <span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj == null&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj != null, finlize生效使obj复活&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;第二次GC&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 很好，我们开始进行第二轮gc，再一次清除强引用指向并调用gc开始清理</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            System.gc();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ok，这个时候先不要着急看这里，回到上面的第11行，我们从第十一行接着分析。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 行了，上面的队列刘晨我们走完了，最后这里收个尾，最后判断一下obj是不是null</span></span><br><span class="line">            <span class="comment">// 是的话，ok，回收成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;obj == null?  &quot;</span> + (obj == <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-堆</title>
    <url>/2022/05/28/jvm-heap/</url>
    <content><![CDATA[<p>很好，上一章讲了栈，这里开始看看堆是怎么一个情况。</p>
<blockquote>
<p>首先要说的一点是，整个这一章，都是关于堆的，在网课里面堆讲了30集，着实离谱，而且东西奇多，所以笔记也会多到离谱</p>
</blockquote>
<span id="more"></span>

<h1 id="1-堆的概述"><a href="#1-堆的概述" class="headerlink" title="1. 堆的概述"></a>1. 堆的概述</h1><ul>
<li><p>一个JVM实例只存在一个堆内存，堆也是 Java内存管理的核心区域</p>
<blockquote>
<p>一个进程对应一个JVM实例，JVM实例只有一个Runtime，Runtime里面只有堆和方法区是线程公用，所以说的直白了，一个进程只有一个堆</p>
</blockquote>
</li>
<li><p>JVM启动时堆的大小已经确定</p>
</li>
<li><p>堆的大小可以调节</p>
</li>
<li><p>Java虚拟机规范中规定，堆可以处于物理不连续的内存上，但是逻辑上应视为连续。</p>
<blockquote>
<p>如何证明堆是进程唯一的？需要用到一个工具，在 java.bin 目录下，jvisualvm，这个东西可以看到目前的java进程信息，(需要安装一个插件，VisualGC，工具里面就能安装).然后进入 visualGC</p>
</blockquote>
</li>
<li><p>即使整个线程共用一个堆，对内部还是有线程私有的缓冲区，最典型的就是 ThreadLocal，Buffer，TLAB Allocation，很好，目前我都不知道啥意思。</p>
</li>
<li><p>几乎所有的对象实例都分配在堆上，注意是几乎，不是所有，随着 JVM 的更新，JVM会进行逃逸检测，栈上也可以村对象了。</p>
</li>
<li><p>数组和对象可能永远不会存在栈上，栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
<blockquote>
<p>官网中JVM规范说的是所有，所以引出了下一条</p>
</blockquote>
</li>
<li><p>方法结束后，堆中的对象不会马上被删除，仅仅在垃圾收集的时候才会被删除。</p>
<blockquote>
<p>这里解释一下什么意思，一个方法，方法里面有引用，指向堆中的实例，当方法执行完成后，栈帧出栈，这时候引用就没了，就不在指向堆了，这个时候听不会马上GC，因为影响效率，他会在堆满了的时候去进行垃圾收集。</p>
</blockquote>
<blockquote>
<p>这里老师的原话是：出栈后引用为空，很好现在回来看，显然是栈帧出栈，局部变量表停止指向</p>
</blockquote>
</li>
<li><p>堆是GC作用的重点区域。</p>
</li>
</ul>
<h1 id="2-堆空间内存细分"><a href="#2-堆空间内存细分" class="headerlink" title="2. 堆空间内存细分"></a>2. 堆空间内存细分</h1><p>现代垃圾收集器大部分都是基于分带收集论涉及，对空间细分为：</p>
<ul>
<li><p>java7 包括之前的JVM 堆内存逻辑上分为 3部分：新生区 + 养老区 + 永久区</p>
<ul>
<li><p>Young Generation Space -&gt; 新生区 Young&#x2F;New</p>
<blockquote>
<p>又被划分为 Eden 区 和 Survivor 区</p>
</blockquote>
</li>
<li><p>Tenure Generation space -&gt; 养老区 Old&#x2F;Tenure</p>
</li>
<li><p>Permanent Space -&gt; 永久区 Perm</p>
</li>
</ul>
</li>
<li><p>java8 以后堆内存逻辑上分为3部分：新生区 + 养老区 + 元空间</p>
<ul>
<li><p>Young Generation Space 新生区 Young&#x2F;New</p>
<blockquote>
<p>同理分为 Eden Survivor</p>
</blockquote>
</li>
<li><p>Tenure Generation Space 养老区 Old&#x2F;Tenure</p>
</li>
<li><p>Meta Space 元空间 Meta</p>
</li>
</ul>
</li>
</ul>
<p>需要注意的是，永久代和元空间其实并不属于 堆，而是属于方法区，所以在这里不细说永久代。 如何证明堆包括元空间和养老代？还是昨天那个工具：Jvisualvm，里面的 visualGC， 里面 三块，enden survivor tenure 加起来 就是你设置的 堆的大小。</p>
<p>在Java 中分别叫 PSYoungGen&#x3D;新生区 ParOldGen&#x3D;养老区 MetaGen&#x2F;PSPermGen&#x3D;元空间&#x2F;永久区</p>
<h1 id="3-设置堆空间大小"><a href="#3-设置堆空间大小" class="headerlink" title="3. 设置堆空间大小"></a>3. 设置堆空间大小</h1><ul>
<li><p>堆的大小在JVM启动的时候就已经设定好了，可以通过 -Xmx 和 -Xms 来设置</p>
<ul>
<li><p>-Xms 用来表示堆区的初始内存，等价于： -XX:InitialHeapSize</p>
</li>
<li><p>-Xmx 用来表示堆区的最大内存，等价于：-XX:MaxHeapSize</p>
<blockquote>
<p>-X 是 JVM 参数，ms &#x3D; memory start</p>
</blockquote>
</li>
</ul>
</li>
<li><p>一旦堆区的内存大小超过 -Xmx，就会跑出 OutOfMemoryError异常。</p>
</li>
<li><p>通常会将-Xms 和 -Xmx配置相同的值，目的就是为了能够在Java垃圾回收机制清理完堆区后 不需要重新分割计算堆区的大小，从而提供性能。</p>
</li>
<li><p>默认情况下，初始内存大小：物理电脑内存大小 &#x2F; 64,最大内存：物理电脑内存大小 &#x2F; 4</p>
</li>
</ul>
<h1 id="4-堆的年轻代和老年代"><a href="#4-堆的年轻代和老年代" class="headerlink" title="4. 堆的年轻代和老年代"></a>4. 堆的年轻代和老年代</h1><p>别说话，看图： </p>
<p><img src="/../images/runtime/HeapOldGenAndYoungGen.png" alt="heap"></p>
<p>存储在JVM中的Java对象可以分为两类：</p>
<ul>
<li><p>生命周期比较短的瞬时对象，创建消亡都非常迅速</p>
</li>
<li><p>生命周期比较长，极端情况下和JVM的声明周期一样长</p>
</li>
</ul>
<p>创建出来的对象先放在 年轻代的Eden 区，进行一轮垃圾回收之后，如果是垃圾了，就直接回收了， 如果不是垃圾，说明对象幸存，则放到 survivor0 或者 survivor1 中。</p>
<blockquote>
<p>survivor 也叫 from &#x2F; to 区</p>
</blockquote>
<h2 id="内存占比"><a href="#内存占比" class="headerlink" title="内存占比"></a>内存占比</h2><p>默认情况下，年轻代和老年代占比 1:2，也就是年轻代占堆的1&#x2F;3，老年代占堆的 2&#x2F;3.能不能手动调整？可以，启动时添加JVM参数：<code>-XX:NewRatio=n</code> 设置年轻代和老年代占比 1:n。当然默认情况下是 <code>-XX:NewRatio=2</code>。但是这个数一般不建议改，除非你确定项目中有很多老对象。</p>
<p>HotSpot虚拟机中，伊甸园区和幸存者区占比为 8:1:1。同理可以通过启动参数 <code>-XX:survivorRatio=n</code> 来调整。但是需要说一下，其实启动后占比是6:1:1，而不是8:1:1，你要是真想让他8:1:1符合规范，那你设置一下好了。</p>
<p>几乎所有对象首先都是在Eden区创建，除非这个对象太大了直接放到OldGen，而且大部分对象的销毁都是放在Eden中，有研究表明 80%的对象都是朝生暮死，生命周期很短。如果我们嫌不够的话，可以使用参数 <code>-Xmn</code> 来调整新生代大小.</p>
<h1 id="5-创建对象的大体流程"><a href="#5-创建对象的大体流程" class="headerlink" title="5. 创建对象的大体流程"></a>5. 创建对象的大体流程</h1><p>前文说道，创建对象一般发生在新生代，那么新生代具体发生了什么，让我们来详细说一说，注意，这里并没有提到类加载器，仅仅是在对重给对象分配内存流程。后面还会详细说一个对象创建具体的流程。</p>
<h2 id="5-1-流程"><a href="#5-1-流程" class="headerlink" title="5.1 流程"></a>5.1 流程</h2><ol>
<li><p>在Eden区分配空间，大部分情况都是吧对象分配在eden区，上文也说过，除非这个对象特别大</p>
</li>
<li><p>当Eden区满了的时候，出发年轻代的垃圾回收机制，叫 YGC(YoungGC) 或者叫 MinorGC，Eden中已经没有了引用的对象将会被回收，剩下的对象，将会进入 survivor0 或者 survivor1，这里我们先假设 survivor0 和 survivor1 都是空的，再假设 Eden中没有被回收的对象进入了 survivor0.这个时候 survivor0 就叫to区，同时进入 survivor0 的对象有一个年龄计数器，用来记录幸存次数，从 0 变成 1。</p>
</li>
<li><p>继续创建对象，放在 Eden中，当Eden再一次满了，再次触发 YGC，这回Eden中的幸存对象将会进入空的那个 survivor，这里空的是 survivor1，年龄计数器变为1，同时 survivor0 中的对象也进行YGC，s0中的幸存者也会进入s1，那么这个时候，s1就叫to区，s0就叫from 区，s区的垃圾回收是 Eden 回收，他也顺带回收一下，如果 s区满了，再说。</p>
</li>
<li><p>一直进行这个 Eden + from &#x3D;&gt; to 的过程，同时对象的年龄计数器累加。</p>
</li>
<li><p>当一个对象的年龄计数器值达到临界的时候，默认是15，那么就会认为这个对象的生命周期很长，就会把它放入 老年代。这个过程叫提升 ：Promotion</p>
</li>
</ol>
<h2 id="5-2-总结"><a href="#5-2-总结" class="headerlink" title="5.2 总结"></a>5.2 总结</h2><ul>
<li><p>针对 s区，复制之后有交换，谁空谁是to</p>
</li>
<li><p>关于垃圾回收，频繁在 新生代回收，很少在老年代回收，几乎不再永生代(Meta) 回收。</p>
</li>
<li><p>再出发 YGC 的时候，Eden区肯定是被清空了</p>
</li>
</ul>
<h2 id="5-3-特殊情况"><a href="#5-3-特殊情况" class="headerlink" title="5.3 特殊情况"></a>5.3 特殊情况</h2><p>看图：</p>
<p><img src="/../images/runtime/MemoryHandleSpecialCase.png" alt="heap_memory"></p>
<p>解释一下： 正常流程肯定能看懂，说一点特殊情况：</p>
<ul>
<li><p>Eden 放不下了，可能是 Eden 满了，触发 YGC，然后Eden 还是放不下，这个时候Eden肯定是 空了，说明 对象大小超过了 Eden大小，则直接放入 老年代。</p>
</li>
<li><p>上面这种情况，如果 老年代也放不下，触发 FGC，还放不下，那完了，抛出 OOM错误。</p>
</li>
<li><p>触发YGC的时候，如果 s区放不下，就直接进入老年代。</p>
</li>
</ul>
<h1 id="6-堆垃圾回收"><a href="#6-堆垃圾回收" class="headerlink" title="6. 堆垃圾回收"></a>6. 堆垃圾回收</h1><p>大体来看，Heap 中的 GC 分为 3种：</p>
<ul>
<li><p>Young GC &#x2F; MinorGC</p>
</li>
<li><p>Full GC</p>
</li>
<li><p>Old GC &#x2F; Major GC</p>
</li>
</ul>
<p>根据 HotSpot 虚拟机，按照收集区域又分为两种：部分收集和整堆收集</p>
<ul>
<li><p>部分收集：不是完整收集整个Java 堆的收集，其中又分为：</p>
<ul>
<li><p>新生代收集 MinorGC&#x2F;YoungGC: 只收集年轻代的垃圾收集</p>
</li>
<li><p>老年代收集 MajorGC&#x2F;OldGC： 只收集老年代</p>
<ul>
<li><p>目前只有CMS GC会有单独收集老年代的行为</p>
</li>
<li><p>很多时候 MajorGC 会和 FullGC 混合使用，需要具体分辨是老年代回收还是整堆回收</p>
</li>
</ul>
</li>
<li><p>混合回收器 Mixed GC：收集整个新生代和部分老年代的垃圾</p>
<ul>
<li>只有G1 GC 有这种行为</li>
</ul>
</li>
</ul>
</li>
<li><p>整堆收集：收集整个 Java 堆 和 方法区 的垃圾，注意，还包括方法区。</p>
</li>
</ul>
<p>下面说一下各个内存部分的垃圾回收触发机制：</p>
<h2 id="6-1-年轻代触发机制"><a href="#6-1-年轻代触发机制" class="headerlink" title="6.1 年轻代触发机制"></a>6.1 年轻代触发机制</h2><ul>
<li><p>年轻代空间不足，就会触发minor gc,这里说的空间不足指的是eden空间不足，survivor 满了不会触发 minor gc，只会发生提升。每次回收都会清空年轻代内存。</p>
</li>
<li><p>Java 对象大多数申明周期很短，所以minor gc 发生的特别频繁。</p>
</li>
<li><p>minor gc 会触发STW，也就是暂停用户线程，等垃圾回收结束，才会恢复用户线程</p>
</li>
</ul>
<h2 id="6-2-老年代回收："><a href="#6-2-老年代回收：" class="headerlink" title="6.2 老年代回收："></a>6.2 老年代回收：</h2><ul>
<li><p>发生在老年代的垃圾回收，当对象从老年代消失了，我们就认为 major gc 或者 full gc 发生了，</p>
</li>
<li><p>发生一次 major gc，一般来说，伴随着至少一次的minor gc，不是绝对的，以后再说。</p>
<ul>
<li>也就是当老年代空间不足时，西安出发一次 minor gc，如果空间还不足，触发 major gc</li>
</ul>
</li>
<li><p>major gc 一般比 minor gc 慢10倍以上，stw 时间更长。</p>
</li>
<li><p>如果major gc后空间还是不够，抛出 OOM 异常。</p>
</li>
</ul>
<h2 id="6-3-FullGC-触发机制："><a href="#6-3-FullGC-触发机制：" class="headerlink" title="6.3 FullGC 触发机制："></a>6.3 FullGC 触发机制：</h2><ul>
<li><p>调用 System.gc() 时</p>
</li>
<li><p>老年代空间不足</p>
</li>
<li><p>方法区空间不足</p>
</li>
<li><p>通过 minor gc 后进入老年代的平均大小大于老年代的可用内存</p>
</li>
<li><p>eden from 的对象往 to 区复制，to区空间不够，提升到老年代，老年代空间也不够，触发 full gc</p>
</li>
<li><p>开发中尽量避免 full gc</p>
</li>
</ul>
<h1 id="7-TLAB"><a href="#7-TLAB" class="headerlink" title="7. TLAB"></a>7. TLAB</h1><p>前文说过TLAB，说是 堆里面有每个线程的私有缓冲区，有 TLAB，ThreadLocal，Buffer，Allocation，其实后面的三个词全都在说 TLAB。</p>
<h2 id="7-1-TLAB是啥"><a href="#7-1-TLAB是啥" class="headerlink" title="7.1 TLAB是啥"></a>7.1 TLAB是啥</h2><p>ThreadLocal Buffer Allocation： 线程私有缓冲区，用于结局线程安全问题。</p>
<h2 id="7-2-为什么要设置TLAB"><a href="#7-2-为什么要设置TLAB" class="headerlink" title="7.2 为什么要设置TLAB"></a>7.2 为什么要设置TLAB</h2><p>堆是整个进程共享的一块区域，如果一大堆线程同事访问堆，会造成县城不安全，如果给数据加锁，那效率就太慢了，所以为了提高效率，加入了线程缓冲区。</p>
<p>JVM给每个线程在 Eden 划分出来一块 TLAB，这种方式解决了线程安全问题，提高了内存分配吞吐量，我们就管这种方式叫“快速分配策略”.</p>
<p>虽然说不是所有对象都可以分配在 TLAB上，但是TLAB确实是JVM分配对象的首选。TLAB非常小，仅仅占到了 Eden的 1%。</p>
<p>如果对象在TLAB分配失败，JVM就会考虑给对象加锁，直接把对象放在Eden中。</p>
<h2 id="7-3-一些参数"><a href="#7-3-一些参数" class="headerlink" title="7.3 一些参数"></a>7.3 一些参数</h2><ul>
<li><p>-XX:useTLAB 是否开启TLAB，默认开启</p>
</li>
<li><p>-XX:TLABWasteTargetPercent 设置TLAB占Eden的百分比。</p>
</li>
</ul>
<h2 id="7-4-对象创建过程"><a href="#7-4-对象创建过程" class="headerlink" title="7.4 对象创建过程"></a>7.4 对象创建过程</h2><p>有了TLAB以后，对象创建流程如下：</p>
<p><img src="/../images/runtime/TLAB.png" alt="tlab"></p>
<h2 id="7-5-剩下的"><a href="#7-5-剩下的" class="headerlink" title="7.5 剩下的"></a>7.5 剩下的</h2><p>p81 没好好看，以后可以补一补。</p>
<h1 id="8-逃逸分析"><a href="#8-逃逸分析" class="headerlink" title="8. 逃逸分析"></a>8. 逃逸分析</h1><p>随着 JIT(编译器) 的发展，逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术 导致技术上有了一点区别，那就是 堆上分配对象不再那么绝对了。</p>
<p>大部分情况下，一个对象在堆上分配空间，但是在某些特殊情况下，这个对象经过了逃逸分析，发现这个方法并没有逃离方法，那么这个对象就有可能在栈上分配空间。</p>
<p>但是提一句，HotSpot虚拟机可是没有逃逸分析里面的部分功能的，比如栈上分配这个，HotSpot就没有。</p>
<h2 id="8-1-逃逸分析概述"><a href="#8-1-逃逸分析概述" class="headerlink" title="8.1 逃逸分析概述"></a>8.1 逃逸分析概述</h2><p>逃逸分析干嘛的？就是用来优化内存分配的，我们前面说对象都要分配到堆上，但是堆上涉及到GC，而栈却不涉及GC，所以可不可以把对象存到栈上，然后方法执行完成直接弹栈，省的GC了。所以这个就是逃逸分析要干的事，分配一个对象，就要看这个对象有没有发生逃逸，如果发生逃逸，也就是这个对象跑出了当前方法作用域，那么发生逃逸，该咋办咋办，如果没有，则可以进行优化。就可以把这个对象放到栈上。</p>
<ul>
<li><p>通过逃逸分析，Java Hotspot 编译器能够分析一个对象的引用从而决定这个对象是否分配到栈上。</p>
</li>
<li><p>逃逸分析的基本行为就是分析对象的作用域：</p>
<ul>
<li><p>一个对象被定义后，如果只在方法中调用，那么没有发生逃逸。</p>
</li>
<li><p>对象被定义后，方法外也引用了它，则发生了逃逸。比如方法中创建的对象最后被return了。</p>
</li>
</ul>
</li>
<li><p>没有发生逃逸，则对象可以分配到栈上，毕竟别的地方不用，方法执行完，栈帧出栈，对象也跟着出栈。</p>
</li>
<li><p>发生逃逸，那就老老实实往堆上分配。</p>
</li>
</ul>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这种情况下，user 对象仅仅在方法内部被调用，则没有逃逸，往栈上分配就行了  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();  </span><br><span class="line">    user = <span class="literal">null</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 这种情况，StringBuffer 最终被return，发生了逃逸。  </span></span><br><span class="line"><span class="keyword">public</span> StringBuffer <span class="title function_">getString</span><span class="params">(String a, String b)</span>&#123;  </span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();  </span><br><span class="line">    buffer.append(a);  </span><br><span class="line">    buffer.append(b);  </span><br><span class="line">    <span class="keyword">return</span> buffer;  </span><br><span class="line">&#125;  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 上面的 StringBuffer 改成这种，就不会发生逃逸  </span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getString</span><span class="params">(String a, String b)</span>&#123;  </span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();  </span><br><span class="line">    stringBuffer.append(a);  </span><br><span class="line">    stringBuffer.append(b);  </span><br><span class="line">    <span class="keyword">return</span> stringBuffer.toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数如下：</strong></p>
<ul>
<li><p>-XX:-DoEscapeAnalysis 关闭逃逸分析</p>
</li>
<li><p>-XX:+DoEscapeAnalysis 开启逃逸分析</p>
</li>
</ul>
<h2 id="8-2-逃逸分析：代码优化"><a href="#8-2-逃逸分析：代码优化" class="headerlink" title="8.2 逃逸分析：代码优化"></a>8.2 逃逸分析：代码优化</h2><p>总的来说，可以通过逃逸分析干好多事，上面那个，仅仅是一个 栈上分配。</p>
<p>逃逸检测的优化：</p>
<ul>
<li><p>栈上分配</p>
</li>
<li><p>同步省略</p>
</li>
<li><p>分离对象&#x2F;标量替换</p>
</li>
</ul>
<h3 id="8-2-1-栈上分配"><a href="#8-2-1-栈上分配" class="headerlink" title="8.2.1 栈上分配"></a>8.2.1 栈上分配</h3><p>就是前面说的，站上分配对象，如果实体仅仅在方法内部使用没有进入外部，则对象会被分配到栈上。</p>
<h3 id="8-2-2-同步省略"><a href="#8-2-2-同步省略" class="headerlink" title="8.2.2 同步省略"></a>8.2.2 同步省略</h3><p>如果一个对象仅在一个线程中使用，或者说，一个对象只能从一个线程中被访问，那么对于这个对象的操作就不考虑同步。</p>
<ul>
<li><p>线程同步的代价是很高的。</p>
</li>
<li><p>在动态编译同步代码块的时候，如果JIT 检测到一个对象仅仅在一个线程中被访问，而没有发布到其他线程，则运行时 JVM 就会取消对这个对象进行上锁，大大的提高效率，这就叫 锁消除。</p>
</li>
</ul>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();  </span><br><span class="line">    <span class="keyword">synchronized</span>(user)&#123;  </span><br><span class="line">        System.out.println(user);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 上面这种情况，user 对象仅仅在一个线程中被访问，并没有多个线程共享，所以几遍你给他加了锁，  </span></span><br><span class="line"><span class="comment">// JVM也不会执行，但是废话，这种情况，本来我们就不应该加锁。</span></span><br></pre></td></tr></table></figure>

<h3 id="8-2-3分离对象或标量替换"><a href="#8-2-3分离对象或标量替换" class="headerlink" title="8.2.3分离对象或标量替换"></a>8.2.3分离对象或标量替换</h3><p>有的对象可能不需要作为一个连续的内存结构存入到内存中，而且也可以被访问到。那么这部分对象的部分(甚至全部) 就可以存到 CPU的寄存器中。</p>
<p>用Java 说，就是这个对象不用存在 堆中，那就可以放到 栈 中。这里还需要解释几个概念：</p>
<p><strong>标量</strong></p>
<p>无法被分解成更小的数据，比如基本数据类型。</p>
<p><strong>对应聚合量</strong></p>
<p>还可以被分解的对象就是聚合量，比如我们自己写的类的实例。</p>
<p><strong>标量替换</strong></p>
<p>如果经过逃逸分析，发现你目前的对象没有在方法外面使用，他就会把你的聚合量，分解为几个标量，这个过程就叫标量替换。</p>
<p>说白了，就是吧对象打散了，分配到栈上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();  </span><br><span class="line">    System.out.println(<span class="string">&quot;Point.x=&quot;</span> + p.x + <span class="string">&quot; Point.y=&quot;</span> + p.y);  </span><br><span class="line">&#125;  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 最终这个东西会被优化成  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;  </span><br><span class="line">    System.out.println(<span class="string">&quot;Point.x=&quot;</span> + x + <span class="string">&quot; Point.y=&quot;</span> + y);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-XX:+EliminateAllocation 开启标量替换，默认就是开启的。</p>
<h2 id="8-3-总结"><a href="#8-3-总结" class="headerlink" title="8.3 总结"></a>8.3 总结</h2><p>大体说几点：</p>
<ul>
<li><p>逃逸分析并不成熟</p>
</li>
<li><p>逃逸分析本身也消耗性能，如果分析了半天，结果发现都逃逸了，那完犊子了</p>
</li>
<li><p>Oracle HotSpot 并没有栈上分配，所以肯定对象都在堆上</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-方法区</title>
    <url>/2022/05/30/jvm-methodarea/</url>
    <content><![CDATA[<p>JVM方法区，主要用于储存各种类的元信息，也就是我们常说的Class类摸版，这里详细说一下方法区的内存分布和垃圾回收问题。同时这里也不会只讲方法区，因为讲完方法区以后我们就可以深入的去研究一个对象是如何被创建的，所以后面还会和堆空间结合起来说。</p>
<span id="more"></span>

<h1 id="1-方法区"><a href="#1-方法区" class="headerlink" title="1. 方法区"></a>1. 方法区</h1><h2 id="1-1-明确几个概念"><a href="#1-1-明确几个概念" class="headerlink" title="1.1 明确几个概念"></a>1.1 明确几个概念</h2><ul>
<li><p>方法区虽然之前说过算是 堆的一部分，但是一般情况下是要分开的。</p>
</li>
<li><p>方法去看作是JVM独立的一部分。</p>
</li>
<li><p>HotSpot 虚拟机的方法区还有一个别名：Non-Heap 非堆。</p>
</li>
<li><p>方法区会自己收缩扩大</p>
</li>
</ul>
<h2 id="1-2-方法区的基本理解"><a href="#1-2-方法区的基本理解" class="headerlink" title="1.2 方法区的基本理解"></a>1.2 方法区的基本理解</h2><ul>
<li><p>方法区和堆类似，都是线程共享的。</p>
</li>
<li><p>方法区在JVM启动时被创建，和heap一样他的物理内存可以不连续。</p>
</li>
<li><p>方法区的大小和heap一样，可固定 可 伸缩</p>
</li>
<li><p>方法区的大小决定了系统能加载多少个类，如果类过于多，也会抛出 OutOfMemoryError</p>
<ul>
<li>比如加载过多 jar 包，或者 tomcat部署过多服务，比如 30 - 50 个。</li>
</ul>
</li>
<li><p>关闭JVM会释放这部分内存。</p>
</li>
</ul>
<h2 id="1-3-HotSpot-虚拟机-方法区演进"><a href="#1-3-HotSpot-虚拟机-方法区演进" class="headerlink" title="1.3 HotSpot 虚拟机 方法区演进"></a>1.3 HotSpot 虚拟机 方法区演进</h2><ul>
<li><p>JDK7 中，将方法区称为永久代，JDK8以后用元空间取代了永久代</p>
<blockquote>
<p>JVM虚拟机规范中说：将类的原信息存储到本地堆中，这块区域称为元空间</p>
</blockquote>
</li>
<li><p>确切来说永久代和方法区并不等价，仅针对 HotSpot 虚拟机而言，他并没有规定如何实现方法区。</p>
</li>
<li><p>可以这么理解，方法区就是一个接口，永久代和元空间用于存储类的原信息，是方法区的实现。</p>
</li>
</ul>
<h2 id="1-4-hotSpot-设置-方法区大小"><a href="#1-4-hotSpot-设置-方法区大小" class="headerlink" title="1.4 hotSpot 设置 方法区大小"></a>1.4 hotSpot 设置 方法区大小</h2><ul>
<li><p>JDK7 之前：</p>
<ul>
<li><p>-XX:PermSize&#x3D;100m 设置初始大小 默认 20.75m</p>
</li>
<li><p>-XX:MaxPermSize&#x3D;200m 设置最大值 默认 32位机器 64m，64位机器 86m</p>
</li>
</ul>
</li>
<li><p>JDK8 以后：</p>
<ul>
<li><p>-XX:MetaspaceSize&#x3D;100m 设置初始大小 默认 21m</p>
</li>
<li><p>-XX:MaxMetaspaceSize&#x3D;200m 设置最大值 默认没有最大，最大就是你的真实内存</p>
</li>
</ul>
</li>
</ul>
<p>二者的区别：</p>
<ul>
<li><p>元空间和永久代不同，元空间会耗尽你所有的内存，直到你的内存崩了，他会给你抛出 OOM异常。</p>
</li>
<li><p>-XX:MetaspaceSize 设置初始大小。对于一个64位的机器来说，默认是21m空间，那么这个21m就是一个高水位线，一旦元空间的东西超过了21m，就会触发FullGC来清理不用的类(类加载器死亡了)，然后这个高水位线会重置。如果清理的不多，同时在最大空间以内，他就会稍微提高这个高水位线，如果清理的过多，就会降低这个高水位线。</p>
</li>
<li><p>根据上面所说的，如果初始值比较低，那么就会频繁触发 FullGC，为了提高性能，建议吧这个初始值调高。</p>
</li>
</ul>
<h1 id="2-方法区内部结构"><a href="#2-方法区内部结构" class="headerlink" title="2. 方法区内部结构"></a>2. 方法区内部结构</h1><h2 id="2-1-方法区主要存储对象"><a href="#2-1-方法区主要存储对象" class="headerlink" title="2.1 方法区主要存储对象"></a>2.1 方法区主要存储对象</h2><ul>
<li><p>类型信息</p>
<ul>
<li><p>全限定命名</p>
</li>
<li><p>直接父类的全限定命名</p>
</li>
<li><p>类的访问修饰符</p>
</li>
<li><p>实现的直接接口的有序列表</p>
</li>
</ul>
</li>
<li><p>域信息(Field 其实就是字段，或者属性):</p>
<ul>
<li><p>JVM必须在方法去中保存所有字段的相关信息和声明顺序</p>
</li>
<li><p>域的相关信息包括：名称 类型 访问修饰符</p>
</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li><p>JVM必须在方法去中保存下面的信息，同时也会保存声明顺序：</p>
</li>
<li><p>方法名称</p>
</li>
<li><p>方法返回值类型</p>
</li>
<li><p>参数的数量与类型(按顺序)</p>
</li>
<li><p>访问修饰符</p>
</li>
<li><p>方法的字节码 操作数栈 局部变量表及大小(abstract native 方法除外)</p>
</li>
<li><p>异常表(abstract native 除外)</p>
<ul>
<li>包括 每个异常处理的开始位置，结束位置，代码处理在PC寄存器中的偏移地址，被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-全局常量"><a href="#2-2-全局常量" class="headerlink" title="2.2 全局常量"></a>2.2 全局常量</h2><p>就是 static final，用 final 修饰的 static 成员。</p>
<p>这个东西在编译的时候就已经为他分配了值。直接反编译，就可以看到.</p>
<h1 id="3-常量池-和-运行时常量池"><a href="#3-常量池-和-运行时常量池" class="headerlink" title="3. 常量池 和 运行时常量池"></a>3. 常量池 和 运行时常量池</h1><p>一个有效的字节码文件里面包含了类的信息 字段 方法 接口等，以外，还包括一个东西，就是常量池：Constant Pool。常量池里面包括：字面量 类型，字段，方法的引用。</p>
<p>看图： </p>
<p><img src="/images/runtime/ConstantPool.png" alt="method_area"></p>
<p>这图领会精神，因为我也看不懂.</p>
<h2 id="3-1-为什么引入-常量池"><a href="#3-1-为什么引入-常量池" class="headerlink" title="3.1 为什么引入 常量池"></a>3.1 为什么引入 常量池</h2><p>Java 一个类编译后生成字节码文件。而Java字节码通常需要数据支持，而这些数据大到无法存到 字节码文件中，所以引入常量池，在动态链接阶段 会用到运行时常量池。</p>
<p>比如我们写一个最简单的HelloWorld 程序，这个程序就用到了 Object,System,PrintStream等一系列的类。这些类很显然不能全都装在字节码里面，所以就以常量池的形式存储。</p>
<p>比如我们随便反编译一个类，得到 Constant Pool，都是一大堆 #… 这种东西，然后我们跟着他的 # 一路往下追，才能找到他到底是个啥。</p>
<h2 id="3-2-常量池里面都存啥？"><a href="#3-2-常量池里面都存啥？" class="headerlink" title="3.2 常量池里面都存啥？"></a>3.2 常量池里面都存啥？</h2><ul>
<li><p>数量值</p>
</li>
<li><p>字符串值</p>
</li>
<li><p>类引用</p>
</li>
<li><p>字段引用</p>
</li>
<li><p>方法引用</p>
</li>
</ul>
<p>举个例子：</p>
<p><code>Object object = new Object();</code></p>
<p>他在 字节码中会被表示成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0:new #2</span><br><span class="line">1:dup </span><br><span class="line">2:invokespecial #3</span><br></pre></td></tr></table></figure>

<p>这里的#2 和#3就是常量池中的东西，new 后面这个#2，指向的就是常量池中用于表示Object这个类的字符串常量，注意是字符串常量，#3 就指向了常量池的Object的<init>O 方法，然后在类加载的链接阶段就会将这些字符串常量转化为运行时常量池，然后#2也会指向真实的内存地址。</p>
<p>总的来说：常量池就可以理解成一张表，JVM根据这张表，去找到要执行的类名 方法 参数 字面量等。</p>
<h2 id="3-3-运行时常量池"><a href="#3-3-运行时常量池" class="headerlink" title="3.3 运行时常量池"></a>3.3 运行时常量池</h2><p>这里明确一下，运行时常量池和字节码中的常量池表不一样。</p>
<ul>
<li><p>运行时常量池 是 方法区的一部分</p>
</li>
<li><p>常量池表是字节码文件的一部分，用于存储编译期生成的各种字面量和引用，这部分内容将在类加载后放到方法区的运行时常量池中。</p>
</li>
<li><p>加载类和接口到虚拟机后就会生成对应的运行时常量池</p>
</li>
<li><p>JVM为每一个已经加载的类型(类或者接口)都维护一个运行时常量池，池中的数据向数组像一样，可以通过索引访问。</p>
</li>
<li><p>运行时常量池中包含多种不同的常量，包括编译期间就已经明确的字面量，也包括运行时解析后才能得到的方法或字段引用，此时已经不再是常量池那种符号地址了，而是真实地址</p>
</li>
<li><p>运行时常量池对比常量池的一个特点：具备动态性</p>
</li>
<li><p>运行时常量池类似其他语言的符号表，但是内容更丰富。</p>
</li>
<li><p>在构造类型的运行时常量池的时候，如果方法区的空间不够了，就会抛出 OutOfMemoryError</p>
</li>
</ul>
<h1 id="4-JVM方法区的演进"><a href="#4-JVM方法区的演进" class="headerlink" title="4. JVM方法区的演进"></a>4. JVM方法区的演进</h1><ul>
<li><p>首先 HotSpot 虚拟机才有永久代</p>
</li>
<li><p>HotSpot虚拟机的演进：</p>
<ul>
<li><p>JDK6以前，有永久代，静态变量存放在永久代上</p>
</li>
<li><p>JDK7还有永久代，但是 字符串常量池，静态变量从永久代移除，放到了堆上</p>
</li>
<li><p>JDK8以后，取消永久代，而是元空间，类型信息 字段 方法 常量保存在元空间，但是 静态变量和字符串常量池还在堆上。</p>
</li>
</ul>
</li>
<li><p>以前有永久代的时候，所有内存都放在JVM的内存上，到了元空间，变成了本地内存。</p>
</li>
</ul>
<h2 id="4-1元空间为何要取代永久代"><a href="#4-1元空间为何要取代永久代" class="headerlink" title="4.1元空间为何要取代永久代"></a>4.1元空间为何要取代永久代</h2><ul>
<li><p>JDK8以后，永久代没了，原先存在永久代中的数据被存到了一个和堆不连续的本地内存上， 这块地方就是元空间。</p>
</li>
<li><p>因为类的元数据放在本地内存，所以元空间的上线就是真实内存max</p>
</li>
</ul>
<h2 id="4-2-好处"><a href="#4-2-好处" class="headerlink" title="4.2 好处"></a>4.2 好处</h2><ul>
<li><p>方法区的大小很难确定，如果功能过多，加载的雷多，很可能出现OOM错误。</p>
</li>
<li><p>对永久代调优很困难，就是 FullGC，去判断哪些是垃圾特别麻烦，所以 尽量少去GC，就需要更大的方法区空间。</p>
</li>
</ul>
<h2 id="4-3-StringTable-调整"><a href="#4-3-StringTable-调整" class="headerlink" title="4.3 StringTable 调整"></a>4.3 StringTable 调整</h2><p>首先说一下啥是StringTable，StringTable 就是字符串常量池，JVM中有一个专门储存字符串的地方，因为字符串大量使用，所以干脆给你做成一个单独的常量池。这个东西在后面我们说到字符串的时候还会详细说，这里先了解一下。</p>
<p>JDK7以前，StringTable在永久代，而JDK7以后，把StringTable扔到了堆中，为哈？</p>
<p>如果放在方法区，那就会涉及FullGC，而FullGC只有在永久代满了的时候才会触发， GC不频繁，而StringTable 经常用，看法中大量的String被创建，所以放在永久代里面 效率底下，所以放在堆中。</p>
<h2 id="4-4-静态成员放在哪里"><a href="#4-4-静态成员放在哪里" class="headerlink" title="4.4 静态成员放在哪里"></a>4.4 静态成员放在哪里</h2><p>就是说我们有一个静态成员，比如 <code>private static UserUtils uu = new UserUtils();</code> ，那么这个UserUtils 到底在哪？</p>
<p>明确一下，只要是new出来的东西，就肯定是放在堆中的，没有例外。不同的是这个 static uu 放到哪了。</p>
<p>JDK7 以后，这个引用也会放在堆中，而JDK6以前，这个引用同样放在方法区。</p>
<h1 id="5-元空间GC"><a href="#5-元空间GC" class="headerlink" title="5. 元空间GC"></a>5. 元空间GC</h1><blockquote>
<p>方法区的具体实现部分可以不涉及GC ——Java虚拟机规范</p>
</blockquote>
<p>首先明确，方法去中有GC，但是方法区的GC很难让人满意。</p>
<p>方法区的垃圾回收主要回收常量池和类型信息。</p>
<h2 id="如何垃圾回收"><a href="#如何垃圾回收" class="headerlink" title="如何垃圾回收"></a>如何垃圾回收</h2><ul>
<li><p>常量相对简单，然而他没讲</p>
</li>
<li><p>如何判断类型不再使用：</p>
<ul>
<li><p>该类的所有对象都被回收，且不存在子类对象</p>
</li>
<li><p>加载该类的类加载器被回收，这个除非是精心设计的可以可替换类加载的场景，比如 JSP OSGI 等，否则很难达成。</p>
</li>
<li><p>类的Class 在任何地方都没有被引用，任何地方都不能通过反射区访问这个类。</p>
</li>
</ul>
</li>
<li><p>Java 虚拟机只有满足了上述三个条件才会允许回收这个类，但也仅仅是允许， 并不是说就想对象一样，一定可以被回收。</p>
</li>
<li><p>在大量使用反射 动态代理 CGlib等字节码框架，动态生成</p>
</li>
</ul>
<p>这里只是大致说一句GC，GC后面会专门说的。</p>
<h1 id="6-创建对象流程"><a href="#6-创建对象流程" class="headerlink" title="6. 创建对象流程"></a>6. 创建对象流程</h1><p>学了方法区，我们就得详细说说一个对象是如何被创建的了，这里就会把方法区和堆空间结合起来说了。所以这部分内容比较综合。</p>
<h2 id="6-1-创建方式"><a href="#6-1-创建方式" class="headerlink" title="6.1 创建方式"></a>6.1 创建方式</h2><p>首先，创建对象的方式：</p>
<ul>
<li><p>new 对象</p>
<blockquote>
<p>包括单例设计模式里面的 getInstance 那种在内部调用 new 的</p>
</blockquote>
</li>
<li><p>Class.newInstance() 反射创建对象</p>
<blockquote>
<p>条件比较苛刻，首先必须有无参构造，其次构造函数必须是 public</p>
</blockquote>
</li>
<li><p>Constructor的 newInstance(args) 调用构造函数</p>
<blockquote>
<p>可以调用任意构造函数，不用担心权限</p>
</blockquote>
</li>
<li><p>Clone，需要类 实现 Cloneable 接口，实现 clone 方法</p>
</li>
<li><p>反序列化，通过 ObjectSteam</p>
</li>
<li><p>第三方库 Objenesis</p>
</li>
</ul>
<h2 id="6-2-字节码角度看对象创建"><a href="#6-2-字节码角度看对象创建" class="headerlink" title="6.2 字节码角度看对象创建"></a>6.2 字节码角度看对象创建</h2><p>我们写一个代码，main 方法里面仅仅创建一个 Object 对象，然后反编译，看看 得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: new           #2   // class java/lang/Object  </span><br><span class="line">3: dup  </span><br><span class="line">4: invokespecial #1   // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V  </span><br><span class="line">7: astore_1  </span><br><span class="line">8: return</span><br></pre></td></tr></table></figure>

<p>首先我们看第一条指令 new，它里面涉及到的东西：</p>
<ul>
<li><p>加载 Object，将 Object 放到方法区，当然这个过程可能早就做了</p>
</li>
<li><p>在堆中给Object 分配空间，此时内存占用大小已经可以通过数据类型确定下来了，然后 给成员变量进行初始化，给他一个初值。</p>
</li>
</ul>
<p>第二步 dump 复制操作：</p>
<ul>
<li>因为这个对象在 main 方法中执行，所以引用在操作数栈里面， 然后他吧引用复制了一份，一份用来赋值，一个用来调用方法。</li>
</ul>
<blockquote>
<p>为啥是在操作数栈？因为此时对象还没有创建完，创建完之后 指令 7 才会存储到 局部变量表中。</p>
</blockquote>
<p>第三步 invokespecial 调用 <init> 方法，也就是构造函数。</p>
<p>第四步 astore 将对象存储到 局表。</p>
<h2 id="6-3-具体的创建流程"><a href="#6-3-具体的创建流程" class="headerlink" title="6.3 具体的创建流程"></a>6.3 具体的创建流程</h2><p>一个对象创建出来，new 出来，大致需要经历六个步骤：</p>
<h3 id="6-3-1-判断对象对应的类是否加载-链接-初始化"><a href="#6-3-1-判断对象对应的类是否加载-链接-初始化" class="headerlink" title="6.3.1 判断对象对应的类是否加载 链接 初始化"></a>6.3.1 判断对象对应的类是否加载 链接 初始化</h3><p>很显然这三步是反射的时候学过的，然后一开始类加载也学过一些， 可以看chapter02回忆一下。下面具体说：</p>
<p>虚拟机遇到一条new指令，首先根据这个指令的参数去metaspace 也就是方法区里面定位这个类的符号引用，并且检查这个符号引用对应的类是否完成了 加载 链接 初始化。 也就是查找类型元信息。如果找不到，则会在双亲委派模式下调用 ClassLoader 来加载Class文件， 如果找不到，则抛出 ClassNotFoundException。</p>
<p>如果找到了，则加载类，方法区中生成 Class对象。</p>
<h3 id="6-3-2-为对象分配内存"><a href="#6-3-2-为对象分配内存" class="headerlink" title="6.3.2 为对象分配内存"></a>6.3.2 为对象分配内存</h3><p>计算对象占用空间大小，这个根据类的成员类型很容易可以计算出来，如果是引用数据类型，那就分配 引用空间即可，也就是 4 字节，然后为对象分配空间。</p>
<p>如何分配空间又是个问题，这里区分内存规整和不规整：</p>
<ul>
<li><p>内存规整，则采用指针碰撞来为对象分配内存。</p>
<p>这tm是啥？简单说，就是如果内存规整，一条内存，用过的连续在一端，没用过的在另一端， 区分的特别明显，那么这条内存在用过的和没用过的中间有个指针用来划分区域。 在这种情况下分配内存，指针只需要向空的那一端移动和对象一样的大小即可。</p>
<p>如果垃圾收集器采用的是 Serial ParNew 这种基于标记压缩算法的，虚拟机使用这种内存分配方式。</p>
<p>一般使用带有 Compact(整理)过程的收集器时，使用指针碰撞。</p>
</li>
<li><p>内存不规整，虚拟机就需要维护一个列表，也就是空闲列表。</p>
<p>那么啥叫空闲列表？内存不规整，使用过的和没用过的相互交错，就需要一个列表用来 标记那些内存是没用过的，那些使用过的。</p>
<p>分配内存的时候，查询列表，找到一块能放得下的地方，吧对象放进去， 然后更新空闲列表。</p>
</li>
<li><p>总的来说，采用那种方法是由Java堆是否规整决定的，堆规整与否又是由所采用的垃圾收集器 是否有压缩算法决定。</p>
</li>
</ul>
<h3 id="6-3-3-处理并发安全问题"><a href="#6-3-3-处理并发安全问题" class="headerlink" title="6.3.3 处理并发安全问题"></a>6.3.3 处理并发安全问题</h3><ul>
<li><p>采用CAS 失败重试，区域枷锁 保证更新的原子性</p>
</li>
<li><p>给每个线程预留一块 TLBA ，通过 -XX:+&#x2F;-useTLBA 来控制， jdk8默认开启。</p>
</li>
</ul>
<h3 id="6-3-4-初始化分配到的空间"><a href="#6-3-4-初始化分配到的空间" class="headerlink" title="6.3.4 初始化分配到的空间"></a>6.3.4 初始化分配到的空间</h3><p>简单地说就是给每个成员一个默认值，保证一个对象不赋值就可以直接使用。</p>
<h3 id="6-3-5-设置对象的对象头"><a href="#6-3-5-设置对象的对象头" class="headerlink" title="6.3.5 设置对象的对象头"></a>6.3.5 设置对象的对象头</h3><p>将对象的所属类(也就是累的元信息) 和 对象的 HashCode 和 对象的 GC信息，锁信息存储到对象头中，这个过程的具体设置方式取决于JVM。</p>
<h3 id="6-3-6-调用-init-方法"><a href="#6-3-6-调用-init-方法" class="headerlink" title="6.3.6 调用 init 方法"></a>6.3.6 调用 init 方法</h3><p>init 方法并不是构造方法，而是给对象进行完整的赋值，比如 成员的赋值，实例代码块里面对于成员的赋值，构造函数里面给成员的赋值，都在init 方法里面，不是单纯的构造函数。</p>
<h2 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h2><p>看这条代码</p>
<p>Object o &#x3D; new Object();</p>
<p>其实 new 就是一个指令，告诉JVM 要去加载 Object，然后Object() 就是调用构造器，完整的创建一个对象出来，应该是吧上面的6部全都执行完才算是创建完了，就一个new，可以说仅仅是有了个对象的大体模型，但是细节还不完善。</p>
<h1 id="7-对象的内存分布"><a href="#7-对象的内存分布" class="headerlink" title="7. 对象的内存分布"></a>7. 对象的内存分布</h1><p>对象的内存分布主要分为：</p>
<ul>
<li><p>对象头 header</p>
</li>
<li><p>实例数据 instance data</p>
</li>
<li><p>对齐填充</p>
</li>
</ul>
<p>下面会挨个说。</p>
<h2 id="7-1-对象头"><a href="#7-1-对象头" class="headerlink" title="7.1 对象头"></a>7.1 对象头</h2><p>对象头里面包含两部分：</p>
<ul>
<li><p>运行时元数据 Mark Word（32bit），里面记录了以下内容：</p>
<ul>
<li><p>哈希值</p>
</li>
<li><p>GC分代年龄，就是堆里面的年龄计数器记录的那个东西</p>
</li>
<li><p>锁状态标志</p>
</li>
<li><p>线程持有的锁</p>
</li>
<li><p>偏向线程id</p>
</li>
<li><p>偏向时间戳</p>
</li>
</ul>
</li>
<li><p>类型指针 Klass Word（32bit）</p>
<p>指向了方法区里面的Class，也就是类型元信息。确定对象所属类型</p>
<p>方法 Object.getClass() 就是体现了这个，就是我们以前说的，对象可以找到 它对应的Class。</p>
</li>
<li><p>特殊情况： 如果存的是数组，那么还会保存数组长度信息（32bit）。</p>
</li>
</ul>
<p>这块内容在Java并发编程的时候也会说的，到时候可以再加深一下印象。</p>
<h2 id="7-2-实例数据"><a href="#7-2-实例数据" class="headerlink" title="7.2 实例数据"></a>7.2 实例数据</h2><p>他是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段 (包括继承的和本身的)</p>
<p>存放规则：</p>
<ul>
<li><p>相同宽度的字段总是被分配在一起。</p>
</li>
<li><p>父类中定义的变量会出现在子类之前</p>
</li>
<li><p>如果 CompactFields 参数为 true，子类的窄变量可以插入到父类的变量之间。</p>
</li>
</ul>
<h2 id="7-3-图解过程"><a href="#7-3-图解过程" class="headerlink" title="7.3 图解过程"></a>7.3 图解过程</h2><p>我们现在有一个Customer对象，这个对象里面还包含了一个Account对象，那么这个Customer对象的内存分布如何？</p>
<p>具体情况如下：</p>
<p><img src="/images/runtime/NewObjectProcess.png"></p>
<p>看图就行了，我觉得这个图还是挺清楚的。</p>
<h1 id="8-对象的访问定位"><a href="#8-对象的访问定位" class="headerlink" title="8. 对象的访问定位"></a>8. 对象的访问定位</h1><p>简单地说，JVM是如何通过栈帧中的引用访问到对象实例的？</p>
<p>懂得来说，都是一个流程：</p>
<p>栈帧中的引用指向堆区，堆区再通过元数据指针指向方法区。</p>
<p>具体的流程有两个：</p>
<h2 id="8-1-句柄访问"><a href="#8-1-句柄访问" class="headerlink" title="8.1 句柄访问"></a>8.1 句柄访问</h2><p>就是说堆中我们再专门弄出一个空间，专门用来放类型指针，栈的引用先指向了句柄，然后句柄再指向实例数据和类型数据。</p>
<p><img src="/images/runtime/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png"></p>
<h2 id="8-2-直接指针"><a href="#8-2-直接指针" class="headerlink" title="8.2 直接指针"></a>8.2 直接指针</h2><p>这个就很好理解了，就是堆中的对象里面还有个对象头指向了类型数据，HotSpot虚拟机就是使用这种办法。</p>
<p><img src="/images/runtime/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png"></p>
<p>这个就是栈帧里面的引用直接指向堆中的对象实体，实体里面有一个指针指向方法区的类型元信息。</p>
<p>Hotspot 虚拟机就用的是直接访问，看24那张图，可以看出来是直接访问。</p>
<h1 id="9-直接内存"><a href="#9-直接内存" class="headerlink" title="9. 直接内存"></a>9. 直接内存</h1><p>jdk8中的元空间不再是 jvm的虚拟内存，而是直接内存，所以这里我们看看什么是直接内存。</p>
<h2 id="9-1-直接内存概念"><a href="#9-1-直接内存概念" class="headerlink" title="9.1 直接内存概念"></a>9.1 直接内存概念</h2><ul>
<li><p>直接内存不是虚拟机运行时内存的一部分，也不是java虚拟机规范中定义的内存区域</p>
</li>
<li><p>直接内存是堆外，直接向系统申请的内存</p>
</li>
<li><p>来源于 NIO，通过存在堆中的 DirectByteBuffer操作native内存。</p>
</li>
<li><p>通常，访问直接内存的效率要高于java堆，读写速度快。</p>
<ul>
<li><p>由于处于性能考虑，读写频繁的场合可能用到直接内存。</p>
</li>
<li><p>java 的NIO 库允许Java程序直接使用内存，用于数据缓冲区。</p>
</li>
</ul>
</li>
</ul>
<h2 id="9-2-NIO-和-IO-的比较"><a href="#9-2-NIO-和-IO-的比较" class="headerlink" title="9.2 NIO 和 IO 的比较"></a>9.2 NIO 和 IO 的比较</h2><ul>
<li><p>IO：文件输入输出</p>
<p>基础工具：byte[] &#x2F; char[] 用于传输</p>
<p>基础的类：Stream</p>
</li>
<li><p>NIO(New IO &#x2F; Non-Blocking IO)</p>
<p>基础工具：Buffer</p>
<p>基础的类：Channel</p>
</li>
</ul>
<p>不使用 NIO ，JVM进行IO的流程如下：</p>
<p><img src="/images/runtime/non-direct-memory.png"></p>
<p>使用NIO，JVM进行IO流程</p>
<p><img src="/images/runtime/NIOProcess.png"></p>
<p>额，咱也不懂这玩意有啥用，反正先写在这里。</p>
<h1 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h1><p>啊，总算是整理完了，这一章东西可谓是奇多，不光是讲方法区，同时还讲了堆和方法区之间是如何配合的，这两部分如何协同才能创建出一个对象来。需要慢慢消化。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机栈</title>
    <url>/2022/05/27/jvm-stack/</url>
    <content><![CDATA[<p>虚拟机栈，JVM用于处理方法执行的地方，东西还挺多，而且还听重要.</p>
<span id="more"></span>

<h1 id="1-虚拟机栈概述"><a href="#1-虚拟机栈概述" class="headerlink" title="1. 虚拟机栈概述"></a>1. 虚拟机栈概述</h1><blockquote>
<p>Java Virtual Machine Stack</p>
</blockquote>
<p>首先明确个概念，JVM是基于栈的存储模型(当然还有基于寄存器的)，一般来说java 中 栈里面存放运行时数据，堆 进行存储，比如创建对象，就会放到堆里面，当然这不代表栈不会存数据，一些局部变量也是存在栈里面的。</p>
<h2 id="1-1-虚拟机栈是什么"><a href="#1-1-虚拟机栈是什么" class="headerlink" title="1.1 虚拟机栈是什么"></a>1.1 虚拟机栈是什么</h2><p>每个线程创建时都会创建一个虚拟机栈，里面存储着栈帧(Stack Frame) 对应方法调用，栈帧就是方法调用，方法开始调用栈帧入栈，方法调用结束栈帧出栈。</p>
<p>生命周期和JVM一样。</p>
<h2 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2 作用"></a>1.2 作用</h2><p>主管程序的运行，保存方法的局部变量，部分结果，并参与方法的调用和返回</p>
<blockquote>
<p>局部变量包括 8 中基本数据类型和 引用数据类型的引用，仅限引用地址，不包括实际的对象，对象在堆中。</p>
</blockquote>
<p>大致说一下，先不说那么细，看图： </p>
<p><img src="/images/runtime/stackFrame.png" alt="stack_frame"></p>
<p>这里定义两个方法，A 和 B，然后两个方法进行入栈操作，绿色的就是 B 方法，那么栈顶的方法就是当前方法，然后B执行完，A就是当前方法。</p>
<p>那么目前，我们可以粗略的将方法，理解为栈帧，当然栈帧里面还细分一堆东西，我们现在先不说了。</p>
<h2 id="1-4-栈的优点"><a href="#1-4-栈的优点" class="headerlink" title="1.4 栈的优点"></a>1.4 栈的优点</h2><ul>
<li><p>有效的存储方式，访问速度仅次于程序计数器</p>
</li>
<li><p>JVM 对栈的操作只有两个</p>
<ul>
<li><p>方法执行，入栈</p>
</li>
<li><p>执行完，出栈</p>
</li>
</ul>
</li>
<li><p>不存在垃圾回收</p>
<blockquote>
<p>栈不存在 GC 但是存在 OOM (out of memory 内存溢出),PC寄存器俩都没有</p>
</blockquote>
</li>
</ul>
<h2 id="1-5-栈可能出现的问题"><a href="#1-5-栈可能出现的问题" class="headerlink" title="1.5 栈可能出现的问题"></a>1.5 栈可能出现的问题</h2><p>Java 中，栈的大小可以是动态的或者固定不变的。如果栈的大小固定不变，那么入栈操作可能会因为栈满了而报错， 抛出 StackOverFlowError</p>
<blockquote>
<p>最常见的就是无限递归</p>
</blockquote>
<p>如果栈的大小动态，那么可能进行入栈操作是跟内存要空间，结果内存没了，导致异常 抛出 OutOfMemoryError</p>
<h1 id="2-栈帧概述"><a href="#2-栈帧概述" class="headerlink" title="2. 栈帧概述"></a>2. 栈帧概述</h1><p>何为栈帧，我们上面说，把一个方法的调用理解成栈帧，一个方法在JVM中执行，就是虚拟机栈中压入了这个方法对应的栈帧，方法执行完成后，这个栈帧就会弹栈。同时为了保证方法执行的正确性以及其他的一些什么乱七八糟的东西，栈帧内部还有很多的其他组成部分，我们下面会详细说。</p>
<h2 id="2-1-栈帧的注意事项"><a href="#2-1-栈帧的注意事项" class="headerlink" title="2.1 栈帧的注意事项"></a>2.1 栈帧的注意事项</h2><ul>
<li><p>不同线程之间的栈帧不能相互引用</p>
</li>
<li><p>如果方法调用了其他返回，在方法返回时，当前栈帧会传给前一栈帧执行结果，当前栈帧出栈，让上一个栈帧变为当前。</p>
</li>
<li><p>java中有两个方式返回方法，return 和 throw(没有处理)，两种办法都会弹出栈帧。</p>
</li>
</ul>
<h2 id="2-2-栈帧的具体结构"><a href="#2-2-栈帧的具体结构" class="headerlink" title="2.2 栈帧的具体结构"></a>2.2 栈帧的具体结构</h2><p>分为5部分：</p>
<ul>
<li><p>局部变量表</p>
</li>
<li><p>操作数栈&#x2F;表达式栈</p>
</li>
<li><p>动态链接&#x2F;指向运行时常量池的方法引用</p>
</li>
<li><p>方法返回地址</p>
</li>
<li><p>附加信息</p>
</li>
</ul>
<p>下面我们就会进入这5个部分，详细说说栈帧里面都是些什么鬼。</p>
<h1 id="3-局部变量表"><a href="#3-局部变量表" class="headerlink" title="3. 局部变量表"></a>3. 局部变量表</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ul>
<li><p>也叫本地变量表：</p>
</li>
<li><p>定义一个数字数组，用于存储方法参数，和定义在方法内的局部变量，这些数据类型包括 8种基本数据类型，引用，和返回值类型。</p>
</li>
<li><p>一个线程配套一个虚拟机栈，所以不存在线程安全问题。</p>
</li>
<li><p>这个表的长度一开始就已经固定，且不会发生改变，因为在编译的时候编译器就已经解析出来你这个方法需要多少个临时变量了，表长存在一个 maximum local variables 属性里面。 可以反编译一个class文件找找，code 里面的 locals 也记录了。</p>
</li>
<li><p>只在当前方法中有效，别人想用就得传参了，方法调用结束变量表随之销毁。</p>
</li>
<li><p>方法嵌套次数由虚拟机栈决定，一般来说，栈越大，嵌套越多，如果一个方法的本地数据过多， 会导致栈帧过大，进而占用虚拟机栈的空间变多，导致方法嵌套次数变少。</p>
</li>
</ul>
<p>我们解析一个 class文件，就能在方法里面找到 LocalVariableTable， slot 代表了第几个本地变量，然后 length不解释，signature 就是数据类型， 同时，code 里面的 locals 也记录了 变量表的最大长度。</p>
<h2 id="3-2-解析Class中的方法"><a href="#3-2-解析Class中的方法" class="headerlink" title="3.2 解析Class中的方法"></a>3.2 解析Class中的方法</h2><p>我们解析一个 class文件以后，不说 javap 解析了，就说 jclasslib 解析以后得到的东西。首先我们解析完成后，随便进入一个方法，这里我就以main方法为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: cp_info #30 &lt;main&gt;  </span><br><span class="line">descriptor: cp_info #31 &lt;([Ljava/lang/String:V)&gt;  </span><br><span class="line">Access flags: 0x0009 [public static]</span><br></pre></td></tr></table></figure>

<p>name 就是方法名，告诉你是 main 方法，descriptor 描述，包括 参数类型：LJava…String,L 代表引用，V 代表void 无返回值。Access flags 访问表示，告诉你是 public static。</p>
<p>然后，我们进入 code，byteCode 就是字节码指令, ExceptionTable 就是异常表，没有异常，空。misc 里面就是一些描述，比如 本地变量表的最大长度，还有指令长度，字节码指令0 - 最后那个号。</p>
<p>然后code 里面还有一个 LineNumberTable,里面记录Java 代码和 字节码指令的行号映射关系，lineNumber 表示 Java 行数，startPC 代表字节码指令行数，两个上述一一对应。</p>
<p>LineNumberTable如下：</p>
<p><img src="/images/runtime/line_number_table.png" alt="line_number_table"></p>
<p>然后重点看看本地变量表，局部变量表如下：</p>
<p><img src="/images/runtime/local_var_table.png" alt="local_var_table"></p>
<p>你方法里面有几个局部变量，他就有几行+1，几个字段+1(一般情况是，为啥？实例方法局部变量表中的第一位是 this)：</p>
<ul>
<li><p>name名字： 想必是局部变量的名称</p>
</li>
<li><p>descriptor 描述符： 就是类型，同理L是引用，</p>
</li>
<li><p>startPC起始PC： 是你这个局部变量的作用域的起始位置，是一个 字节码行号， 根据 lineNumber 表找到对应java 的行数，其实就是你java声明了这个局部变量的下一行。</p>
</li>
<li><p>index 序号： 就是索引</p>
</li>
<li><p>length长度： 不是说你这个变量多长，而是作用域长度，结合上面的 startPC， 比如 misc 里面记录的字节码长度是16，就代表你总共有16条指令， 然后已定义了一个变量，从 字节码的 第8行开始，然后到第15(0开始)失效， 那么你的这个 length 就是 8，从第8行开始，在往后的8行内生效。</p>
</li>
</ul>
<h2 id="3-3-槽-Slot"><a href="#3-3-槽-Slot" class="headerlink" title="3.3 槽 Slot"></a>3.3 槽 Slot</h2><p>本地变量表中，会将数据存放到 槽中。</p>
<ul>
<li><p>JVM 会给每一个 slot 分配一个索引，根据这个索引可以访问到局部变量表中的局部变量值。</p>
</li>
<li><p>当一个实例方法被调用时，他的方法参数和局部变量会按顺序复制到每一个 slot 上。</p>
</li>
<li><p>32 bit 的数据占用一个 slot，64bit 的占用两个，64的只有 long 和 double，包括引用都是 32bit的。</p>
</li>
<li><p>如果要访问一个 64bit的数据，只需要访问这个数据的第一个slot的索引即可。</p>
</li>
<li><p>如果当前栈帧被构造方法或者实例方法创建，则 对象 this 会被存到 index 位 0 的栈帧上，其余的按顺序。</p>
</li>
</ul>
<h2 id="3-4-静态变量和局部变量的对比"><a href="#3-4-静态变量和局部变量的对比" class="headerlink" title="3.4 静态变量和局部变量的对比"></a>3.4 静态变量和局部变量的对比</h2><ul>
<li><p>局部变量表初始化完以后，才会按顺序定义局部变量的空间</p>
</li>
<li><p>静态变量有两次机会赋值，第一次是链接阶段的准备阶段，讲静态变量初始化位零值，第二次是 初始化阶段，赋值为我们定义的值。</p>
</li>
<li><p>局部变量没有初始化，他必须我们自己定义初始值，否则不能用。</p>
</li>
</ul>
<h2 id="3-5-补充说明"><a href="#3-5-补充说明" class="headerlink" title="3.5 补充说明"></a>3.5 补充说明</h2><ul>
<li><p>这部分和GC有很大联系的就是局部变量表，方法执行时，通过这东西完成参数传递。</p>
</li>
<li><p>局部变量表中的变量也是GC中重要的根节点，只要是被局部变量表中直接或间接引用的对象都不会被回收。</p>
</li>
</ul>
<h1 id="4-操作数栈"><a href="#4-操作数栈" class="headerlink" title="4. 操作数栈"></a>4. 操作数栈</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>操作数栈，字面意思，就是用于方法内代码执行做运算的。细节如下：</p>
<ul>
<li><p>每一个栈帧除了局部变量表外，还有操作数栈，后进先出。</p>
</li>
<li><p>根据指令的不同，进行 push 和 pop 的操作，也只能进行这两个操作</p>
<ul>
<li><p>某些字节码指令让操作数入栈，然后其他的指令让操作数出栈求和，再重新入栈。</p>
</li>
<li><p>比如 赋值 求和 交换等操作。</p>
</li>
</ul>
</li>
<li><p>主要用于保存计算的中间结果，同时作为计算过程中变量临时的存储空间</p>
</li>
<li><p>操作数栈就是JVM执行引擎的一个工作区，随着方法执行被创建，刚创建时是空的(空 !&#x3D; 没创建)</p>
</li>
<li><p>每个操作数栈都有一个明确的深度来进行存储，也是在编译的时候就已经定义好的， 在code 里面的 max_stack 里面定义，或者 javap 里面 方法的stack 参数</p>
</li>
<li><p>栈里面的每一个元素都可以是任意java类型，32bit的数据占1个栈深度，64bit占2个站深度。</p>
</li>
<li><p>如果被调用的方法有返回值，那么返回值也会入栈，同时PC寄存器更新下一条指令。</p>
</li>
<li><p>栈里面的元素和字节码指令的数据类型必须严格匹配，编译器在编译期间会进行验证。</p>
</li>
<li><p>我们所说的 Java解释引擎是基于栈的，这里的栈 就是 操作数栈。</p>
</li>
</ul>
<h2 id="4-2-具体流程分析"><a href="#4-2-具体流程分析" class="headerlink" title="4.2 具体流程分析"></a>4.2 具体流程分析</h2><p>我们找一段代码来具体分析分析操作数栈到底是干啥的，直接看图：</p>
<p><img src="/images/runtime/operateStack.png" alt="ops_stack"></p>
<p>我们逐条看指令，</p>
<ol>
<li><p>首先进行了 bipush 操作，push 15，将 15 存入操作数栈</p>
</li>
<li><p>执行 istore_1 也就是弹栈得到15后存入局部变量表的1位置(复习一下，0位置存this)</p>
</li>
<li><p>bipush 8，将8存入操作数栈</p>
</li>
<li><p>执行 istore_2 弹栈得8 存入 局部变量表的 2位置</p>
</li>
<li><p>iload_1 这里读取 表中1位置的数据，放入 操作数栈 进行入栈操作</p>
</li>
<li><p>iload_2 读取 表中2位置的数据，入栈</p>
</li>
<li><p>iadd 将两个操作数弹栈，相加，得到结果重新入栈</p>
</li>
<li><p>istore_3 将得到的数据 存储到 局部变量表 3 位置</p>
</li>
<li><p>返回</p>
</li>
</ol>
<p>在这个过程中，这个栈只需要 2 深度，所以可以看到，code 里面的 stack &#x3D;&#x3D; 2.</p>
<p>顺带说一句，这里我们可以看到什么 bipush，sipush，意思就是：b(yte) -&gt; i(nt) 和 s(hort) -&gt; i(nt)</p>
<p>有一种特殊的情况，方法 A return int，然后 方法B 里面调用 A 并用i接收返回值。</p>
<p>首先在方法A里面最后会进行 ireturn，也就是把返回值结果返回，然后在B方法里面，在 调用A方法接受参数的位置，会进行 aload_0他会得到返回值并入栈。</p>
<h1 id="5-动态链接"><a href="#5-动态链接" class="headerlink" title="5. 动态链接"></a>5. 动态链接</h1><blockquote>
<p>或者叫 指向运行时常量池的方法引用</p>
</blockquote>
<p>先说一下符号链接</p>
<ul>
<li>java源文件被编译到class文件里面的时候，所有的变量和方法引用都作为符号引用保存在class常量池中</li>
</ul>
<p>这话简直不是人话，我来给翻译一下：</p>
<p>我们先解析一个class文件，这个原本的Java文件里面有个a方法和b方法，b方法里面调用了a，所以字节码里面方法B有这么一句：</p>
<p><code>1: invokevirtual #6 // Method methodA:()V</code></p>
<p>这就意思是调用了 方法#6，当然注释告诉我其实就是 methodA，然后我们去常量池 里面找 #6 是个啥，然后找半天，不停地指向别的符号，最后指向了 methodA 和 ()V，methodA 就是方法名，()V 就是无参，返回 void 磨磨唧唧不停地指向别的东西。</p>
<p>同时，体现出，所有的东西，都存在常量池中，比如我们输出的 String，也存在 常量池中。</p>
<p>所以：</p>
<p>运行时，将常量池加载到方法区内形成运行时常量池，然后每个栈帧都包含一个 指向运行时常量池中 该栈帧所属方法的引用，那么这个引用，就是动态链接，可以支持该方法实现动态链接。</p>
<p>下面解释一下啥是常量池：</p>
<blockquote>
<p>说的还是不是人话，我这里再解释一下：我们解析一个Class文件会发现里面有个constant pool常量池，这里面包含什么？字符串字面值，各种需要用到的类等等等等。然后下面的代码比如 String st &#x3D; “123”，这个123就会存到常量池中，并不会直接在代码中体现。</p>
<p>JVM读取class的时候，就会去读这个常量池，也就是可以提前知道这个类里面要用到哪些其他的类，以及有用到哪些常量值，然后JVM就会把这个常量池读到运行时数据区，比如常量池中有 System.out 这个类，JVM就会提前把这个类加载到方法区中。总而言之，JVM会读取常量池从而形成运行时常量池。</p>
<p>然后，class文件中，代码会指向常量池中的某些元素，比如 invokevirtual #6，就是指向了#6常量，但是JVM读了以后你不能还指向#6了，因为已经有了运行时常量池，常量池中的元素已经有了具体的内存体现了，那你还指向#6干啥，这时就会让代码直接指向运行时常量池。这一步，也就对应了类加载中的 链接-解析 阶段。</p>
</blockquote>
<p>既然知道了啥是常量池，那么我们再看看这个动态链接，其实就很好理解了，字节码文件中，方法名，方法返回值，方法入参类型，这些都是存在常量池中的东西。那么栈帧应该知道自己这个方法对应到运行时常量池中的是哪个，动态链接就是干这个的。</p>
<h2 id="为何需要常量池"><a href="#为何需要常量池" class="headerlink" title="为何需要常量池"></a>为何需要常量池</h2><p>我们加载一个类，比如我们就写一个类里面有一个主方法，就一个输出，他加载到内存里面就需要加载 比如 父类Object，各种数据类型，System对象，PrintWriter对象，等等。</p>
<p>如果这些东西全都存在 class里面，就很浪费，所以弄一个常量池，把常用的东西放进去，需要的时候直接引用过来就行了。</p>
<h1 id="6-方法调用"><a href="#6-方法调用" class="headerlink" title="6. 方法调用"></a>6. 方法调用</h1><blockquote>
<p>从 JVM 角度看java 方法如何被调用</p>
</blockquote>
<p>上面刚说过，在类加载的时候，会把符号引用转化为直接引用，而这个转化过程是在编译期间完成的还是在运行期间完成的，这个还是有区别的。</p>
<h2 id="6-1-静态链接"><a href="#6-1-静态链接" class="headerlink" title="6.1 静态链接"></a>6.1 静态链接</h2><p>一个字节码文件被加载到 JVM 内部时，如果被调用的目标方法在编译期间可知，且运行期间保持不变，那么这个时候 符号 -&gt; 直接 的转化，就叫静态链接。</p>
<blockquote>
<p>简单说，编译期间转化，就叫静态链接</p>
</blockquote>
<h2 id="6-2-动态链接"><a href="#6-2-动态链接" class="headerlink" title="6.2 动态链接"></a>6.2 动态链接</h2><p>对应的，如果在编译期间无法确定，比如接口回调，需要在运行时转换，则成为动态链接。</p>
<blockquote>
<p>同理，运行期间绑定，动态链接</p>
</blockquote>
<h2 id="6-3-绑定"><a href="#6-3-绑定" class="headerlink" title="6.3 绑定"></a>6.3 绑定</h2><p>什么叫绑定？一个字段，方法，类的符号引用替换成直接引用的过程，只发生一次。同时这里还区分早期绑定和晚期绑定：</p>
<ul>
<li><p>早期绑定：对应静态链接，目标方法在编译期间可知且运行时不变，可以明确被调用的方法是哪一个，使用静态链接的方式进行符号到直接的转化，叫早期绑定</p>
</li>
<li><p>晚期绑定：不确定目标方法，使用动态链接进行转换，就叫晚期绑定</p>
</li>
</ul>
<h2 id="6-4-虚方法和非虚方法"><a href="#6-4-虚方法和非虚方法" class="headerlink" title="6.4 虚方法和非虚方法"></a>6.4 虚方法和非虚方法</h2><p>非虚方法对应 静态链接和早期绑定，在编译期间就确定方法的具体版本。如下都属于非虚方法：</p>
<ul>
<li><p>静态方法</p>
</li>
<li><p>私有方法</p>
</li>
<li><p>final 修饰的方法</p>
</li>
<li><p>实例构造器</p>
</li>
<li><p>父类方法</p>
</li>
</ul>
<p>其他的都属于虚方法。</p>
<h2 id="6-5-虚拟机中调用方法的指令"><a href="#6-5-虚拟机中调用方法的指令" class="headerlink" title="6.5 虚拟机中调用方法的指令"></a>6.5 虚拟机中调用方法的指令</h2><h3 id="6-5-1-调用指令"><a href="#6-5-1-调用指令" class="headerlink" title="6.5.1 调用指令"></a>6.5.1 调用指令</h3><ul>
<li><p>invokeStatic 调用非虚方法</p>
</li>
<li><p>invokeSpecial 调用 <init> 构造方法，私有方法，父类方法</p>
</li>
</ul>
<p>前面两个都属于调用非虚方法</p>
<ul>
<li><p>invokeVirtual 调用虚方法</p>
<blockquote>
<p>但是不代表 invokeVirtual 调用的都是虚方法，特别的，调用final方法，也是 invokeVirtual</p>
</blockquote>
</li>
<li><p>invokeInterface 调用接口方法</p>
</li>
</ul>
<p>还有一个特殊的，调用Lambda 的指令</p>
<ul>
<li>invokeDynamic</li>
</ul>
<p>java7 开始才引入了 invokeDynamic 这个东西，为了体现 java 的 动态类型语言特性。但是 java7 没法直接生成 invokeDynamic 指令，知道 java8 出现了 lambda 表达式，java8 才能直接生成 invokeDynamic 指令。</p>
<h3 id="6-5-2-动态类型语言-和-静态类型语言"><a href="#6-5-2-动态类型语言-和-静态类型语言" class="headerlink" title="6.5.2 动态类型语言 和 静态类型语言"></a>6.5.2 动态类型语言 和 静态类型语言</h3><p>简单说，静态类型语言在编译期间会对数据类型进行检查，动态类型语言会在运行时进行类型检查，变量本身没有类型，变量值才有类型。</p>
<h1 id="7-方法返回值地址"><a href="#7-方法返回值地址" class="headerlink" title="7. 方法返回值地址"></a>7. 方法返回值地址</h1><p>所谓 方法返回值地址，这里我给举个例子：</p>
<p>我们调用 方法 A，方法 A 里面我们有调用了 方法 B，在虚拟机栈的角度，A 入栈，然后B入栈，现在，方法 B 执行完成，那么就需要回到 方法 A 中 调用 B 的那个地方，继续往下执行，方法 B 的返回值，需要给到 方法 A 调用 B 的那一行代码，这就需要方法返回值地址</p>
<p>方法返回值地址里面存储了 PC寄存器中的值，也就是记录了调用方法的位置的下一行代码，然后方法执行完成，将返回值放入操作数栈，然后根据方法返回值地址，回到方法调用的位置，继续执行。</p>
<h2 id="7-1-方法退出的两种情况"><a href="#7-1-方法退出的两种情况" class="headerlink" title="7.1 方法退出的两种情况"></a>7.1 方法退出的两种情况</h2><ul>
<li><p>正常退出，调用者 PC寄存器的值作为返回地址，调用该方法指令的下一条指令地址。</p>
</li>
<li><p>出现未处理异常，非正常退出，返回地址需要异常表来确定，栈帧不保存这部分信息</p>
</li>
</ul>
<p>所以，方法返回值地址仅针对方法正常推退出的情况。</p>
<h2 id="7-2-返回指令："><a href="#7-2-返回指令：" class="headerlink" title="7.2 返回指令："></a>7.2 返回指令：</h2><p>函数返回指令如下：</p>
<ul>
<li><p>ireturn -&gt; intReturn 返回 byte short int boolean char</p>
</li>
<li><p>lreturn -&gt; longReturn 返回 long</p>
</li>
<li><p>freturn -&gt; floatReturn 返回 float</p>
</li>
<li><p>dreturn -&gt; doubleReturn 返回 double</p>
</li>
<li><p>areturn -&gt; 不知道 返回 引用</p>
</li>
<li><p>return -&gt; void 方法无返回值</p>
</li>
</ul>
<h2 id="7-3-异常表"><a href="#7-3-异常表" class="headerlink" title="7.3 异常表"></a>7.3 异常表</h2><p>如果方法存在异常，则会有一个异常表进行处理，在方法里面，需要 javap</p>
<p>结构如下：</p>
<table>
<thead>
<tr>
<th>from</th>
<th>to</th>
<th>target</th>
<th>type</th>
</tr>
</thead>
<tbody><tr>
<td>6</td>
<td>8</td>
<td>11</td>
<td>java&#x2F;io&#x2F;IOException</td>
</tr>
</tbody></table>
<p>意思如下：</p>
<p>从 6 到 8 行 如果出现异常IOException，交给 11 处理，其实也就是 try catch 代码块里面的东西。</p>
<h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p>很好，栈总算是说完了。下面就是牛逼的堆了。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
</search>
