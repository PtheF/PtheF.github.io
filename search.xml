<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01.操作系统基础概念</title>
    <url>/2023/06/30/01-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer" />

<p>操作系统基础概念</p>
<span id="more"></span>

<h1 id="1-操作系统的定义"><a href="#1-操作系统的定义" class="headerlink" title="1. 操作系统的定义"></a>1. 操作系统的定义</h1><p>操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的借口和环境；她是计算机系统中最基本的系统软件。</p>
<h1 id="2-操作系统的功能和目标"><a href="#2-操作系统的功能和目标" class="headerlink" title="2. 操作系统的功能和目标"></a>2. 操作系统的功能和目标</h1><h2 id="2-1-向上层提供方便易用的服务"><a href="#2-1-向上层提供方便易用的服务" class="headerlink" title="2.1 向上层提供方便易用的服务"></a>2.1 向上层提供方便易用的服务</h2><p>操作系统的主要功能和目标就是向上层提供方便易用的服务，这里用qq视频为例：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616151323.png" alt="image.png"></p>
<p>总体如下：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616152019.png" alt="image.png"><br>这里稍微解释一下联机命令接口和脱机命令接口。</p>
<ul>
<li>联机命令接口就是我说一句系统做一句，其实就是我直接输入的类似 ls 的这种指令。</li>
<li>脱机命令接口就是批处理指令，一大堆命令写的指令集。<br>程序接口就是程序里面用的，比如C语言的printf，底层就掉用了很多操作系统提供的接口，这种就是程序接口。<br>然后命令接口和程序接口也可以统称为用户接口。</li>
</ul>
<h2 id="2-2-作为最接近硬件的层次"><a href="#2-2-作为最接近硬件的层次" class="headerlink" title="2.2 作为最接近硬件的层次"></a>2.2 作为最接近硬件的层次</h2><p>这个也好理解，操作系统离硬件最近，可以拓展硬件的功能，比如可以在操作系统的层面上实现虚拟机。</p>
<h1 id="3-操作系统的特征"><a href="#3-操作系统的特征" class="headerlink" title="3. 操作系统的特征"></a>3. 操作系统的特征</h1><h2 id="3-1-并发"><a href="#3-1-并发" class="headerlink" title="3.1 并发"></a>3.1 并发</h2><p>这个非常熟悉了，宏观上是同时发生的，但是微观上是交替发生的。对应的是并行，并行就是在同一时间确实是同时发生的。</p>
<p>而在操作系统的层面上来说，并发性指的是计算机系统中“同时”运行着多个程序，这些程序宏观上是同时运行的，而围观上是交替运行的。操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的。</p>
<p>并发性是操作系统一个最基本的特性。</p>
<h2 id="3-2-共享"><a href="#3-2-共享" class="headerlink" title="3.2 共享"></a>3.2 共享</h2><p>共享就是资源共享，指系统中的资源可供内容中的多个并罚执行的进程共同使用。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616153156.png" alt="image.png"></p>
<p>这里所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的，也就是分时共享。</p>
<h2 id="3-3-并发和共享的关系"><a href="#3-3-并发和共享的关系" class="headerlink" title="3.3 并发和共享的关系"></a>3.3 并发和共享的关系</h2><p>并发性指同时存在着多个运行着的程序<br>共享性指系统中的资源可供能存中的多个并罚执行的进程共同使用。</p>
<p>这里举个例子：qq和微信同时发送文件，qq发送文件A，微信发送文件B。qq和微信两个进程并发执行，如果失去了并发性，则系统中只有一个程序正在运行，则共享性失去了意义。两个进程共享的访问硬盘资源，如果失去了共享性，则qq和微信不能同时访问磁盘，则无法并发。</p>
<p>所以并发性和共享性互为<strong>存在条件</strong>。</p>
<h2 id="3-4-虚拟"><a href="#3-4-虚拟" class="headerlink" title="3.4 虚拟"></a>3.4 虚拟</h2><p>这个东西有个概念就行了，往后会重点说，大致就是，我的电脑只有4g内存，我打开一个gta5就用了4g内存，但是我还可以同时打开其他的软件，难道内存不会爆么？这里就涉及虚拟存储器技术的“空分复用技术”。</p>
<p>再比如，一个单核CPU的计算机，但是用户可以打开很多软件，为啥？这里队赢了虚拟处理器技术，更详细的就是“时分复用技术”，微观上处理剂在各个微笑的时间段内加集体的为各个进程服务。</p>
<p>显然，如果失去了并发性，虚拟性也就没有意义了。</p>
<h2 id="3-5-异步"><a href="#3-5-异步" class="headerlink" title="3.5 异步"></a>3.5 异步</h2><p>在多道程序环境中，允许多个程序并发执行，但是由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是异步性，其实说白了就是阻塞，学Java并发的时候很清楚了。</p>
<h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616154733.png" alt="image.png"></p>
<p>并发和共享互为存在条件，没有并发和共享，就谈不上虚拟和异步，所以并发和共享是操作系统的两个最基本的特征。</p>
<h1 id="4-OS的发展和分类"><a href="#4-OS的发展和分类" class="headerlink" title="4. OS的发展和分类"></a>4. OS的发展和分类</h1><h2 id="4-1-手工操作阶段"><a href="#4-1-手工操作阶段" class="headerlink" title="4.1 手工操作阶段"></a>4.1 手工操作阶段</h2><p>这个玩意很反人类，就是最早的纸带，程序员把程序通过打孔的方式写到纸带上，然后把纸带给计算机，计算机计算后将结果大打回到纸带上，然后程序猿再去研究纸带。</p>
<p>这种方式最主要就是资源利用率差，程序猿研究纸带就很浪费时间，而计算机计算又非常快。而且同一时间只有一个程序猿可以使用计算机，总的来说就是资源利用率极低。</p>
<h2 id="4-2-单道批处理系统"><a href="#4-2-单道批处理系统" class="headerlink" title="4.2 单道批处理系统"></a>4.2 单道批处理系统</h2><p>一定程度上解决了上面的问题，程序猿把自己的纸带一块交给一个叫外围机的机器，这个机器会把所有的纸带数据录入到磁带上，然后将磁带交给计算机进行计算，再将结果返回给磁带。</p>
<p>好处就是磁带的读写速度比纸带快很多，计算机的利用率就上来了。但是速度仍然很差，一段时间内只有一个程序在运行。</p>
<h2 id="4-3-多道批处理系统"><a href="#4-3-多道批处理系统" class="headerlink" title="4.3 多道批处理系统"></a>4.3 多道批处理系统</h2><p>这里操作系统就真正的诞生了，计算机可以从内容（也就是磁带）中读取多道程序，然后并发的执行，将结果返回给磁带，优点就是多道程序并发执行，共享计算机资源。资源利用率大幅提高，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616155831.png" alt="image.png"></p>
<h2 id="4-4-分时操作系统"><a href="#4-4-分时操作系统" class="headerlink" title="4.4 分时操作系统"></a>4.4 分时操作系统</h2><p>这里就有了时间片，计算机以时间片为单位轮流为各个用户&#x2F;作业进行服务，各个用户可以通过终端与计算机交互。</p>
<p>主要优点：用户请求可以即时被响应，解决了人机交互的问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p>
<p>主要缺点：不能及时处理一些紧急的任务。</p>
<h2 id="4-5-实时操作系统"><a href="#4-5-实时操作系统" class="headerlink" title="4.5 实时操作系统"></a>4.5 实时操作系统</h2><p>这种可以优先响应一些紧急任务，某些紧急任务不需要时间片排队。在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在<strong>严格的时限内处理完事件</strong>。实施操作系统的主要特点是<strong>及时性和可靠性</strong>。<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616160422.png" alt="image.png"></p>
<h2 id="4-6-其他操作系统"><a href="#4-6-其他操作系统" class="headerlink" title="4.6 其他操作系统"></a>4.6 其他操作系统</h2><p>这里看看图就行了，不多说。<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616160520.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>02.操作系统</title>
    <url>/2023/06/30/02-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>操作系统</p>
<span id="more"></span>

<h1 id="1-操作系统运行机制"><a href="#1-操作系统运行机制" class="headerlink" title="1. 操作系统运行机制"></a>1. 操作系统运行机制</h1><h2 id="1-1-两种程序"><a href="#1-1-两种程序" class="headerlink" title="1.1 两种程序"></a>1.1 两种程序</h2><p>两种程序分为：应用程序和内核程序。</p>
<p>应用程序很好理解，就是跑在OS上的程序，比如QQ，微信，程序猿开发的一些程序等等。而开发操作系统的开发人员，开发的就是内核程序，很多的内核程序组成了操作系统内核，或者简称内核（Kernel），内核是OS最重要最核心的部分，也是最接近硬件的部分，甚至可以说一个OS只需要内核就够了，比如 Docker，一个 Linux 容器可以只包含了 Linux 内核。</p>
<h2 id="1-2-两种指令"><a href="#1-2-两种指令" class="headerlink" title="1.2 两种指令"></a>1.2 两种指令</h2><p>首先明确一个概念，指令指的是CPU执行的二进制的那一串一串的玩意，详细的可以在计算机组成原理里面学到，而我们执行的那些 cd ls 啥的都是我们之前说的命令接口。</p>
<p>CPU有一些比较牛逼的指令比如清空内存这类的，这类功能肯定不是谁想用谁就用的，只能是OS的管理者——操作系统内核才有资格执行这种指令。所以CPU就分了两种指令：特权指令和非特权指令。普通应用程序只能使用“非特权指令”，比如加减指令这些。而更危险的特权指令只能由内核程序来发送。</p>
<p>但是CPU只负责一条一条的执行指令，CPU出厂的时候就已经定好了特权指令，他确实可以分辨特权指令，但是他怎么知道这个指令是内核发来的还是应用程序发来的？</p>
<h2 id="1-3-CPU-两种状态"><a href="#1-3-CPU-两种状态" class="headerlink" title="1.3 CPU 两种状态"></a>1.3 CPU 两种状态</h2><p>CPU有两种状态，“内核态” 与 “用户态”，用户态时，CPU只能执行非特权指令，内核态时，CPU就可以执行特权指令了。</p>
<p>同时，CPU里面有一个寄存器叫 <strong>程序状态字寄存器（PSW）</strong>，其中又个二进制位，1表示当前时内核态，0表示用户态。</p>
<p>两种状态还有个别名：内核态 &#x3D; 核心态 &#x3D; 管态； 用户态 &#x3D; 目态。</p>
<h2 id="1-4-CPU状态切换"><a href="#1-4-CPU状态切换" class="headerlink" title="1.4 CPU状态切换"></a>1.4 CPU状态切换</h2><p>流程如下：</p>
<ul>
<li>刚开机时，CPU状态是内核态，操作系统的内核程序先上CPU运行</li>
<li>开完机以后，内核程序会向CPU发送一条特权指令，将PSW从1改成0，进而变成用户态，操作系统就会让出CPU的使用权。</li>
<li>然后就可以执行其他的应用程序。</li>
<li>假设，这个应用程序被黑了，被植入了一条特权指令，CPU读取到这个特权指令后，检查PSW发现自己是用户态，不能执行该指令，就引发一个<strong>中断信号</strong>。</li>
<li>CPU检测到中断信号后，会立即变成<strong>核心态</strong>，并停止运行当前的应用程序，转而运行处理中断信号的内核程序。也就是<strong>中断</strong>会使操作系统重新夺回CPU的控制权。</li>
<li>操作系统处理完了中断时间后，再将CPU使用权交给别的应用程序。</li>
</ul>
<p>两种状态切换：</p>
<ul>
<li>内核态-&gt;用户态：执行一条特权指令即可，操作系统会让出CPU使用权</li>
<li>用户态-&gt;内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号以为着操作系统将强行夺回CPU的使用权。</li>
</ul>
<h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h2><p>一张图：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616163352.png" alt="image.png"></p>
<h1 id="2-中断和异常"><a href="#2-中断和异常" class="headerlink" title="2. 中断和异常"></a>2. 中断和异常</h1><h2 id="2-1-中断的作用"><a href="#2-1-中断的作用" class="headerlink" title="2.1 中断的作用"></a>2.1 中断的作用</h2><p>上面就说过了，操作系统内核程序是整个操作系统的管理者，在合适的情况下，操作系统会将CPU使用权让给应用程序，“中断”则是<strong>让操作系统内核夺回CPU使用权</strong>的唯一途径。</p>
<p>如果没有“中断”机制，CPU就会一直运行一个程序，还怎么并发？</p>
<h2 id="2-2-中断的分类"><a href="#2-2-中断的分类" class="headerlink" title="2.2 中断的分类"></a>2.2 中断的分类</h2><p>分为两类：内中断和外中断。</p>
<p><strong>内中断</strong></p>
<p>上面说的黑客例子就是一个内中断，CPU在用户态接收了一个特权指令进而引发内中断。CPU如果执行的指令是非法的，或者指令的某些参数是非法的，比如除以0，就会引发内中断。</p>
<p>另一种情况就是，我们的应用程序要调用操作系统的一些功能，就需要发送一条特殊的指令——<strong>陷入指令</strong>，意味着应用程序主动将CPU控制权还给操作系统内核，让操作系统帮我干一些事儿。陷入指令也会引发内中断。当然需要注意的是，陷入指令并不是特权指令。</p>
<p><strong>外中断</strong></p>
<p>中断和CPU当前的指令没有关系，中断信号来源于CPU<strong>外部</strong>。比如时钟中断，这个东西就是实现了CPU时间片轮转。现在有两个程序A和B，程序A执行了50ms了，时钟一看差不多该转了，就会给CPU发送一个始终中断信号，然后CPU就会切换到内核态执行时钟中断的内核程序，这个内核程序就可以让CPU待会去执行程序B而非程序A。</p>
<p>其他的比如IO设备，打印机。打印完成后打印机就会发送一个中断信号，这个来源于CPU外部，也属于外中断。</p>
<p>用一张图来说明：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616165006.png" alt="image.png"></p>
<p>这里可以看到，异常也就是内中断，而如果我们直接说中断，大部分情况下说的都是外中断。</p>
<h2 id="2-3-中断机制的基本原理"><a href="#2-3-中断机制的基本原理" class="headerlink" title="2.3 中断机制的基本原理"></a>2.3 中断机制的基本原理</h2><p>不同的中断信号，需要不同的中断处理程序来处理，比如时钟中断，就得用相应的处理程序去进行时间片轮转。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616165337.png" alt="image.png"></p>
<h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616165425.png" alt="image.png"></p>
<h1 id="3-系统调用"><a href="#3-系统调用" class="headerlink" title="3. 系统调用"></a>3. 系统调用</h1><h2 id="3-1-什么是系统调用"><a href="#3-1-什么是系统调用" class="headerlink" title="3.1 什么是系统调用"></a>3.1 什么是系统调用</h2><p>我们之前说过：操作系统向上提供了一些简单易用的服务。主要包括命令接口和程序接口。其中程序接口由一组系统调用组成。</p>
<p>”系统调用“是操作系统提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong>。</p>
<p>编程语言的库函数和系统调用的区别：系统调用向上层提供服务，让上层程序可以请求内核服务，这个上层程序有可能就是库函数，很多库函数就使用了系统调用，然后进行封装，让我们调用的更加方便。</p>
<p>但是并不是所有的库函数都用了系统调用，比如C语言的 abs 函数就没用，其他的一些比如创建一个新文件这类的函数，肯定就会用到系统调用。<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616170342.png" alt="image.png"></p>
<h2 id="3-2-系统调用重要性"><a href="#3-2-系统调用重要性" class="headerlink" title="3.2 系统调用重要性"></a>3.2 系统调用重要性</h2><p>这么个场景：用 WPS 和 office 同时打印论文，如果两个进程都可以直接调用IO设备，并发的使用打印机，那么两个论文就会混在一起了。</p>
<p>所以，将这类共享资源交给操作系统内核进行统一管理，并向上提供“系统调用”，用户进程想要使用打印机，只能通过系统调用向操作系统内核发出请求，然后内核再对哥哥请求进行协调处理，该阻塞阻塞。</p>
<h2 id="3-3-什么功能要用到系统调用"><a href="#3-3-什么功能要用到系统调用" class="headerlink" title="3.3 什么功能要用到系统调用"></a>3.3 什么功能要用到系统调用</h2><p>很简单，凡是与共享资源有关的操作（存储分配、IO操作、文件管理），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616170934.png" alt="image.png"></p>
<h2 id="3-4-系统调用过程"><a href="#3-4-系统调用过程" class="headerlink" title="3.4 系统调用过程"></a>3.4 系统调用过程</h2><p>这个就很有意思了，假设我们的C语言要开辟一个新进程：</p>
<ul>
<li>首先，向CPU发送一条指令，将fork存到CPU的寄存器中</li>
<li>然后，再向CPU发送一条指令，将具体的参数存到寄存器中</li>
<li>发送陷入指令（trap），CPU一看trap指令就会发生内中断，然后调用处理trap的内核程序，这个内核程序就会将寄存器中存的参数取出来，一看，奥，你要执行fork，然后具体参数是多少多少，然后内核程序给你执行</li>
<li>执行完了以后，回到用户态。</li>
</ul>
<p>需要注意的是，陷入指令是用户态执行的，然后立即引发一个内中断，CPU进入内核态；发送系统调用请求是在用户态，而对系统调用的相应处理是在核心态下进行。</p>
<p>顺带：陷入指令 &#x3D; trap 指令 &#x3D; 访管指令</p>
<h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616171751.png" alt="image.png"></p>
<h1 id="4-操作系统体系结构"><a href="#4-操作系统体系结构" class="headerlink" title="4. 操作系统体系结构"></a>4. 操作系统体系结构</h1><h2 id="4-1-内核结构"><a href="#4-1-内核结构" class="headerlink" title="4.1 内核结构"></a>4.1 内核结构</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616172203.png" alt="image.png"></p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616172333.png" alt="image.png"><br>上面的三种东西，时钟，中断，原语，这三个东西和硬件最为紧密，是一定要放在内核中的。但是下面三个 进程、存储器、设备，不会直接涉及到硬件，所以有些操作系统并不会将他们放到内核中。</p>
<p>这就引出两种操作系统设计方法；</p>
<ul>
<li>将所有内容包含在内核中，包括 进程、寄存器、设备管理，就叫大内核。</li>
<li>只保留时钟，中断，原语等核心功能，这种设计就叫微内核。</li>
</ul>
<p>微内核情况下，核心功能跑在内核态，其他的进程管理、寄存器管理、设备管理就会跑在用户态。</p>
<h2 id="4-2-两种内核的区别"><a href="#4-2-两种内核的区别" class="headerlink" title="4.2 两种内核的区别"></a>4.2 两种内核的区别</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616172949.png" alt="image.png"></p>
<p>主要就是变态这块有点区别，剩下的没啥。</p>
<h2 id="4-3-大小内核总结"><a href="#4-3-大小内核总结" class="headerlink" title="4.3 大小内核总结"></a>4.3 大小内核总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616173054.png" alt="image.png"></p>
<h2 id="4-4-分层结构"><a href="#4-4-分层结构" class="headerlink" title="4.4 分层结构"></a>4.4 分层结构</h2><p>这个和Java的什么三层架构很像，操作系统分为多个层，每层可单向调用更低一层提供接口：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616175224.png" alt="image.png"></p>
<p>好处就是易于调试，而且想要在两层之间加一层的话也是比较简单的。</p>
<p>但是缺点就是，层与层的划分有的时候并不明确，比如进程管理和内存管理，两种功能相互调用，在分层结构中就比较难办。同时，A层不能直接调用D层，而是需要依次向下传递调用，效率会比较慢。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616175454.png" alt="image.png"></p>
<h2 id="4-5-模块化结构"><a href="#4-5-模块化结构" class="headerlink" title="4.5 模块化结构"></a>4.5 模块化结构</h2><p>将操作系统按照功能划分为若干个具有一定独立性的模块。每个模块具有某方面的管理功能，并会定好个模块之间的接口，使各模块之间能通过接口进行通信。还可以进一步将各模块细分为若干个具有一定功能的自模块，同样也规定好各自模块之间的接口。将这种设计方法称为模块-接口法：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616175731.png" alt="image.png"><br>这里面内核包括主模块和加载模块，主模块包含最主要的功能，没有主模块没法启动，加载模块非必需，可以按照需求动态添加。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616180219.png" alt="image.png"></p>
<h2 id="4-6-大小内核"><a href="#4-6-大小内核" class="headerlink" title="4.6 大小内核"></a>4.6 大小内核</h2><p>这个就是之前重点在说的，直接看图就行了：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616180256.png" alt="image.png"></p>
<h2 id="4-7-外核"><a href="#4-7-外核" class="headerlink" title="4.7 外核"></a>4.7 外核</h2><p>一般情况下，OS给用户分配的都是虚拟的资源，比如虚拟的内存空间，我们看到的内存是连续的，但其实在物理上压根不是连续的。外存就是跳过了虚拟这一步，外存讲究不虚拟，不抽象，直接调用硬件资源给你，让资源管理更加灵活，同时外核也负责保证这些硬件资源的安全。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616180900.png" alt="image.png"></p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616180834.png" alt="image.png"></p>
<h1 id="5-操作系统引导"><a href="#5-操作系统引导" class="headerlink" title="5. 操作系统引导"></a>5. 操作系统引导</h1><p>简单说就是怎么开机，我们买回来一块硬盘，装在电脑上，然后分完区，将系统装在C盘上，磁盘就会出现一个东西叫主引导记录：里面记录的磁盘的引导程序和磁盘的分区表。</p>
<p>同时电脑的内存分为两类：RAM和ROM，ROM断电后是不会消失的，然后我们来看看电脑是怎么开机的。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616181654.png" alt="image.png"></p>
<ul>
<li>通电以后，CPU开始工作，CPU执行ROM中的引导程序，主要就是自检，同时指示CPU将磁盘中的主引导记录导入内存</li>
<li>CPU开始执行磁盘引导程序，磁盘引导程序会根据分区表去判断C盘的位置，然后就可以将C盘的第一部分数据读入内存，也就是引导记录PBR</li>
<li>这个PBR本质上也是个程序，CPU执行这个PBR，就会找到C盘根目录中的启动管理程序，然后这个程序负责初始化操作系统。</li>
</ul>
<h1 id="6-虚拟机"><a href="#6-虚拟机" class="headerlink" title="6. 虚拟机"></a>6. 虚拟机</h1><p>虚拟机：使用虚拟化技术，将一台物理机器虚拟化为堕胎虚拟机起，每个虚拟机起都可以独立运行一个操作系统。</p>
<p>同义术语：虚拟机管理程序&#x2F;虚拟机监控程序&#x2F;Virtual Machine Monitor（VMM）&#x2F; Hypervisor</p>
<h2 id="6-1-第一类虚拟机"><a href="#6-1-第一类虚拟机" class="headerlink" title="6.1 第一类虚拟机"></a>6.1 第一类虚拟机</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616183023.png" alt="image.png"></p>
<p>虚拟机管理程序直接运行在硬件上，然后将硬件资源分配给上层的各个虚拟机。但是这里有个问题，虚拟机以为自己是真实的机器，所以他们也会有虚拟的内核态，就会向真实CPU发送特权指令，但是整个虚拟机其实都是真实机的用户态，怎么办？</p>
<p>简单，VMM会截获虚拟机发送过来的特权指令，然后将特权指令进行等价转化，让虚拟机以为自己的特权指令执行成功。</p>
<h2 id="6-2-第二类虚拟机"><a href="#6-2-第二类虚拟机" class="headerlink" title="6.2 第二类虚拟机"></a>6.2 第二类虚拟机</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616183342.png" alt="image.png"></p>
<h2 id="6-3-两类虚拟机区别"><a href="#6-3-两类虚拟机区别" class="headerlink" title="6.3 两类虚拟机区别"></a>6.3 两类虚拟机区别</h2><p>直接看图吧，没啥说的了：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616184114.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>03.进程</title>
    <url>/2023/06/30/03-%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>进程</p>
<span id="more"></span>

<h1 id="1-进程概念"><a href="#1-进程概念" class="headerlink" title="1. 进程概念"></a>1. 进程概念</h1><p>程序就是磁盘上的可执行文件，而进程就是动态的执行。</p>
<p>如果我们一次打开多个进程，操作系统怎么知道哪个是哪个？</p>
<h1 id="2-进程的组成"><a href="#2-进程的组成" class="headerlink" title="2. 进程的组成"></a>2. 进程的组成</h1><p>先说结论，进程实体由PCB、程序段、数据段 组成：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617214531.png" alt="image.png"></p>
<h2 id="2-1-PCB-程序控制块"><a href="#2-1-PCB-程序控制块" class="headerlink" title="2.1 PCB-程序控制块"></a>2.1 PCB-程序控制块</h2><p>操作系统会为每个进程分配一个ID——PID，同时操作系统还会记录当前这个进程的所属用户UID，还要记录给这个进程分配了多少资源；以及记录进程的运行情况，比如 CPU 使用时间，磁盘使用情况等。</p>
<p>操作系统需要为一个进程维护这么多信息，这些信息就会统一的保存在一个数据结构中——PCB（Process Control Block），也就是<strong>进程控制块</strong>，操作系统需要对各个并发运行的进程进行管理，单发管理时所需要的信息，都会放在PCB中。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617213809.png" alt="image.png"></p>
<h2 id="2-2-程序段和数据段"><a href="#2-2-程序段和数据段" class="headerlink" title="2.2 程序段和数据段"></a>2.2 程序段和数据段</h2><p>这个其实好理解，一个可执行文件，运行的时候就会把指令放在内存中供CPU读取执行，那么这些内存中的指令，就是程序段。而执行过程中肯定会产生不少数据，这些数据也会存在内存中，这么用来存数据的部分，就是这个进程的数据段。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617214306.png" alt="image.png"></p>
<h1 id="3-进程的特征"><a href="#3-进程的特征" class="headerlink" title="3. 进程的特征"></a>3. 进程的特征</h1><p>一张图：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617214648.png" alt="image.png"></p>
<h1 id="4-进程状态"><a href="#4-进程状态" class="headerlink" title="4. 进程状态"></a>4. 进程状态</h1><h2 id="4-1-进程的各个状态"><a href="#4-1-进程的各个状态" class="headerlink" title="4.1 进程的各个状态"></a>4.1 进程的各个状态</h2><p>这个和线程状态感觉特别像。</p>
<p><strong>创建态</strong></p>
<p>当进程被创建时，它的状态就是“创建态”，这个阶段操作系统会给她分配资源，初始化PCB。</p>
<p><strong>就绪态</strong></p>
<p>当进程创建完成后，就会进入“就绪态”，处于就绪态的进程已经具备了运行条件，但是由于CPU比较忙，所以还不能运行这个进程。</p>
<p><strong>运行态</strong></p>
<p>等CPU空闲了，就会拿过来一个处于就绪态的进程去运行，那么这个被运行的进程就处于“运行态”。</p>
<p><strong>阻塞态</strong></p>
<p>假设这个进程就是WPS，他要让打印机进行打印，然后CPU就会给这个进程分配打印机资源，但是这个打印机正在干活，没空为这个进程服务，那么这个进程就会进入“阻塞态”。总的来说，进程运行时，可能会请求等待某个事件的发生，这里就是等待打印机空闲，在这个事件发生之前，操作系统就会让这个进程下CPU，并让他进入“阻塞态”。</p>
<p>等到打印机空闲了，这个进程就会重新回到就绪态，然后等待被调度上CPU。</p>
<p><strong>终止态</strong></p>
<p>使用完打印机，这个进程就该结束了，然后进程就会执行 exit 系统调用，请求操作系统终止该进程。此时进程就会进入“终止态”，操作系统就会让这个进程下CPU，并回收内存空间等资源，最后回收这个进程的PCB。</p>
<h2 id="4-2-进程状态的转换"><a href="#4-2-进程状态的转换" class="headerlink" title="4.2 进程状态的转换"></a>4.2 进程状态的转换</h2><p>这个转换和线程的状态转换也是非常像：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617220127.png" alt="image.png"></p>
<h2 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h2><p>看图：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617220107.png" alt="image.png"></p>
<h1 id="5-进程的组织"><a href="#5-进程的组织" class="headerlink" title="5. 进程的组织"></a>5. 进程的组织</h1><p>这个说的就是操作系统如何管理各个进程的PCB，这里说两个组织方式：</p>
<h2 id="5-1-链接方式"><a href="#5-1-链接方式" class="headerlink" title="5.1 链接方式"></a>5.1 链接方式</h2><p>操作系统提供几个指针来指向不同的PCB：</p>
<ul>
<li>执行指针：指向当前运行的进程PCB</li>
<li>就绪队列指针：将所有就绪的进程PCB放入队列，优先级高的进程放在队头，然后指针指向队头</li>
<li>阻塞队列指针：和上面类似。</li>
</ul>
<p>阻塞队列指针有的时候会分开，比如进程1 3 5 等待打印机，就会把PCB1 3 5 放入打印机的阻塞队列，进程 2 4 6 等待磁盘，就会把PCB 2 4 6 放入磁盘的阻塞队列。</p>
<h2 id="5-2-索引方式"><a href="#5-2-索引方式" class="headerlink" title="5.2 索引方式"></a>5.2 索引方式</h2><p>也会提供指针，但是指针不会直接指向PCB。</p>
<ul>
<li>执行指针：也是指向当前运行进程的PCB</li>
<li>就绪表指针：指向了一个记录就绪进程表的指针，表里面记录了PCB的位置</li>
<li>阻塞表指针：同理</li>
</ul>
<p>看看图就理解了：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617220726.png" alt="image.png"></p>
<h2 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617220803.png" alt="image.png"></p>
<h1 id="6-进程控制"><a href="#6-进程控制" class="headerlink" title="6. 进程控制"></a>6. 进程控制</h1><p>前面重点说了进程的状态以及操作系统如何组织PCB，这里就说说操作系统具体如何实现各个进程的转换，也就是进程控制。</p>
<h2 id="6-1-如何实现进程控制"><a href="#6-1-如何实现进程控制" class="headerlink" title="6.1 如何实现进程控制"></a>6.1 如何实现进程控制</h2><p>这里首先复习一下，前面说过一个词——“原语”，这个东西是操作系统内核的组成部分，非常重要。我们这里先给结论：进程控制需要使用原语来实现。</p>
<p>一个进程从阻塞态变为就绪态需要干两件事：将这个进程的PCB的state改为2，此时这个PCB在阻塞队列里；然后将PCB放入就绪队列中。这两件事儿一定要一起执行，如果中断，就会导致PCB的state和所处队列不一致，可能就会出现BUG。</p>
<p>之前说过，原语的执行具有原子性，执行原语的过程中不允许被打断，和上面说的就非常吻合，所以就要用原语来实现进程控制。</p>
<h2 id="6-2-原语为啥原子性"><a href="#6-2-原语为啥原子性" class="headerlink" title="6.2 原语为啥原子性"></a>6.2 原语为啥原子性</h2><p>一般情况下，CPU每执行完一个指令，就会去检查有没有外部的中断信号，如果有就会中断，去执行中断处理程序。为了变面外中断干扰，CPU提供了两条特权指令：</p>
<ul>
<li>关中断指令：CPU执行这条指令后，往后面的指令都不会检查外部中断，一定会往下执行</li>
<li>开中断指令：CPU执行后，恢复到以前的执行完检查外中断的模式，往后就不能保证原子性</li>
</ul>
<p>依靠这两条指令就可以实现原子性：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617222120.png" alt="image.png"></p>
<p>图中，指令a 和 指令b 一起执行，这两条指令就有了原子性。</p>
<h2 id="6-3-进程控制相关原语"><a href="#6-3-进程控制相关原语" class="headerlink" title="6.3 进程控制相关原语"></a>6.3 进程控制相关原语</h2><h3 id="6-3-1-创建原语"><a href="#6-3-1-创建原语" class="headerlink" title="6.3.1 创建原语"></a>6.3.1 创建原语</h3><p>也就是涉及到创建进程的原语：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617222353.png" alt="image.png"><br>这里提一句：这个作业调度里面的作业，指的就是外存里面的程序，把外存里面的程序读入内存，就是作业调度。</p>
<h3 id="6-3-2-撤销原语"><a href="#6-3-2-撤销原语" class="headerlink" title="6.3.2 撤销原语"></a>6.3.2 撤销原语</h3><p>让进程结束要用到的原语：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617222743.png" alt="image.png"></p>
<h3 id="6-3-3-阻塞和唤醒"><a href="#6-3-3-阻塞和唤醒" class="headerlink" title="6.3.3 阻塞和唤醒"></a>6.3.3 阻塞和唤醒</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617222901.png" alt="image.png"></p>
<h3 id="6-3-4-切换原语"><a href="#6-3-4-切换原语" class="headerlink" title="6.3.4 切换原语"></a>6.3.4 切换原语</h3><p>这个原语是干嘛的？就是说时间片轮转嘛，一个进程的时间片到了，他就需要从运行态返回就绪态，然后另一个进程上CPU，从就绪态变成运行态。切换原语就是干这个的：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617223007.png" alt="image.png"></p>
<h3 id="6-3-5-进程的运行环境"><a href="#6-3-5-进程的运行环境" class="headerlink" title="6.3.5 进程的运行环境"></a>6.3.5 进程的运行环境</h3><p>前面说要把进程的运行环境保存到PCB中，进程的运行环境是啥？</p>
<p>首先说一下：CPU里面有两个比较重要的寄存器，PC和IR，PC也就是程序计数器，它指向了下一条要执行的指令；IR是当前正在执行的指令。然后还有一些别的寄存器就不说了。</p>
<p>如果现在只有一个进程在运行，有指令 1 2 3 4，那很好解释，CPU将指令1存入IR，PC指向指令2，然后执行IR中的指令。然后CPU根据PC找到指令2，将指令2存入IR，然后PC接着指向指令3，然后CPU执行指令2，以此类推。</p>
<p>但是如果要进行时间片轮转，执行到指令2之后要下CPU了，咋办？下次再上CPU，CPU如何恢复这些IR和PC？操作系统就会把CPU这些寄存器的数据存到PCB中，等下一次再将PCB读会到CPU。那么这些寄存器的数据，就是这个进程的运行环境信息。</p>
<h2 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617224219.png" alt="image.png"></p>
<h1 id="7-进程通讯"><a href="#7-进程通讯" class="headerlink" title="7. 进程通讯"></a>7. 进程通讯</h1><p>首先，进程之间通讯需要操作系统进行支持。进程是分配系统资源的单位（包括内存地址空间），因此各个进程拥有的内存地址空间相互独立。为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p>
<p>所以，操作系统为进程通讯提供了三种方式：共享存储、消息传递、管道通讯。</p>
<h2 id="7-1-共享存储"><a href="#7-1-共享存储" class="headerlink" title="7.1 共享存储"></a>7.1 共享存储</h2><p>这个很好理解，一个进程需要对外暴露共享，他就可以在内存中再申请一片空间，共享数据往这片空间写就行了，然后别的进程来这片空间读即可。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617225020.png" alt="image.png"></p>
<p>互斥这里注意一下就行了，为了避免两个进程都往共享区里面写，操作系统会让写这个操作为互斥操作。</p>
<p>共享存储又分出来两种：基于存储区和基于数据结构。基于存储区的共享，操作系统只负责在内存中划分出来一块共享存储区，数据的形式、存放位置都是通过通信简称控制，而不是操作系统。这种共享方式速度很快，是一种<strong>高级通信</strong>方式。</p>
<p>而基于数据结构的共享，就是操作系统规定，共享空间只能放一个 int[10]，这种共享方式速度慢，限制多，是一种<strong>低级通信</strong>方式。</p>
<p>将内存区域映射到进程的虚拟地址空间，这个先有个印象，往后会详细说。</p>
<h2 id="7-2-消息传递"><a href="#7-2-消息传递" class="headerlink" title="7.2 消息传递"></a>7.2 消息传递</h2><p>进程间的数据交换以<strong>格式化消息</strong>（Message） 为单位。进程通过操作系统提供的“发送消息&#x2F;接收消息”两个<strong>原语</strong>进行数据交换。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617230026.png" alt="image.png"></p>
<h3 id="7-2-1-直接通讯"><a href="#7-2-1-直接通讯" class="headerlink" title="7.2.1 直接通讯"></a>7.2.1 直接通讯</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617230239.png" alt="image.png"></p>
<ul>
<li>首先进程P写一个消息，肯定是在P的地址空间写消息，然后执行发送原语，将消息发出。</li>
<li>进程Q的PCB在操作系统内核空间，PCB内部都有一个消息队列，进程P发来的消息就会挂到这个队列上</li>
<li>然后进程Q执行接收原语，就会在PCB的消息队列上找，哪个是进程P发来的消息</li>
<li>找到消息以后，将这个消息从内核空间PCB上，复制到进程Q的地址空间。</li>
</ul>
<p>所谓的直接通讯，也就是在发送和接收消息的时候指名道姓的说，我这个消息是发给哪个进程的。</p>
<h3 id="7-2-2-间接通信"><a href="#7-2-2-间接通信" class="headerlink" title="7.2.2 间接通信"></a>7.2.2 间接通信</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617230752.png" alt="image.png"></p>
<p>这个也很好理解：</p>
<ul>
<li>进程P同样在自己的地址空间填写消息，但是不再发送给进程Q，而是发送给信箱A。</li>
<li>进程Q会使用接收原语，从信箱A获取这个消息，同样是将消息复制到Q的地址空间。</li>
</ul>
<p>这个就可以多个进程往信箱中发送消息。</p>
<h2 id="7-3-管道通讯"><a href="#7-3-管道通讯" class="headerlink" title="7.3 管道通讯"></a>7.3 管道通讯</h2><p>所谓管道就是特殊的共享文件，又名 pipe 文件。其实就是在内存中开辟一个大小固定的内存缓冲区。这个管道单向传递数据，而且必须按顺序读取数据，类似循环队列。</p>
<p>进程P和进程Q建立pipe，进程P只能往pipe里写，进程Q只能从pipe里读。而且，进程Q只能读最前面未读取的数据，不能像前面共享存储那样，随心所欲想读哪读哪。</p>
<p>重点：</p>
<ul>
<li>管道只能采取半双工通信，也就是在某一时间只能实现单向传输。传输完了以后pipe的方向可以改。如果想要同时进行两个方向的传输，需要设置两个管道。</li>
<li>各个进程要护齿的访问管道，由操作系统实现</li>
<li>当管道写满时，写进程将阻塞，直到读进程将数据取走，即可唤醒写进程</li>
<li>当管道为空时，读进程将阻塞，直到写进程写入数据，即可唤醒读进程。</li>
<li>数据被读走后就会彻底消失。因此如果多个进程同时读一个pipe时，可能会造成混乱。解决方案是：1-一个管道允许多个写进程，一个读进程；2-允许多个写进程多个读进程，但是读进程会轮流读取数据（Linux做法）</li>
</ul>
<p>如果是考试的话，就按多个写进程，一个读进程来就行了。还有，只要pipe没空，读进程就可以读，不用非等pipe满了以后才读，反过来也一样。</p>
<h2 id="7-4-总结"><a href="#7-4-总结" class="headerlink" title="7.4 总结"></a>7.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617232207.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>04.线程</title>
    <url>/2023/06/30/04-%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>线程</p>
<span id="more"></span>

<h1 id="1-什么是线程"><a href="#1-什么是线程" class="headerlink" title="1. 什么是线程"></a>1. 什么是线程</h1><p>有的进程可能需要“同时”做很多事情，而传统的进程只能穿性的执行一系列程序。为此引入了“线程”，来增加并发度。可以吧线程理解成“轻量级进程”</p>
<p>传统的进程是程序执行流的最小单位，引入线程后，线程成为了程序执行流的最小单位，线程是一个基本的CPU执行单元，进程内的各个线程也可以并发，从而进一步提高了系统并发度。</p>
<h1 id="2-线程带来的变化"><a href="#2-线程带来的变化" class="headerlink" title="2. 线程带来的变化"></a>2. 线程带来的变化</h1><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618093531.png" alt="image.png"></p>
<p>这里再提一句，这个进程运行环境在上一章专门说过，也就是CPU里面寄存器那些东西，这些东西需要保存到PCB中，切换进程就需要将当前进程的环境保存到PCB，然后将下一个进程的PCB数据读入，开销会比较大。</p>
<h1 id="3-线程的属性"><a href="#3-线程的属性" class="headerlink" title="3. 线程的属性"></a>3. 线程的属性</h1><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618093825.png" alt="image.png"></p>
<h1 id="4-线程的实现方式"><a href="#4-线程的实现方式" class="headerlink" title="4. 线程的实现方式"></a>4. 线程的实现方式</h1><h2 id="4-1-用户级线程"><a href="#4-1-用户级线程" class="headerlink" title="4.1 用户级线程"></a>4.1 用户级线程</h2><p>早起的操作系统（比如 Unix）只支持进程不支持线程。当时的“线程”是由线程库实现的。比如说我们要写一个程序，这个程序要同时处理文字聊天，视频，文件传输，我们就可以在代码层面这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span>) &#123; 文字聊天 &#125;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">1</span>) &#123; 视频 &#125;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">2</span>) &#123; 文件传输 &#125;</span><br><span class="line">		i = (i + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码我们就简单实现了三个线程，很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能。</p>
<p>说明几个问题：</p>
<ul>
<li>线程的管理工作由用户来完成，操作系统感知不到线程的存在</li>
<li>线程切换不需要CPU变态，因为进程没变</li>
</ul>
<p>这种线程的实现在用户空间即可完成，不需要CPU切换到核心态，所以管理的系统开销小，效率高。但是从代码角度看，如果一个线程被阻塞，整个程序都会被阻塞，并发度不高。同时因为CPU感知不到线程，多个线程不可以在多核处理机上并行运行。</p>
<h2 id="4-2-内核级线程"><a href="#4-2-内核级线程" class="headerlink" title="4.2 内核级线程"></a>4.2 内核级线程</h2><p>这种就是操作系统层面上支持线程，线程的管理工作如线程调度、切换等由操作系统内核完成，所以内核级线程的切换必须要在核心态下才能完成。</p>
<p>和进程类似，操作系统会为每个内核级线程创建相应的TCB（Thread Control Block），通过对TCB来管理线程。“内核级线程”就是“从操作系统内核角度能看到的线程”。</p>
<p>这么做的优点就是当一个线程被阻塞后，别的线程还可以继续执行，并发能力强，而且多个线程就可以被分配到多个处理机上并行执行。而缺点就是一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理成本高。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618095730.png" alt="image.png"></p>
<h1 id="5-多线程模型"><a href="#5-多线程模型" class="headerlink" title="5. 多线程模型"></a>5. 多线程模型</h1><p>如果将用户线程和内核线程结合起来，将用户线程映射到内核线程上，就会有下面这么三种多线程模型。</p>
<h2 id="5-1-一对一模型"><a href="#5-1-一对一模型" class="headerlink" title="5.1 一对一模型"></a>5.1 一对一模型</h2><p>每个用户线程映射到一个内核线程。每个用户进程有与用户线程同数量的内核线程。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618100033.png" alt="image.png"></p>
<p>当一个线程被阻塞后，别的线程还可以继续运行，并发能力强。多线程可以在多核处理机上并行。但是一个用户进程占用多个内核线程，线程管理开销大。</p>
<h2 id="5-2-多对一模型"><a href="#5-2-多对一模型" class="headerlink" title="5.2 多对一模型"></a>5.2 多对一模型</h2><p>多个用户及线程映射到一个内核级线程。且一个进程只分配一个内核级线程。这个东西就是退化回去了，优点和之前一样，线程转换不需要切换到核心态，线程管理开销小。但是线程一旦被阻塞整个进程就会被阻塞，并发度不高。多个线程也不能在多核处理机上并行。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618100426.png" alt="image.png"></p>
<p>切记：<font color='red'> 操作系统只“看得见”内核级线程，因此只有内核线程才是处理机分配的单位。</font></p>
<h2 id="5-3-多对多模型"><a href="#5-3-多对多模型" class="headerlink" title="5.3 多对多模型"></a>5.3 多对多模型</h2><p>N个用户线程映射到M个内核线程上（N&gt;M）。每个用户进程对应M个内核线程。克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核线程，开销太大的缺点。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618100601.png" alt="image.png"></p>
<p>这里用户线程和核心线程的关系：</p>
<ul>
<li>用户线程是“代码逻辑”的载体</li>
<li>内核线程是”运行机会“的载体</li>
</ul>
<p>一端代码逻辑只有获得了运行机会才能被CPU执行。比如三个功能，视频聊天，文字聊天，文件传输，其中视频聊天比较占用资源，就可以给视频聊天的用户线程单独分配一个核心线程，然后文字聊天和文件传输共用另一个核心线程。</p>
<h1 id="6-线程的状态与转换"><a href="#6-线程的状态与转换" class="headerlink" title="6. 线程的状态与转换"></a>6. 线程的状态与转换</h1><p>这个就十分的简单了，和前面的进程几乎是一毛一样，我们只需要着重关注三个状态：就绪、运行、阻塞。线程首先进入就绪状态然后等待CPU分配时间片，然后运行，时间片用完以后就会返回就绪状态。如果在运行的时候等待某件事，就会进入阻塞，等待结束返回就绪态。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618101420.png" alt="image.png"></p>
<h1 id="7-线程的组织与控制"><a href="#7-线程的组织与控制" class="headerlink" title="7. 线程的组织与控制"></a>7. 线程的组织与控制</h1><p>这个和进程也是很类似，操作系统为了管理线程就会为每个线程创建一个TCB线程控制块：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618101912.png" alt="image.png"></p>
<p>这里只说两个东西：</p>
<ul>
<li>其他寄存器：这个东西和之前的进程运行状态类似，就是CPU在执行这个线程的时候寄存器的值</li>
<li>堆栈指针：这个玩意如果学过JVM的话就好理解了，就是指向虚拟机栈的指针，然后这个栈用来记录函数调用情况。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>07.死锁</title>
    <url>/2023/06/30/07-%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<p>死锁</p>
<span id="more"></span>

<h1 id="1-死锁的概念"><a href="#1-死锁的概念" class="headerlink" title="1. 死锁的概念"></a>1. 死锁的概念</h1><p>前面的哲学家进餐就是一个典型的死锁，每个进程要申请其他进程锁住的临界资源，同时自己还占着别的进程的临界资源，就会发生死锁。</p>
<p>然后需要和饥饿，死循环区分一下：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620105802.png" alt="image.png"></p>
<h1 id="2-死锁产生的必要条件"><a href="#2-死锁产生的必要条件" class="headerlink" title="2. 死锁产生的必要条件"></a>2. 死锁产生的必要条件</h1><p>字太多了，懒得打：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620110257.png" alt="image.png"></p>
<h1 id="3-什么时候会发生死锁"><a href="#3-什么时候会发生死锁" class="headerlink" title="3. 什么时候会发生死锁"></a>3. 什么时候会发生死锁</h1><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620110332.png" alt="image.png"></p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620110439.png" alt="image.png"></p>
<h1 id="4-死锁的处理策略"><a href="#4-死锁的处理策略" class="headerlink" title="4. 死锁的处理策略"></a>4. 死锁的处理策略</h1><h2 id="4-1-静态-预防死锁"><a href="#4-1-静态-预防死锁" class="headerlink" title="4.1 静态-预防死锁"></a>4.1 静态-预防死锁</h2><p>上面说了死锁产生的四个条件：互斥条件，不剥夺条件，请求和保持条件，循环等待条件。预防就是依次把这些条件给他破坏了就行。</p>
<h3 id="4-1-1-破坏互斥条件"><a href="#4-1-1-破坏互斥条件" class="headerlink" title="4.1.1 破坏互斥条件"></a>4.1.1 破坏互斥条件</h3><p>只有对必须互斥使用的资源的争抢才会导致死锁。如果把这些互斥资源改造成共享资源，则系统不会进入死锁状态。比如后面要说到的一个 SPOOLing技术，将独占的设备改造成逻辑上共享的设备。这样的话在进程看起来请求资源会被立即接收处理，无需等待。</p>
<p>缺点就是为了保证系统的安全，某些设备必须要被设计成互斥的。</p>
<h3 id="4-1-2-破坏不剥夺条件"><a href="#4-1-2-破坏不剥夺条件" class="headerlink" title="4.1.2 破坏不剥夺条件"></a>4.1.2 破坏不剥夺条件</h3><p>正常情况下，进程获得资源以后，只有使用完成才会释放资源，其他人不能剥夺他的资源。如果其他人可以强制让他释放资源也就不会发生死锁。</p>
<p>方案一：进程请求信资源得不到满足的时候，就会立即释放他持有的资源，等以后需要的时候重新申请，其实就是他自己发现自己活干不了了就主动躺平了。</p>
<p>方案二：如果发现自己要的资源被其他进程占用了，可以让操作系统出面调解，强行剥夺其他进程持有的资源。这种方式需要考虑优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）。</p>
<p>破坏不剥夺条件的缺点：</p>
<ul>
<li>实现复杂</li>
<li>释放已经获得的资源可能会导致前面的工作作废，所以这种办法适合那种易于保存和恢复的资源，比如CPU。</li>
<li>反复申请和释放资源会增加系统开销，降低系统吞吐量。</li>
<li>方式一的话可能会导致饥饿。</li>
</ul>
<h3 id="4-1-3-破坏请求和保持条件"><a href="#4-1-3-破坏请求和保持条件" class="headerlink" title="4.1.3 破坏请求和保持条件"></a>4.1.3 破坏请求和保持条件</h3><p>这个条件本身说的是：进程已经保持了至少一个资源，同时还提出了新的资源<strong>请求</strong>，而该罪案又被其他进程占用，此时请求进程阻塞，仍<strong>保持</strong>着自己已有的资源。</p>
<p>可以使用静态分配方法，进程在运行前一次性申请完他所需要的资源，如果没有申请到，那就不让他运行。一旦运行资源就会一直归他所有，根本上避免进程申请别的资源。</p>
<p>缺点：资源浪费，资源利用率低，可能导致饥饿。</p>
<h3 id="4-1-4-破坏循环等待条件"><a href="#4-1-4-破坏循环等待条件" class="headerlink" title="4.1.4 破坏循环等待条件"></a>4.1.4 破坏循环等待条件</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620112309.png" alt="image.png"></p>
<h3 id="4-1-5-总结"><a href="#4-1-5-总结" class="headerlink" title="4.1.5 总结"></a>4.1.5 总结</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620112338.png" alt="image.png"></p>
<h2 id="4-2-动态-避免死锁"><a href="#4-2-动态-避免死锁" class="headerlink" title="4.2 动态-避免死锁"></a>4.2 动态-避免死锁</h2><h3 id="4-2-1-安全序列"><a href="#4-2-1-安全序列" class="headerlink" title="4.2.1 安全序列"></a>4.2.1 安全序列</h3><p>假设现在有个银行发放贷款，然后各个企业向银行借钱，这些企业会有个借贷总金额的上限，借贷次数可以是多次。现在规定，如果某一次不能满足企业的借贷需求，之前借出去的钱也就要不回来了。</p>
<p>现在问：按照什么顺序给企业发放贷款可以满足全部需求？</p>
<p>假设你有100亿，B企业最多借70亿，A企业最多借40亿，T企业最多借50亿。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620162845.png" alt="image.png"></p>
<p>那如果，借完第一波，A企业又想借30亿，敢借么？如果借出去的话，B或者T企业在来要钱就没了，就不能满足需求。</p>
<p>所以，按照什么顺序依次给这些企业放贷，就是“银行家问题”，得到的这个序列，就是“安全序列”。如果按照安全序列分配资源，每个进程都能顺利完成，那么系统就会处在“安全状态”。如果我们没有按照安全序列分配资源，系统就进入了“不安全状态”，就可能产生死锁问题，如果这个时候某些资源归还了资源，系统就有可能回到“安全状态”。</p>
<h3 id="4-2-2-寻找安全序列"><a href="#4-2-2-寻找安全序列" class="headerlink" title="4.2.2 寻找安全序列"></a>4.2.2 寻找安全序列</h3><p>其实很简单，就是打表然后挨个对比，假设现在有5个进程，每个进程都要申请三种资源，现在已经给他们分配了一部分：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620165403.png" alt="image.png"></p>
<p>现在还剩余（3，3，2），然后用这个和P0-P4挨个对比，看看能满足谁，就给谁分配，分配完了以后进程结束会归还之前的资源，然后重新计算剩余资源数，再去挨个对比。</p>
<p>这里，（3，3，2）可以满足P1，所以把 P1 加入安全队列，P1 使用完资源以后归还之前的资源（2，0，0）和（1，2，2），剩余资源变成（5，3，2）。然后再用（5，3，2）去挨个对比，发现P3可以满足，然后将P3放入安全队列…..一次类推。</p>
<p>手算的话可以简单一点，一上来（3，3，2）可以满足P1和P3，直接把P1和P3加入安全队列就行了，然后加上他们之前持有的资源，然后循环比对。</p>
<p>最后尽可能将所有进程都添加到安全队列中。</p>
<h3 id="4-2-3-银行家算法"><a href="#4-2-3-银行家算法" class="headerlink" title="4.2.3 银行家算法"></a>4.2.3 银行家算法</h3><p>Dijkstra为银行系统设计的一种算法，确保银行放贷的时候可以满足所有客户的需求。在操作系统上，就是提前预知系统会不会进入不安全状态，以此解决资源分配请求，这就是算法的核心思想。银行家算法代码实现的逻辑如下：</p>
<p>系统中有n个进程m种资源。</p>
<p>每个进程都需要先声明对各种资源的最大需求利郎，可以用一个 n * m 的矩阵来表示各种：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620170704.png" alt="image.png"></p>
<p>同时用 Available &#x3D; （3，3，2） 来表示当前剩余的资源量。假设 P0 现在发起请求 Req0 &#x3D; （2，1，1）也就是要申请这么多资源我们就可以这么着：</p>
<ul>
<li>判断 Req &lt;&#x3D; Need，如果不满足认为出错，不给分配资源</li>
<li>判断 Req &lt;&#x3D; Available，如果不满足说明资源紧张，当前进程等待</li>
<li>系统会试探的将资源分配给P0，根据 Available 修改 P0 的 Allocation 和 Need 矩阵。</li>
<li>系统执行安全性算法，根据当前修改寻找安全队列，判断系统是否可以进入安全状态。如果安全，则真正的将资源分配给 P0。</li>
</ul>
<p>这里所谓的安全性算法就是前面的寻找安全队列。</p>
<h2 id="4-3-死锁的检测和解除"><a href="#4-3-死锁的检测和解除" class="headerlink" title="4.3 死锁的检测和解除"></a>4.3 死锁的检测和解除</h2><h3 id="4-3-1-死锁检测"><a href="#4-3-1-死锁检测" class="headerlink" title="4.3.1 死锁检测"></a>4.3.1 死锁检测</h3><p>要检测死锁，就需要做两件事：</p>
<ul>
<li>用某种数据结构来保存资源的请求和分配信息。</li>
<li>提供一种算法，利用上述信息来检测系统是否已经进入死锁状态。</li>
</ul>
<p>数据结构如下：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620212656.png" alt="image.png"></p>
<p>P1 和 P2 两个进程，蓝色的箭头代表他们分别要申请什么资源。R1 和 R2 代表两种资源，里面的点代表资源个数，绿色箭头代表已经给进程分配了多少资源，注意是已经分配的。</p>
<p>然后根据图来分析，P1 进程 要申请1一个R2，R2 已经给了P2一个资源还剩一个资源，所以就可以正常分配给 P1，P1执行结束后，返还资源，也就是将 P1 连着的边全部消除。证明 P1 执行完成并释放资源。同样的方法看 P2，最后也可以消边，最终这个图里面就不存在边，只剩各个节点，则称这个图<font color='red'>可完全简化</font>。</p>
<p>如果一个图可以完全简化，那么此时一定没有发生死锁，其实就相当于我们根据这个图找到了一个安全序列。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620213210.png" alt="image.png"></p>
<p>如果是这种情况，P3 可以正常消边，P1 和 P2 根据分析发现完全没法动，则说明该图不能完全简化，那么就发生了死锁。</p>
<p><strong>具体检测方法</strong></p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620213940.png" alt="image.png"></p>
<h3 id="4-3-2-死锁解除"><a href="#4-3-2-死锁解除" class="headerlink" title="4.3.2 死锁解除"></a>4.3.2 死锁解除</h3><p>根据上面的方法检测到死锁以后，如何解除？</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620214029.png" alt="image.png"></p>
<p>我们再根据以下指标来判断对谁开刀：</p>
<ul>
<li>进程优先级</li>
<li>已经执行多长时间</li>
<li>还要多久完成</li>
<li>进程已经使用了多少资源</li>
<li>进程是交互式的还是批处理式的</li>
</ul>
<h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620214230.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>05.调度</title>
    <url>/2023/06/30/05-%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<p>调度</p>
<span id="more"></span>

<h1 id="1-调度概念"><a href="#1-调度概念" class="headerlink" title="1. 调度概念"></a>1. 调度概念</h1><p>有一堆任务要处理，但是由于资源有限，这些事情没法同时处理。这就需要确定<strong>某种规则</strong>来决定处理这些任务的顺序，这就是”调度“研究的问题。</p>
<h1 id="2-调度三层次"><a href="#2-调度三层次" class="headerlink" title="2. 调度三层次"></a>2. 调度三层次</h1><h2 id="2-1-高级调度"><a href="#2-1-高级调度" class="headerlink" title="2.1 高级调度"></a>2.1 高级调度</h2><p>也叫作业调度，作业就是一个具体的任务，用户向系统提交一个作业 约等于 用户让操作系统启动一个程序（来处理一个具体的任务），这个时候这个程序还在磁盘里面呢。所以高级调度是从磁盘到内存的调度。</p>
<p>我们要启动好几个程序，就需要将这些程序放入内存，但有的时候内存空间有限，无法放入内存。所以高级调度就是：按照一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入时会创建PCB，调出时会撤销PCB。</p>
<h2 id="2-2-低级调度"><a href="#2-2-低级调度" class="headerlink" title="2.2 低级调度"></a>2.2 低级调度</h2><p>也就是进程调度或者叫处理机调度：按照某种策略从就绪队列中选取一个进程，将处理机分配给他。也就是我们之前说的进程的时间片轮转。</p>
<p>进程调度时操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度，而且进程调度的频率很高，一般几十毫秒一次。</p>
<h2 id="2-3-中级调度"><a href="#2-3-中级调度" class="headerlink" title="2.3 中级调度"></a>2.3 中级调度</h2><p>也叫内存调度，内存不够时，可以将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。</p>
<p>暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列。</p>
<p>所以总的来说，中级调度就是按照某种策略决定将哪个处于挂起状态的进程重新调入内存。同样是磁盘到内存。</p>
<h2 id="2-4-七状态模型"><a href="#2-4-七状态模型" class="headerlink" title="2.4 七状态模型"></a>2.4 七状态模型</h2><p>之前我们说的进程状态是5个，开始、结束、就绪、运行、阻塞。现在有了挂起，那么就可以多两种状态：就绪挂起和阻塞挂起。</p>
<ul>
<li>就绪挂起：进程本来是就绪态，但是被挂起了，那就变成就绪挂起，有的时候运行态的进程发现内存没有地方了，也会直接被设为就绪挂起。</li>
<li>阻塞挂起：好理解，就是阻塞的时候内存不够了，这个进程被挂起，就会进入阻塞挂起，阻塞挂起不能直接回到就绪，当阻塞结束时，他会先变为就绪挂起，然后再回到就绪态。</li>
</ul>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618103739.png" alt="image.png"></p>
<p>这种408可能不会考。</p>
<h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618103931.png" alt="image.png"><br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618104043.png" alt="image.png"></p>
<h1 id="3-进程调度的时机"><a href="#3-进程调度的时机" class="headerlink" title="3. 进程调度的时机"></a>3. 进程调度的时机</h1><p>注意，这里可是叫进程调度，也就是对应前面的低级调度。</p>
<p>进程调度的时机就是什么时候可以进行进程调度，什么时候不能进行调度。</p>
<h2 id="3-1-可以进程调度"><a href="#3-1-可以进程调度" class="headerlink" title="3.1 可以进程调度"></a>3.1 可以进程调度</h2><p>两种情况可以进行进程调度：</p>
<ul>
<li>当前运行的进程主动放弃处理机：进程正常终止，或者运行过程中发成异常，或者进程正在等待某事发生阻塞。</li>
<li>当前运行的进程被动放弃处理机：时间片到了，有更紧急的事儿需要处理（比如IO中断），或者有更高优先级的进程进入就绪队列。</li>
</ul>
<h2 id="3-2-不能进程调度"><a href="#3-2-不能进程调度" class="headerlink" title="3.2 不能进程调度"></a>3.2 不能进程调度</h2><ul>
<li>处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在处理中断的过程中进行进程切换</li>
<li>进程在<font color = 'red'>操作系统内核程序临界区</font>中</li>
<li>在原子操作过程中，比如原语。原子操作需要一气呵成，中间不能调度。</li>
</ul>
<h2 id="3-3-临界区"><a href="#3-3-临界区" class="headerlink" title="3.3 临界区"></a>3.3 临界区</h2><p>前面说到了操作系统内核临界区，这里解释一下：</p>
<p>首先说一下临界资源：一个时间段内只允许一个进程使用的资源。各个进程需要互斥地访问临界资源。临界区：访问临界资源的那段代码。</p>
<p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列。根据我学JUC和MySQL 的经验，比如进程要操作就绪队列，就绪队列就属于临界资源，那么操作队列的这段代码就是临界区，为了实现互斥效果，操作队列之前就会给队列上锁，但是这个锁不能老上着啊，一直持有锁不释放很有可能发生BUG，所以这个时候就不能进程调度，而是让当前进程赶紧用完队列赶紧释放锁。</p>
<p>但是还有一种情况，就是程序处在普通临界区，比如程序正在操作打印机，这个时候是没事的。</p>
<h1 id="4-进程调度的方式"><a href="#4-进程调度的方式" class="headerlink" title="4. 进程调度的方式"></a>4. 进程调度的方式</h1><h2 id="4-1-非剥夺调度方式"><a href="#4-1-非剥夺调度方式" class="headerlink" title="4.1 非剥夺调度方式"></a>4.1 非剥夺调度方式</h2><p>也叫非抢占方式。只允许进程主动放弃处理机。在运行过程中即使有更近剖的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动阻塞。</p>
<p>这种方式开销小，但是无法及时执行紧急任务。</p>
<h2 id="4-2-剥夺调度方式"><a href="#4-2-剥夺调度方式" class="headerlink" title="4.2 剥夺调度方式"></a>4.2 剥夺调度方式</h2><p>也叫抢占方式。当一个进程正在处理机上时，如果有一个更重要或者更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要的进程。</p>
<p>可以优先处理更紧急的进程，也可以让各个进程按照时间片轮流执行。适合于分时操作系统和实时操作系统。</p>
<h1 id="5-进程的切换与过程"><a href="#5-进程的切换与过程" class="headerlink" title="5. 进程的切换与过程"></a>5. 进程的切换与过程</h1><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618110321.png" alt="image.png"></p>
<h1 id="6-调度器-x2F-调度程序"><a href="#6-调度器-x2F-调度程序" class="headerlink" title="6. 调度器&#x2F;调度程序"></a>6. 调度器&#x2F;调度程序</h1><p>调度器或者说调度程序（Scheduler）就是具体执行调度的东西，调度器来执行进程从就绪态到运行态的转变。具体调度程序需要决定：</p>
<ul>
<li>让谁来运行：调度算法</li>
<li>运行多长时间：时间片大小</li>
</ul>
<p>而我们之前说的调度时机，其实就是什么事件会出发”调度程序“：</p>
<ul>
<li>创建新进程</li>
<li>进程推出</li>
<li>运行进程阻塞</li>
<li>IO中断发生（可能唤醒某些阻塞的进程）</li>
<li>非抢占式调度策略，只有运行进程发生阻塞或者退出才会触发调度程序工作</li>
<li>抢占式调度策略，每个时钟中断或K个时钟中断会触发调度程序工作</li>
</ul>
<p>对于不支持内核线程的操作系统，调度程序的处理对象就是进程。而对于支持内核线程的操作系统，调度程序的处理对象就是内核线程。因为线程是调度的基本单位。</p>
<h1 id="7-闲逛进程"><a href="#7-闲逛进程" class="headerlink" title="7. 闲逛进程"></a>7. 闲逛进程</h1><p>调度程序的备胎，如果没有其他就绪进程的话，就会运行闲逛进程（Idle）。</p>
<p>Idle 的特性：</p>
<ul>
<li>优先级最低：单反有一个就绪的进程都不会运行他</li>
<li>可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）：就是说这个指令不需要访问CPU啥的</li>
<li>能耗低</li>
</ul>
<h1 id="8-评价调度算法的指标"><a href="#8-评价调度算法的指标" class="headerlink" title="8. 评价调度算法的指标"></a>8. 评价调度算法的指标</h1><h2 id="8-1-CPU利用率"><a href="#8-1-CPU利用率" class="headerlink" title="8.1 CPU利用率"></a>8.1 CPU利用率</h2><p>$$<br>CPU利用率&#x3D;\frac{CPU忙碌时间}{总时间}<br>$$</p>
<p>考研的时候往往会考察多道程序并发执行的情况，可以用“甘特图”来辅助计算。</p>
<h2 id="8-2-系统吞吐量"><a href="#8-2-系统吞吐量" class="headerlink" title="8.2 系统吞吐量"></a>8.2 系统吞吐量</h2><p>指的就是单位时间内完成作业的数量。</p>
<p>$$<br>所以吞吐量&#x3D;\frac{总共完成了多少道作业}{总共花了多少时间}<br>$$</p>
<h2 id="8-3-周转时间"><a href="#8-3-周转时间" class="headerlink" title="8.3 周转时间"></a>8.3 周转时间</h2><p>指的是作业被提交给系统开始，到作业完成为止的这段时间间隔。包括四个部分：</p>
<ul>
<li>作业在外存后备队列上等待作业调度（高级调度）的时间</li>
<li>进程在就绪队列上等待进程调度（低级调度）的时间</li>
<li>进程在CPU上执行的时间</li>
<li>进程等待IO操作完成的时间。</li>
</ul>
<p>后面三项在作业整个处理过程中可能发生多次。</p>
<p>$$<br>周转时间 &#x3D; {作业完成时间} - {作业提交时间}<br>$$</p>
<p>$$<br>平均周转时间 &#x3D; \frac{各作业周转时间和}{作业数}<br>$$</p>
<p>两个作业虽然周转时间相同，但是实际运行时间可能不同，导致的感受也不同，所以又提出了带权周转时间：</p>
<p>$$<br>带权周转时间 &#x3D; \frac{作业周转时间}{作业实际运行时间} &#x3D; \frac{作业完成时间 - 作业提交时间}{作业实际运行时间}<br>$$</p>
<p>带权周转时间必然 &gt;&#x3D; 1，带权周转时间和周转时间都是越小越好。</p>
<p>然后还有一个平均带权周转时间，就是各个作业带权周转时间的和除以作业数，不说了。</p>
<h2 id="8-4-等待时间"><a href="#8-4-等待时间" class="headerlink" title="8.4 等待时间"></a>8.4 等待时间</h2><p>指的是进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p>
<p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待IO完成的期间其实进程也是被服务的，所以不计入等待时间（也就是说打印机工作的时间不算）。</p>
<p>对于作业来说，不仅要考虑建立进程后等待的时间，还要加上作业在外存后备队列中等待的时间。</p>
<p>一个作业总共需要被CPU服务多久，被IO设备服务多久一般是确定不变的，因此调度算法其实只会影响作业&#x2F;进程的等待时间。</p>
<p>$$<br>等待时间 &#x3D; 周转时间 - 运行时间（如果使用了IO设备，还需要减去IO设备使用时间）<br>$$</p>
<h2 id="8-5-响应时间"><a href="#8-5-响应时间" class="headerlink" title="8.5 响应时间"></a>8.5 响应时间</h2><p>指的就是用户提交请求到首次产生响应所需要的时间。</p>
<h2 id="8-6-总结"><a href="#8-6-总结" class="headerlink" title="8.6 总结"></a>8.6 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618145437.png" alt="image.png"></p>
<h1 id="9-调度算法"><a href="#9-调度算法" class="headerlink" title="9. 调度算法"></a>9. 调度算法</h1><h2 id="9-1-先来先服务"><a href="#9-1-先来先服务" class="headerlink" title="9.1 先来先服务"></a>9.1 先来先服务</h2><p>很好理解，就是越先来的进程越先被服务。一般也就是按照时间顺序依次往后执行。核心思想就是“公平”，且属于非抢占式调度算法，除非任务主动放弃或者阻塞，不会强制让任务下线。用于作业调度时，考虑哪个作业先到达后备队列；用于进程调度时，考虑哪个进程先到达就绪队列。</p>
<p>优点：公平、算法实现简单</p>
<p>缺点：排在长作业后面的短作业需要等待很长时间，从指标来看就是带权周转时间非常长，这个体验就是非常不好了。</p>
<p>这种算法不会导致饥饿，所以任务都会有序的被服务。</p>
<h2 id="9-2-短作业优先"><a href="#9-2-短作业优先" class="headerlink" title="9.2 短作业优先"></a>9.2 短作业优先</h2><p>追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间。算法规则就是：最短的作业&#x2F;进程优先得到服务（最短指的是要求服务时间最短）。既可以用于作业调度，也可以用在进程调度。用于进程调度时称为“短进程优先（SPF）算法”。</p>
<p>优点就是“最短的”平均等待时间、平均周转时间。</p>
<p>缺点：不太公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业&#x2F;进程的运行时间是由用户提供的，并已定真实，不一定能做到真正的短作业优先</p>
<p>然而短作业优先又分两种：抢占式和非抢占式：</p>
<h3 id="9-2-1-非抢占式短作业优先"><a href="#9-2-1-非抢占式短作业优先" class="headerlink" title="9.2.1 非抢占式短作业优先"></a>9.2.1 非抢占式短作业优先</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618151318.png" alt="image.png"></p>
<h3 id="9-2-2-抢占式短作业优先"><a href="#9-2-2-抢占式短作业优先" class="headerlink" title="9.2.2 抢占式短作业优先"></a>9.2.2 抢占式短作业优先</h3><p>这种算法也叫“最短剩余时间优先算法（SRNT）”，每次一个任务来了以后，他就会根据任务的剩余时间来重新调度。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618151344.png"></p>
<h3 id="9-2-3-细节"><a href="#9-2-3-细节" class="headerlink" title="9.2.3 细节"></a>9.2.3 细节</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618151642.png" alt="image.png"></p>
<h2 id="9-3-高响应比优先"><a href="#9-3-高响应比优先" class="headerlink" title="9.3 高响应比优先"></a>9.3 高响应比优先</h2><p>是一种非抢占式的算法，就是每次要重新调度的时候，我都看看谁等的时间长了而且活比较简单，优先让这类作业先上处理机。因此也不会饥饿。<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618152410.png" alt="image.png"></p>
<h2 id="9-4-总结"><a href="#9-4-总结" class="headerlink" title="9.4 总结"></a>9.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618152556.png" alt="image.png"></p>
<h2 id="9-5-时间片轮转"><a href="#9-5-时间片轮转" class="headerlink" title="9.5 时间片轮转"></a>9.5 时间片轮转</h2><p>比较常用的算法，只用于进程调度，伴随着分时操作系统引入的一种算法。所以这种算法更注重响应时间。</p>
<p>如果时间片设置太大，使得每个进程都可以在一个时间片内完成，则算法就会退化成先来先服务算法，并且会增大进程响应时间。另一方面，如果进程切换过于频繁，就会导致系统会花费大量的时间来处理进程切换，从而导致进程执行的时间比例减少。一般来说，进程开销占比不少过1%。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618153559.png" alt="image.png"></p>
<p>这里说一下算法规则：任务一定是按照顺序进入就绪队列中，所以调度的时候也是按顺序进行调度。如果时间片内任务没做完，则重新放回队列末尾。如果同一时间又有新任务加入，时间片也用完了旧任务要回队，我们默认旧任务排在新任务后面。</p>
<h2 id="9-6-优先级调度算法"><a href="#9-6-优先级调度算法" class="headerlink" title="9.6 优先级调度算法"></a>9.6 优先级调度算法</h2><p>就是说每个任务来的时候都会有个优先数代表着优先级（优先级越高可不一定优先数越大，分情况讨论），每次调度都会选择最高优先级的任务先上处理机。</p>
<p>同样有抢占式的和非抢占式的，非抢占式的好理解，抢占式的就是每次就绪队列发生变化都要重新调度一下，看看有没有新的任务优先级更高，就优先执行哪个。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618154812.png" alt="image.png"></p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618154718.png" alt="image.png"></p>
<h2 id="9-7-多级反馈队列调度算法"><a href="#9-7-多级反馈队列调度算法" class="headerlink" title="9.7 多级反馈队列调度算法"></a>9.7 多级反馈队列调度算法</h2><p>这个算法可就优点复杂了。<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618155507.png" alt="image.png"><br>看图看不懂，来上个例子：</p>
<p>现在有三个任务：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>到达时间</th>
<th>运行时间</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>0</td>
<td>8</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>P3</td>
<td>5</td>
<td>1</td>
</tr>
</tbody></table>
<p>多级反馈队列会提供多个队列，每个队列有自己的时间片，优先级越高的队列对应的时间片越低：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618160550.png" alt="image.png"></p>
<p>当P1进入，因为是先到达，所以首先进入一级队列，对应的时间片是1，所以执行1个时间，执行完以后，由于时间片没有被打断切P1没有完成，P1就会进入第二级队列，同时，P2来了，就会先进入一级队列。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618160746.png" alt="image.png"></p>
<p>然后操作系统会优先执行优先级高的队列，所以就会优先执行一级队列中的P2，同样是执行一个时间，然后和P1一样进入二级队列。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618160913.png" alt="image.png"></p>
<p>然后二级队列就会按照顺序执行P1，P1同样没有被打断而且没有执行完，那么P1就会进入三级队列，之后继续执行P2任务。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618161034.png" alt="image.png"></p>
<p>P2执行了一个时间时，P3来了，这个时候就会重新调度，相当于P2执行被打断，如果执行被打断，就不会流向下一级队列，而是会重新返回当前队列等待执行。同时P3进入一级队列。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618161214.png" alt="image.png"></p>
<p>操作系统又会优先执行高优先级队列，所以优先执行P3，P3执行完以后执行P2，P2执行了二个时间后执行完成，不会进入三级队列。最后执行P1，因为是最低级队列，即便是时间片内没有执行完，也会重新回到当前队列重新执行。</p>
<h2 id="9-8-总结"><a href="#9-8-总结" class="headerlink" title="9.8 总结"></a>9.8 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618155620.png" alt="image.png"></p>
<h2 id="9-9-多级队列调度"><a href="#9-9-多级队列调度" class="headerlink" title="9.9 多级队列调度"></a>9.9 多级队列调度</h2><p>这个他们就是提了一句，感觉也不是很难。就是说设计好几个任务队列，每个任务队列都有自己的功能划分，所以队列自己就有优先级。各个队列也可以分别设置不同的调度策略。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618163040.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>06.同步与互斥</title>
    <url>/2023/06/30/06-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/</url>
    <content><![CDATA[<p>同步与互斥</p>
<span id="more"></span>

<h1 id="1-进程同步"><a href="#1-进程同步" class="headerlink" title="1. 进程同步"></a>1. 进程同步</h1><p>同步说的就是如何解决进程异步的问题，众所周知操作系统的各个进程异步执行，谁先谁后不可预知，但是有些时候我们又需要控制进程的执行顺序，比如在管道通信中，写肯定得发生在读之前，这就是进程同步要解决的问题。</p>
<h1 id="2-进程互斥"><a href="#2-进程互斥" class="headerlink" title="2. 进程互斥"></a>2. 进程互斥</h1><p>在一个时间段内只允许一个进程使用的资源我们称之为临界资源，比如打印机这种资源，一个进程用了另一个进程就不能用了。</p>
<p>对于临界资源的访问必须互斥的进行。互斥，或者称为间接制约关系。进程互斥指的就是访问临界资源时，另一个想要访问该临界资源的进程必须等待。</p>
<p>对临界资源的访问，可以在逻辑上分为下面四个部分：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619155340.png" alt="image.png"></p>
<p>如果一个进程暂时不能进入临界区，那么该进程是否应该一直占着处理机？这个进程有没有可能一直进不了临界区？这都是互斥要考虑的东西。需要遵循下面四个原则：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619155551.png" alt="image.png"></p>
<p>总结：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619155612.png" alt="image.png"></p>
<h1 id="3-互斥的软件实现"><a href="#3-互斥的软件实现" class="headerlink" title="3. 互斥的软件实现"></a>3. 互斥的软件实现</h1><p>如果两个进程使用打印机，但是不上锁，不涉及到互斥，会出现的问题就是，进程A使用打印机打印了一半时间片用完，然后CPU就去处理进程B，进程B也会获得打印机资源开始打印，然后A和B打印的东西就混在一起了。</p>
<p>为了解决这个问题，可以在代码层面实现互斥。</p>
<h2 id="3-1-单标志法"><a href="#3-1-单标志法" class="headerlink" title="3.1 单标志法"></a>3.1 单标志法</h2><p>核心思想：代码会规定现在只能哪个进程来访问临界区（注意：是访问临界区代码，执行临界区代码的时候肯定已经拿到了临界资源的锁），指定的进程访问完临界资源后，会把临界区的访问权限给另一个进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前只有0进程可以执行临界区</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1进程</span></span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P2 进程</span></span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>

<p>如果进程P2先上处理机，就会卡死在while循环，因为发现turn 确实不等于1，说明自己不能访问临界资源，等到P2的时间片用完了，P1执行，P1就不会卡while，而是会往下执行，最后将 turn 改为1，供P2执行。</p>
<p>这个算法体现了一个谦让的思路，两个进程其中一个只要执行完了临界区，就会把临界区的访问权谦让出去。但是如果P2谦让给了P1，P1因为某种原因迟迟不执行临界区，那么P2也就没发使用临界区，这就<strong>违背了空闲让进</strong>的原则。</p>
<h2 id="3-2-双标志先检查"><a href="#3-2-双标志先检查" class="headerlink" title="3.2 双标志先检查"></a>3.2 双标志先检查</h2><p>核心思想：设置一个布尔型数组 flag[]，数组中各个元素用来表示<strong>各个进程想要进入临界区的意愿</strong>，比如 <code>flag[0] = true</code> 就表示0号进程想要访问临界区。那么每个进程访问临界区之前都要先检查当前其他进程有没有想要进入临界区的意思，如果没有，把自己的 flag 设置为true，然后开始访问临界区。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619161255.png" alt="image.png"></p>
<p>4 和 8 就是退出区。</p>
<p>但是有个问题，就是这种算法的进入区代码分两步：检查和上锁，是非原子性的，并发情况下很可能出现错误，导致两个进程全都进入了临界区。违反了忙则等待。</p>
<h2 id="3-3-双标志后检查"><a href="#3-3-双标志后检查" class="headerlink" title="3.3 双标志后检查"></a>3.3 双标志后检查</h2><p>这个和前面的几乎一样，只是进入区的代码有调整，之前是先检查后上锁，结果会出现锁失效，那么这里就让他先上锁后检查：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619161837.png" alt="image.png"></p>
<p>结果这会更完蛋，每个进程先上锁，然后检查，如果检查发现不能进入临界区他也不会释放锁，这就会导致死锁了。违背了 “空闲让进”和“有限等待”，会产生饥饿。</p>
<h2 id="3-4-Peterson-算法"><a href="#3-4-Peterson-算法" class="headerlink" title="3.4 Peterson 算法"></a>3.4 Peterson 算法</h2><p>这种算法是单标志法和双标志法的结合。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619162402.png" alt="image.png"></p>
<p>就是说一个线程想要进入临界区首先要加锁，加完锁以后还要客气一下执行谦让动作，表明可以让对方进程优先进入。如果这个时候因为并发的原因另一个进程也加了锁，并且也谦让了，相当于该进程的临界区使用权就被让回来了，就可以正常进入临界区。</p>
<p>可以这么理解，谁最后谦让了，谁就会失去行动的优先权。对方进程就会进入临界区。</p>
<p>算法的前三句是进入区。遵循了前三个原则，但是没有遵循<strong>让权等待</strong>。也就是进程会不停的检查自己有没有进入临界区的资格，会占用CPU。</p>
<h2 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619163002.png" alt="image.png"></p>
<h1 id="4-互斥的硬件实现"><a href="#4-互斥的硬件实现" class="headerlink" title="4. 互斥的硬件实现"></a>4. 互斥的硬件实现</h1><h2 id="4-1-中断屏蔽方法"><a href="#4-1-中断屏蔽方法" class="headerlink" title="4.1 中断屏蔽方法"></a>4.1 中断屏蔽方法</h2><p>这个就是使用“关&#x2F;开中断指令”实现，之前说过，执行了关中断指令，后面的指令就不会执行例行检查，所以就一定不会发生进程切换，可以保证原子性。</p>
<p>可以咋办？先执行关中断指令，然后访问临界区，最后执行开中断指令，这样就不会被打断。</p>
<p>优点：简单，高效。</p>
<p>缺点：不适合多核处理机；只适合操作系统内核进程，不适合用户进程。</p>
<h2 id="4-2-TestAndSet指令"><a href="#4-2-TestAndSet指令" class="headerlink" title="4.2 TestAndSet指令"></a>4.2 TestAndSet指令</h2><p>简称TS指令，也叫 TestAndSetLock，或者TSL指令。该指令用硬件实现，执行的过程不允许被中断，只能一气呵成。用C语言表达的话就是：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619163913.png" alt="image.png"></p>
<p>TSL 指令就是说给lock上锁（不管锁原本啥样），同时返回原来的锁状态。当一个进程要访问一个加了锁的资源时，执行TSL指令就会得到true，就不能进入临界区。当另一个进程释放了锁，让lock&#x3D;false时，再执行TSL指令就会得到false，同时自己也会给它上锁。</p>
<p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境。</p>
<p>缺点：不满足让权等待，进程会不停的检查锁的状态，占用CPU。</p>
<h2 id="4-3-Swap-指令"><a href="#4-3-Swap-指令" class="headerlink" title="4.3 Swap 指令"></a>4.3 Swap 指令</h2><p>也叫Exchange指令，其实就是交换，也是由硬件实现，而且也是原子性的指令。思想就是：通过这个原子性的指令，将锁的状态给它换出来，然后检查，如果发现换出来个false，说明锁被释放，自己就可以进入临界区。同时也会将true给换进去，代表加锁。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619164705.png" alt="image.png"></p>
<p>当条件允许，也就是lock为false时，old为true，交换后old为false，lock为true，就相当于自己进程持有了锁。</p>
<h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619164818.png" alt="image.png"></p>
<h1 id="5-互斥锁"><a href="#5-互斥锁" class="headerlink" title="5. 互斥锁"></a>5. 互斥锁</h1><p>这个好像不是个重点，截个图完事儿：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619165144.png" alt="image.png"></p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619165217.png" alt="image.png"></p>
<h1 id="6-信号量机制"><a href="#6-信号量机制" class="headerlink" title="6. 信号量机制"></a>6. 信号量机制</h1><p>之前的方法里面，比如双标志先检查法，进入区的检查和上锁两步不能一气呵成，就导致两个进程可能会同时进入。而且，所有的解决方案都无法实现让权等待。</p>
<p>为了解决这几个问题，就提出了信号量机制。</p>
<p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而可以很方便的实现了进程互斥、进程同步。</p>
<p>信号量其实就是一个变量（可以是整数，也可以是很复杂的记录行变量），可以<font color='red'>用一个信号量来表示系统中某种资源的数量</font>，比如：系统中只有一台打印机，就可以给打印机设置初始值为1的信号量。</p>
<p>操作系统提供了一对原语：wait(S)和signal(S)，可以类比成两个函数，信号量S就是传入的一个参数。</p>
<p>wait和signal操作常被简称为 PV操作，因此也经常把 wait(S) 和 signal(S) 写作P(S) 和 V(S)。</p>
<h2 id="6-1-整型信号量"><a href="#6-1-整型信号量" class="headerlink" title="6.1 整型信号量"></a>6.1 整型信号量</h2><p>用一个整数型变量作为信号量，用来表示系统中某种资源的数量。普通的整数可以进行运行，而整数型信号量只能做三个操作：初始化、P操作、V操作。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619170359.png" alt="image.png"></p>
<p>我们会发现它其实就是先检查后上锁，但是原子性的，所以更安全。但是这种仍旧是自旋锁，不满足“让权等待”，会发生忙等。</p>
<p>这里有个问题，就是wait原语里面一直自旋，难道不会一直占用CPU？我们姑且认为不会。</p>
<h2 id="6-2-记录型信号量"><a href="#6-2-记录型信号量" class="headerlink" title="6.2 记录型信号量"></a>6.2 记录型信号量</h2><p>为了解决忙等的问题，人们又提出了“记录行信号量”，用记录型数据结构表示信号量。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619170747.png" alt="image.png"></p>
<p>就是说如果发现资源不够不能上锁，就会主动阻塞当前进程，将其挂在信号量的阻塞队列上。等其他进程调用V操作释放资源的时候会主动去唤醒之前阻塞的进程，就不会发生忙等，符合“让权等待”。很有monitor那味。</p>
<h2 id="6-3-总结"><a href="#6-3-总结" class="headerlink" title="6.3 总结"></a>6.3 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619172000.png"></p>
<h1 id="7-信号量机制实现互斥、同步、前驱"><a href="#7-信号量机制实现互斥、同步、前驱" class="headerlink" title="7. 信号量机制实现互斥、同步、前驱"></a>7. 信号量机制实现互斥、同步、前驱</h1><h2 id="7-1-进程互斥"><a href="#7-1-进程互斥" class="headerlink" title="7.1 进程互斥"></a>7.1 进程互斥</h2><p>这个很简单，初始化一个为1的信号量mutex，每个进程要访问临界区都要执行P（wait）操作，成功进入临界区并执行完以后，需要执行V操作释放mutex。</p>
<p>这个mutex就可以理解成进程临界区的名额只能有一个，P了以后就占用了这个名额。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般默认的都是记录型信号量</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 做题的话就用这种方式定义信号量就行了</span></span><br><span class="line"></span><br><span class="line">P1() &#123;</span><br><span class="line">	P(mutex);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	V(mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2() &#123;</span><br><span class="line">	P(mutex);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	V(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-进程同步"><a href="#7-2-进程同步" class="headerlink" title="7.2 进程同步"></a>7.2 进程同步</h2><p>我们要控制几个进程的执行顺序，比如：P1 要执行code 1 2 3 ，P2要执行 code 4 5 6，我们要求P2必须在P1执行完code2之后执行，怎么做？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">P1() &#123;</span><br><span class="line">	code <span class="number">1</span>;</span><br><span class="line">	code <span class="number">2</span>;</span><br><span class="line">	V(s);</span><br><span class="line">	code <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2() &#123;</span><br><span class="line">	V(s);</span><br><span class="line">	code <span class="number">4</span>;</span><br><span class="line">	code <span class="number">5</span>;</span><br><span class="line">	code <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里千万注意，信号量要初始化为0，要是初始化为1的话，P2执行 value–，然后发现 value &#x3D;&#x3D; 0 满足 value &gt;&#x3D; 0，P2直接就进去了。</p>
<p>简单说，前操作之后执行V，后操作之前执行P。</p>
<h2 id="7-3-前驱关系"><a href="#7-3-前驱关系" class="headerlink" title="7.3 前驱关系"></a>7.3 前驱关系</h2><p>就是更为复杂的前驱关系，多个进程需要协同前进。其实非常的简单，每一种前驱关系都设定一个信号量，然后两两成对的前V后P即可。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619173559.png" alt="image.png"></p>
<h2 id="7-4-总结"><a href="#7-4-总结" class="headerlink" title="7.4 总结"></a>7.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619173733.png" alt="image.png"></p>
<h1 id="8-相关问题"><a href="#8-相关问题" class="headerlink" title="8. 相关问题"></a>8. 相关问题</h1><h2 id="8-1-生产者-消费者"><a href="#8-1-生产者-消费者" class="headerlink" title="8.1 生产者-消费者"></a>8.1 生产者-消费者</h2><p>这个问题很经典啊，就是说有一个缓冲区，生产者往缓冲区写数据，消费者从缓冲区读数据。如果缓冲区满了，生产者阻塞，如果缓冲区空了，消费者阻塞。同时，生产者和消费者不为一，所以各个角色都要互斥的访问缓冲区。</p>
<p>分析：这就是我们之前说的进程同步，缓冲区没空，然后消费者拿数据；反过来，缓冲区没满，则生产者放数据。这就是两个信号量，生产者生产数据，则缓冲区没空，生产者V，消费者P；消费者获取数据，证明缓冲区没满，消费者V，生产者P。这里的没空和没满，就是两个信号量，两个信号量full和empty分别记录缓冲区中数据的个数和缓冲区空位个数。</p>
<p>进程内如何判空？信号量同时记录着资源的剩余数量，所以释放锁的时候给信号量+1，就可以代表缓冲区内的数据个数，同理，获取锁的时候信号量-1，如果&lt;0，证明缓冲区里面没有数据了，阻塞。</p>
<p>不要考虑什么时候阻塞，而是考虑不阻塞时，先干什么，后干什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line">semaphore empty = n;</span><br><span class="line"></span><br><span class="line">Producer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(empty);</span><br><span class="line"></span><br><span class="line">		P(mutex);</span><br><span class="line">		<span class="comment">// 生产数据</span></span><br><span class="line">		V(mutex);</span><br><span class="line"></span><br><span class="line">		V(full);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(full);</span><br><span class="line"></span><br><span class="line">		P(mutex);</span><br><span class="line">		<span class="comment">// 获取数据</span></span><br><span class="line">		V(mutex);</span><br><span class="line"></span><br><span class="line">		V(empty);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619195303.png" alt="image.png"></p>
<h2 id="8-2-多生产-多消费"><a href="#8-2-多生产-多消费" class="headerlink" title="8.2 多生产-多消费"></a>8.2 多生产-多消费</h2><p>多个生产者生产不同类型的消息，多个消费者对应的消费不同类型的消息，举个例子：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619225251.png" alt="image.png"></p>
<p>分析：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619225436.png" alt="image.png"></p>
<p>实现：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619225644.png" alt="image.png"></p>
<p>这里有个点：即便是不设置 mutex互斥信号量，依然可以正常运作。因为 apple orange 和 plate 三个同步信号量在同一时间只能有一个是1，所以各个进程一上来的P操作就可以防止其他线程进入临界区。如果plate的值是2，也就是盘子可以放两个水果的话，dad和mom可就有可能同时操作盘子了。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619230248.png" alt="image.png"></p>
<h2 id="8-3-吸烟者问题"><a href="#8-3-吸烟者问题" class="headerlink" title="8.3 吸烟者问题"></a>8.3 吸烟者问题</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619230421.png" alt="image.png"></p>
<p>将桌子看作一个缓冲区，容量为1，原材料两两为一个组合，同时要注意轮流这个事儿，他给的解决办法是设置一个i让他%更新。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619231036.png" alt="image.png"></p>
<h2 id="8-4-读者-写者问题"><a href="#8-4-读者-写者问题" class="headerlink" title="8.4 读者-写者问题"></a>8.4 读者-写者问题</h2><p>这个玩意是真的难，说一下：有一个共享文件，写进程（可以是多个）往文件里写，读进程（可以是多个）从文件里读，如何实现同步互斥。</p>
<p>说一下要求：</p>
<ul>
<li>读进程之间不需要互斥，多个读进程可以同时访问文件</li>
<li>写进程之间需要互斥，否则可能会导致覆盖</li>
<li>写进程写完之前不允许读进程读，还得让所有已有的读写进程退出。</li>
</ul>
<h3 id="8-4-1-简单实现"><a href="#8-4-1-简单实现" class="headerlink" title="8.4.1 简单实现"></a>8.4.1 简单实现</h3><p>最简单的就是弄个文件的信号量进行同步：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore file = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">writer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(file);</span><br><span class="line">		<span class="comment">// write...</span></span><br><span class="line">		V(file);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(file);</span><br><span class="line">		<span class="comment">// read...</span></span><br><span class="line">		V(file);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样无法让读进程同时进入，读进程之间也会阻塞，咋办？可以这样，让第一个进来的reader上锁，后来的reader可以跳过上锁，让最后一个reader释放锁：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">0</span>) P(file);</span><br><span class="line">		count++;</span><br><span class="line">		<span class="comment">// read...</span></span><br><span class="line">		count--;</span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">0</span>) V(file);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这又有个问题：代码的进入区有三条语句，判断，上锁，count自增，不保证原子性，就有可能发生冲突，咋办？那就让他保证原子性，给这三条语句上互斥锁：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(mutex);</span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">0</span>) P(file);</span><br><span class="line">		count++;</span><br><span class="line">		V(mutex);</span><br><span class="line">		<span class="comment">// read...</span></span><br><span class="line">		P(mutex);</span><br><span class="line">		count--;</span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">0</span>) V(file);</span><br><span class="line">		V(mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-2-写优先"><a href="#8-4-2-写优先" class="headerlink" title="8.4.2 写优先"></a>8.4.2 写优先</h3><p>上面这种又会出现一个问题，如果有源源不断的读进程，那么file就一直不会被释放，锁进程就会饥饿，如何解决饥饿的问题？</p>
<p>再弄一个信号量，实现“写优先”（并不是真正的写优先，只是暂时能解决问题）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore w = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">writer() &#123; <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	P(w);  <span class="comment">// 获取w锁，表明现在有writer要写，新来的reader先等等。   </span></span><br><span class="line">	P(file);</span><br><span class="line">	<span class="comment">// write...</span></span><br><span class="line">	V(file);</span><br><span class="line">	V(w); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(w); <span class="comment">// 读之前看看有没有writer正在写或者想要写</span></span><br><span class="line">		mutex&#123; <span class="comment">// 只是省事儿这么写，考试别这么写</span></span><br><span class="line">			<span class="keyword">if</span>(count == <span class="number">0</span>) P(file);</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		V(w);  <span class="comment">// 在read之前释放w，保证reader进程并发</span></span><br><span class="line">		<span class="comment">// read...</span></span><br><span class="line">		mutex&#123;</span><br><span class="line">			count--;</span><br><span class="line">			<span class="keyword">if</span>(count == <span class="number">0</span>) V(file);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这回就变成啥了？首先如果是两个reader进来，reader1获取了w，然后reader2阻塞，reader1在读之前释放了w，然后reader2就会唤醒，可以同时read。</p>
<p>如果是一个writer多个reader的话，reader1经过了前面正在进行read，这个时候writer进来，持有了w锁，然后准备写（但是不能写，因为reader1还持有file锁），然后reader2也来了，尝试获取w失败，就会阻塞，count就不会自增，相当于强制reader读完以后释放file锁，然后writer写，写完了唤醒reader2去读。</p>
<p>这种算法并不能真正实现写优先，而是相对公平的先来先服务原则，这种算法也叫读写公平法。</p>
<h2 id="8-5-哲学家进餐"><a href="#8-5-哲学家进餐" class="headerlink" title="8.5 哲学家进餐"></a>8.5 哲学家进餐</h2><h1 id="9-管程"><a href="#9-管程" class="headerlink" title="9. 管程"></a>9. 管程</h1><p> 这个东西就是一种比较牛逼的数据结构，它里面提供了进程安全（线程安全）的一些方法，比如insert方法，往队列中插入元素，remove方法，从队列中拿出元素等，完了里面还提供了 condition 条件变量，简单说就是阻塞队列。<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620104904.png" alt="image.png"></p>
<p>感觉这个管程也不是重点，提一句得了。<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620104938.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>08.内存管理</title>
    <url>/2023/06/30/08-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>内存管理</p>
<span id="more"></span>

<h1 id="1-内存基础知识"><a href="#1-内存基础知识" class="headerlink" title="1. 内存基础知识"></a>1. 内存基础知识</h1><h2 id="1-1-什么是内存"><a href="#1-1-什么是内存" class="headerlink" title="1.1 什么是内存"></a>1.1 什么是内存</h2><p>内存可存放数据。程序执行钱需要先放到内存中才能被 CPU 处理，以此缓和 CPU 和硬盘之间的速度矛盾。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620214937.png" alt="image.png"><br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620215209.png" alt="image.png"></p>
<h2 id="1-2-进程运行的基本原理"><a href="#1-2-进程运行的基本原理" class="headerlink" title="1.2 进程运行的基本原理"></a>1.2 进程运行的基本原理</h2><h3 id="1-2-1-指令工作原理"><a href="#1-2-1-指令工作原理" class="headerlink" title="1.2.1 指令工作原理"></a>1.2.1 指令工作原理</h3><p>假设我们现在要执行一条语句：<code>x = x + 1</code>，这条语句可能就会被编译成下面三条CPU指令：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621095105.png" alt="image.png"></p>
<ul>
<li>指令一：数据传送，将内存中 01001111 地址（X变量的位置，值为10）的数据，传送到 00000011 寄存器</li>
<li>指令二：加速指令，将寄存器 00000011 中的数据 加上 00000001</li>
<li>指令三：数据传送，将寄存器 00000011 中的数据，传送给内存 01001111 地址（将 X 的值更新到内存）</li>
</ul>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621095349.png" alt="image.png"></p>
<p>这里我们假设地址从0开始，那么指令中的所有地址都是真实的“物理地址”。那如果指令不是从 0 开始的，如何应对？</p>
<h3 id="1-2-2-逻辑地址-VS-物理地址"><a href="#1-2-2-逻辑地址-VS-物理地址" class="headerlink" title="1.2.2 逻辑地址 VS 物理地址"></a>1.2.2 逻辑地址 VS 物理地址</h3><p>为了简化理解，我们默认操作系统会给进程分配一片连续的内存空间。如果程序所在的物理地址起始位置不是0，那么指令中的地址如何修改？</p>
<p>可以这么着，指令中的地址不是真实的物理地址，而是一种相对地址，相对于当前进程在物理地址中的起始位置的一种偏移量。比如：指令要求从内存的 79 地址处拿到x，这个79是进程的起始地址往后数 79 个，而非真正的物理79。如果进程起始地址为100，那么x的位置就是 100 + 79。</p>
<h3 id="1-2-3-如何实现地址转换"><a href="#1-2-3-如何实现地址转换" class="headerlink" title="1.2.3 如何实现地址转换"></a>1.2.3 如何实现地址转换</h3><p>计算机中可执行文件也叫装入模块，将装入模块装入内存的时候如何将地址进行转换？这就涉及到三种装入方式：</p>
<p><strong>绝对装入</strong></p>
<p>在编译时，可以预知程序会被放入到哪个位置，那么编译器将产生绝对地址的目标代码，装入程序按照装入模块中的地址，将程序和数据装入内存。也就是说编译出来的可执行文件（装入模块）里面地址就已经写死了。</p>
<p>比如，我们已经知道程序会被装入到 100 的位置，那么编译的时候直接把 x 的位置修改成 179 物理地址即可，也就是绝对地址。这种方式只适合单道程序环境，换一台电脑这个可执行文件怕是就没法用了。</p>
<p><strong>可重定位装入</strong></p>
<p>也叫可重定位装入。编译，链接后装入模块的地址都是从0开始，指令地址中的地址都是相对于起始地址而言的逻辑地址。但是在装入模块被装入内存时会进行地址转换，根据装入的实际位置，将指令中的所有地址修改为物理地址。</p>
<p>这样有个要求：作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入作业。且作业一旦装入完成，运行期间作业不能移动，也不能申请新的内存空间。</p>
<p><strong>动态运行时装入</strong></p>
<p>也叫动态运行时装入，装入模块里面的指令是逻辑地址，装入内存后的指令同样是逻辑地址。然后会有一个重定位寄存器，记录着装入模块存放的起始位置，运行时只需要将指令中的逻辑地址和寄存器中的起始地址相加即可获取真实的物理地址。</p>
<h3 id="1-2-4-写程序到程序运行"><a href="#1-2-4-写程序到程序运行" class="headerlink" title="1.2.4 写程序到程序运行"></a>1.2.4 写程序到程序运行</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621101032.png" alt="image.png"></p>
<p>这里说一下：这个目标模块同样也是指令，然后里面的地址全都是逻辑地址，各个模块的逻辑地址相互独立。链接就是将这些目标模块整合起来，变成一个完整的逻辑地址，当然这些地址同时包含着你用到的一些库函数。最后装入我们之前已经说过了。</p>
<p>这里的链接同样有三种模式：</p>
<p><strong>静态链接</strong></p>
<p>和图里的意思一样，在程序运行之前，将各个目标模块已经库函数链接成一个完整的装入模块，以后不再拆开。</p>
<p><strong>装入时动态链接</strong></p>
<p>这种方式并不会一上来就链接，而是在装入内存时，边装入边链接。</p>
<p><strong>运行时动态链接</strong></p>
<p>运行时将逻辑地址转换为物理地址，需要设置重定位寄存器。如果运行时不需要某个目标模块，则不会加载。</p>
<h2 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621101659.png" alt="image.png"></p>
<h1 id="2-内存管理概念"><a href="#2-内存管理概念" class="headerlink" title="2. 内存管理概念"></a>2. 内存管理概念</h1><h2 id="2-1-内存的分配和回收"><a href="#2-1-内存的分配和回收" class="headerlink" title="2.1 内存的分配和回收"></a>2.1 内存的分配和回收</h2><p>操作系统要负责内存空间的分配与回收，操作系统如何记录哪些内存区域已经被分配出去，哪些空闲。进程结束后又如何回收内存空间。一个新进程来了，该将他放到哪片内存上，这都是问题。</p>
<h2 id="2-2-内存空间的扩展"><a href="#2-2-内存空间的扩展" class="headerlink" title="2.2 内存空间的扩展"></a>2.2 内存空间的扩展</h2><p>操作系统需要提供某种技术从逻辑上对内存空间进行扩充。</p>
<h2 id="2-3-地址转换"><a href="#2-3-地址转换" class="headerlink" title="2.3 地址转换"></a>2.3 地址转换</h2><p>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。这个我们之前已经说过了，也就是三种装入方式。</p>
<h2 id="2-4-内存保护"><a href="#2-4-内存保护" class="headerlink" title="2.4 内存保护"></a>2.4 内存保护</h2><p>操作系统在内存中有专门的一片空间专门用于保存操作系统的一些数据，如何避免其他进程非法访问，这就是内存保护。</p>
<h3 id="2-4-1-上下限寄存器"><a href="#2-4-1-上下限寄存器" class="headerlink" title="2.4.1 上下限寄存器"></a>2.4.1 上下限寄存器</h3><p>CPU 会提供一对上下限寄存器，分别存放进程的上下限地址。进程的指令要访问地址时，CPU 就会首先检查地址是否越界。</p>
<h3 id="2-4-2-重定位寄存器"><a href="#2-4-2-重定位寄存器" class="headerlink" title="2.4.2 重定位寄存器"></a>2.4.2 重定位寄存器</h3><p>和上面这个也很类似，CPU 提供两个寄存器：重定位寄存器（基址寄存器），保存进程的起始物理地址；界地址寄存器（限长寄存器），记录指令中允许的最大偏移地址。执行指令时，首先检查逻辑地址是否在最大偏移地址之内，合法则通过重定位寄存器找到真实的物理地址进行执行。</p>
<h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621102838.png" alt="image.png"></p>
<h1 id="3-覆盖与交换"><a href="#3-覆盖与交换" class="headerlink" title="3. 覆盖与交换"></a>3. 覆盖与交换</h1><h2 id="3-1-覆盖技术"><a href="#3-1-覆盖技术" class="headerlink" title="3.1 覆盖技术"></a>3.1 覆盖技术</h2><p>前朝的计算机内存通常非常的小，所以经常出现内存不够用的情况，如何将一个更大的程序装入内存成功运行？这就提出了覆盖技术。</p>
<p>简单说，内存会给进程提供固定区和覆盖区，固定区存储进程的核心部分，覆盖区存储不可能被同时访问的程序段。一个模块不用了就可以调出内存腾地方。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621103405.png" alt="image.png"></p>
<h2 id="3-2-交换技术"><a href="#3-2-交换技术" class="headerlink" title="3.2 交换技术"></a>3.2 交换技术</h2><p>核心思想和之前说到的中级调度（挂起）很像：内存空间紧张时，系统将内存中某些进程暂时换出内存，把内存中某些已具备运行条件的进程换入内存（进程在内存和磁盘间动态调度）。</p>
<p>再说一句：即便进程被挂起，PCB 也会被记录到内存的挂起队列中，PCB 会记录进程在磁盘中的挂起位置，所以 PCB 一定是常驻内存。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621103801.png" alt="image.png"></p>
<p>之前的七状态模型再拿过来看一眼。</p>
<h3 id="3-2-1-换出位置"><a href="#3-2-1-换出位置" class="headerlink" title="3.2.1 换出位置"></a>3.2.1 换出位置</h3><p>外存的什么位置用来保存被换出的进程？具有交换功能的操作系统中，通常把磁盘空间分为“文件区”和“交换区”。</p>
<p>文件区只负责存文件，主要追求存储空间的利用率，因为文件区空间的管理<font color = 'red'>采用离散分配方式</font>。而交换区主要追求的就是交换速度，所以采用<font color = 'red'>连续分配方式</font>，总之就是交换区比文件区更快。</p>
<h3 id="3-2-2-什么时候交换"><a href="#3-2-2-什么时候交换" class="headerlink" title="3.2.2 什么时候交换"></a>3.2.2 什么时候交换</h3><p>许多进程运行而且内存吃紧的时候进行交换，当系统负荷降低就暂停交换。比如：进程运行时进场发生缺页，则内存吃紧，就可以换出一些进程。如果缺页率显著下降，则暂停换出</p>
<h3 id="3-2-3-换出哪些进程"><a href="#3-2-3-换出哪些进程" class="headerlink" title="3.2.3 换出哪些进程"></a>3.2.3 换出哪些进程</h3><p>优先换出阻塞进程；优先级低的进程；为了防止优先级低的继承在被调入内存后很快又被换出，有些系统还会考虑进程在内存的驻留时间。</p>
<h2 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621104505.png" alt="image.png"></p>
<h1 id="4-连续分配管理方式"><a href="#4-连续分配管理方式" class="headerlink" title="4. 连续分配管理方式"></a>4. 连续分配管理方式</h1><p>第四和第五章开始说一下内存管理的重点：内存分配与回收。分为两类：连续分配管理和非连续分配管理。</p>
<p>连续分配指的就是：系统为用户进程分配的必须是一个连续的内存空间。其中又分为三种方式。</p>
<h2 id="4-1-单一连续分配"><a href="#4-1-单一连续分配" class="headerlink" title="4.1 单一连续分配"></a>4.1 单一连续分配</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621105053.png" alt="image.png"></p>
<h2 id="4-2-固定分区分配"><a href="#4-2-固定分区分配" class="headerlink" title="4.2 固定分区分配"></a>4.2 固定分区分配</h2><p>就是升级版的单一连续分配，将整个用户区分为多个小分区，每个小分区只能放入一个进程，或者说一道作业，这就是最早的最简单的一种可以运行多道程序的内存管理方式。内存的分区数被预先划分。</p>
<p>在某些特定场景下，分区的大小全都相等，比如炼钢厂，每个钢炉的控制程序都一样，就可以将内存分为多个大小相等的区放入控制程序。</p>
<p>分区的大小也可以不相等，增加了灵活性。根据常在系统中运行的作业大小情况来划分。可以划分多个小分区，适量中分区，少量大分区。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621105655.png" alt="image.png"></p>
<h2 id="4-3-动态分区分配"><a href="#4-3-动态分区分配" class="headerlink" title="4.3 动态分区分配"></a>4.3 动态分区分配</h2><p>也叫可变分区分配，这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态建立分区，让分区的大小正好适合进程的需要，因此系统分区的大小和数目可变。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621110137.png" alt="image.png"><br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621110210.png" alt="image.png"></p>
<p>最后一个问题：如何分配和回收。</p>
<p>这个其实很简单，就是要更新空闲分区表或者空闲分区链。分配的时候看有没有填满某个空闲分区，以此决定是更新该分区的参数还是直接删除该空闲分区。回收的时候，看前后是否有相邻的空闲分区，以此来决定是合并空闲分区还是添加空闲分区。如果是要增加一个空闲分区，这个空闲分区排在哪个位置由动态分区分配算法来决定。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621110917.png" alt="image.png"></p>
<p>紧凑技术就是把内存中的各个进程往紧拼一拼，将外部碎片整理起来。</p>
<p>说一下第二个问题：</p>
<ul>
<li>肯定是要用动态运行时装入方式，那么肯定要用到重定位寄存器</li>
<li>紧凑之后，肯定要修改进程的起始地址，这个地址原本是存在重定位寄存器中，但是在进程调度的时候之前说过，会将各种寄存器保存到 PCB 中。所以这个时候进程的起始地址肯定是在 PCB 里面，我们只需要修改 PCB 中的起始地址即可。</li>
</ul>
<h2 id="4-5-分配方式总结"><a href="#4-5-分配方式总结" class="headerlink" title="4.5 分配方式总结"></a>4.5 分配方式总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621111411.png" alt="image.png"></p>
<h2 id="4-6-动态分区分配算法"><a href="#4-6-动态分区分配算法" class="headerlink" title="4.6 动态分区分配算法"></a>4.6 动态分区分配算法</h2><p>这个东西比较多，所以单独放一起。上面说过了动态分区分配策略，里面有一个空闲分区表，现在一个新的进程来了，该把他放在哪个空闲分区？这就是分配算法要解决的问题。</p>
<h3 id="4-2-1-首次适应算法"><a href="#4-2-1-首次适应算法" class="headerlink" title="4.2.1 首次适应算法"></a>4.2.1 首次适应算法</h3><p>这个很简单，空闲表或者空闲链会根据地址从低到高排列，一个新的进程来了以后，会从头开始，依次寻找满足条件的空闲分区，一旦找到直接分配。分配完成以后修改空闲分区结构。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623111452.png" alt="image.png"></p>
<p>看图可知，空闲表和空闲链就是按照内存从上到下维护空闲空间。</p>
<h3 id="4-2-2-最佳适应算法"><a href="#4-2-2-最佳适应算法" class="headerlink" title="4.2.2 最佳适应算法"></a>4.2.2 最佳适应算法</h3><p>因为动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片空间。所以为了保证“大进程”来了以后有足够的空间分配，所以该算法会尽可能优先使用小空闲分区。</p>
<p>空闲分区表或者链会按照空闲分区的大小从小到大依次排列，当一个进程来了以后同样是从头开始找，第一个满足条件的分区就会是最小分区。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623111907.png" alt="image.png"></p>
<p>缺点：内存中会遗留很多非常小的外部碎片，这些外部碎片很难被利用。</p>
<h3 id="4-2-3-最坏适应算法"><a href="#4-2-3-最坏适应算法" class="headerlink" title="4.2.3 最坏适应算法"></a>4.2.3 最坏适应算法</h3><p>和最佳相反，为了不留下很多难以利用的外部碎片，这种算法会优先分配大的空闲分区。</p>
<p>空闲分区数据结构按照空闲分区大小从大到小排列，进程来了以后也是从头开始找，分配第一个满足要求的分区。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623112131.png" alt="image.png"></p>
<p>这种的缺点就显而易见了：大进程来了以后可能就会导致内存分区不够用。</p>
<h3 id="4-2-4-邻近适应算法"><a href="#4-2-4-邻近适应算法" class="headerlink" title="4.2.4 邻近适应算法"></a>4.2.4 邻近适应算法</h3><p>这种算法是为了解决首次适应算法的一个小问题：首次适应算法优先将低地址空闲分区分配出去，这就会导致低地址部分出现很多小的外部碎片。而下一次分配还会扫描低地址的这些碎片，没有必要。</p>
<p>所以临近适应算法就会从上一次分配的位置开始往下找，而不是从开头。数据结构仍然是按照地址从低到高排序，如果是空闲分区链的话可以设计成一个双向循环链表。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623112644.png" alt="image.png"></p>
<p>现在要分配一个 5M 的进程，就会从链头开始找，发现 6 这个空闲分区可以分配，然后进行分配空间，将链表修改为 4 -&gt; 1 -&gt; 10 -&gt; 4。</p>
<p>下一次一个3M的进程来了，就会从 1 的位置开始找，然后找到了 10 这个空闲分区，进行分配，修改链表为 4 -&gt; 1 -&gt; 7 -&gt; 4。</p>
<p>这样的一个优点就是：空闲分区表不需要重新排列。缺点就是降低了低地址部分小分区的利用率，不利于保存高地址部分的大分区。</p>
<h3 id="4-2-4-总结"><a href="#4-2-4-总结" class="headerlink" title="4.2.4 总结"></a>4.2.4 总结</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623113100.png" alt="image.png"></p>
<h1 id="5-非连续分配管理方式"><a href="#5-非连续分配管理方式" class="headerlink" title="5. 非连续分配管理方式"></a>5. 非连续分配管理方式</h1><h2 id="5-1-基本分页存储管理"><a href="#5-1-基本分页存储管理" class="headerlink" title="5.1 基本分页存储管理"></a>5.1 基本分页存储管理</h2><p>将内存分为一个个大小相等的分区，假设每个分区4kb，每个分区就是一个<font color = 'red'>页框（页帧，内存快，物理块，物理页）</font>。然后每一个页框都会给编上号，这个号就叫<font color='red'>页框号</font>。从 0 开始。</p>
<p>每个进程的逻辑地址空间（也就是存放指令的那一部分）也会被划分为大小相等的一个个分区，每个分区就叫<font color='red'>页（页面）</font>。同理有一个编号：<font color='red'>页号</font>。从 0 开始。</p>
<p>操作系统就会以页框为单位给各个进程分配内存空间。进程的每个页面分别放入一个页框中，进程的页面和内存的页框一一对应。整个进程在内存中对应的页框不一定会连续存储。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623114108.png" alt="image.png"></p>
<p>对应的，操作系统为了知道每个进程的页面在内存中的存放位置，就会给每个进程创建一张 <font color = 'red'>页表</font>。页表通常也会存在 PCB 中。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623114348.png" alt="image.png"></p>
<h3 id="5-1-1-页表占用空间大小"><a href="#5-1-1-页表占用空间大小" class="headerlink" title="5.1.1 页表占用空间大小"></a>5.1.1 页表占用空间大小</h3><p>假设内存 4GB，每个页框4KB，那么：</p>
<p>$$ 4GB &#x3D; 2^2 * 2^{20} &#x3D; 2 ^ {32} $$</p>
<p>$$ 4KB &#x3D; 2 ^ 2 * 2 ^ {10} &#x3D; 2 ^ {12} $$<br>$$ 4GB &#x2F; 4KB &#x3D; 2^{20} $$</p>
<p>所以内存中总共有 2 ^ 20 个内存块，想要编号就需要 24bit 也就是 3Byte 来存储页框号。</p>
<p>页号呢？页号不需要占用空间，因为页号从0开始，类似于数组下标，所以是隐藏的。因此，每个表项占 3B，存储整个表就需要 3 * (n+1) 字节。但是，页表中记录的仅仅是页框号，而不是页框的物理地址，如果想要得到物理地址还需要 页框号 * 页框大小。</p>
<h3 id="5-1-2-如何地址转换"><a href="#5-1-2-如何地址转换" class="headerlink" title="5.1.2 如何地址转换"></a>5.1.2 如何地址转换</h3><p>之前说：进程如果在内存中被连续分配，那么指令中的地址就可以是相对于当前内存的一个偏移量。而在页存储中，如何记录指令中的地址？虽然各个页面是离散存放的，但是页面内部是连续的，所以指令中的逻辑地址A，就需要：</p>
<ul>
<li>确定逻辑地址A对应的页号P</li>
<li>确定P号页面在内存中的其实地址（需要查找页表，也就是页框号 * 页框大小）</li>
<li>确定逻辑地址A的页内偏移量 W</li>
</ul>
<p>然后，逻辑地址A对应的物理地址 &#x3D; P号页面在内存中的起始地址 + 页内偏移量 W。</p>
<p><strong>如何确定逻辑地址对应的页号和页内偏移量？</strong></p>
<p>假设：页面大小 50B。进程的逻辑地址空间是 200B，则逻辑地址110对应的页号和页内偏移量是多少？</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623121352.png" alt="image.png"></p>
<p>如果页面大小是2的整数次方的话，这个事就会变的比较简单。比如，一个页面的大小是 4KB，计算机用 32 个比特位来表示逻辑地址。那么 4KB &#x3D; 2^12 B，需要12个比特位来表示这些存储单元（每个存储单元一个Byte），则：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">0号页面逻辑地址范围 0 - 4095：</span><br><span class="line">00000000000000000000｜000000000000 - 00000000000000000000｜111111111111</span><br><span class="line"></span><br><span class="line">1号页面逻辑地址范围 4096 - 8191：</span><br><span class="line">00000000000000000001｜000000000000 - 00000000000000000001｜111111111111</span><br><span class="line"></span><br><span class="line">2号页面逻辑地址范围 8192 - 12287：</span><br><span class="line">00000000000000000010｜000000000000 - 00000000000000000010｜111111111111</span><br></pre></td></tr></table></figure>
<p>我们就可以发现，多少号逻辑地址，就是把它化成二进制，然后前20位就是他的页号，后12位就是他的页内偏移量。</p>
<p>然后，逻辑地址要转化成物理地址，如果这个计算机的物理地址也适用32个bit来表示的话，那么页框的划分就和上面几乎一样，比如一条逻辑地址在一号页面，偏移地址为000000000011，一号页面分配对应九号页框，9的二进制是 1001，那么这条逻辑地址的物理地址就是：<code>00000000000000001001｜000000000011</code>。也就是页框号的二进制直接拼接页内偏移地址。</p>
<p>如果不满足这种特性的话，就需要去算页框的起始地址。</p>
<p>综上说的，我们可以吧逻辑地址看作这种结构：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623160805.png" alt="image.png"></p>
<h3 id="5-1-3-总结"><a href="#5-1-3-总结" class="headerlink" title="5.1.3 总结"></a>5.1.3 总结</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623160851.png" alt="image.png"></p>
<h2 id="5-2-基本地址变换机构"><a href="#5-2-基本地址变换机构" class="headerlink" title="5.2 基本地址变换机构"></a>5.2 基本地址变换机构</h2><p>这个机构是顺着上一部分说的，上面说到了逻辑地址转化为物理地址可以怎么转，这里就是说具体哪个部件负责干这个事儿。</p>
<p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。通常会在系统中设置一个<strong>页表寄存器（PRT）</strong>，存放页表的内存中的起始地址F和页表长度M。进程未执行时，页表的起始地址和页表长度存放在PCB 中，当进程被调度时，操作系统内核会把他们放到页表寄存器。</p>
<h3 id="5-2-1-地址转换流程"><a href="#5-2-1-地址转换流程" class="headerlink" title="5.2.1 地址转换流程"></a>5.2.1 地址转换流程</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623161519.png" alt="image.png"></p>
<p>文字说一下：</p>
<ol>
<li>首先要计算逻辑地址A在哪一页的哪个偏移量上，这个上一节就说过了。得出页号 P 和偏移量 W。</li>
<li>比较页号 P 和 页表长度 M。M就是说页表总共有几项，如果发现 P &gt;&#x3D; M，则发生越界中断，否则继续执行（如果 P &#x3D;= M 也不行）</li>
<li>根据页表寄存器中的页表起始地址 F 和页号 P 就可以访问到页表：<code>页表项地址 = 页表起始地址 F + 页号 P * 页表项长度（页框号所占字节）</code>，这个地址就可以得到 b。</li>
<li>顺着 b 就可以算出具体的地址：逻辑地址A的物理地址 &#x3D; b * 页面大小 + 页面偏移量。</li>
</ol>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623162703.png" alt="image.png"></p>
<h3 id="5-2-2-页表项长度"><a href="#5-2-2-页表项长度" class="headerlink" title="5.2.2 页表项长度"></a>5.2.2 页表项长度</h3><p>这个之前讲过了，如果内存 4G，一个页是 4K，总共就有2^20 个页框，也就需要20个bit来表示页框号，所以操作系统会给页框号划分 3B。</p>
<p>页表这个结构最后也是会存储在内存的页框中的，一个页框4K，但是一个页表项3B，那么一个页框可以存储1365个页表项， 4096 % 3 &#x3D; 1，也就是说最后这个页框会产生 1B 的内部碎片。</p>
<p>如果我们要计算1365号页表项的话，由于上面产生了1B的碎片，所以1365号页表项的地址就要在计算结果的基础上 + 1。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623163426.png" alt="image.png"></p>
<p>解决办法就是，页表项也就是页框号，我们直接给他划 4B 的空间，让页表能把页框填满。如果题目中要问最小的页表项可以是多少，还按 3B 来。</p>
<h3 id="5-2-3-总结"><a href="#5-2-3-总结" class="headerlink" title="5.2.3 总结"></a>5.2.3 总结</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623163653.png" alt="image.png"></p>
<p>这里提到一个概念：页式管理中地址是一维的，就是说 CPU 想要知道逻辑地址对应的物理地址，只需要知道逻辑地址的值即可。</p>
<h2 id="5-3-快表"><a href="#5-3-快表" class="headerlink" title="5.3 快表"></a>5.3 快表</h2><p>快表就是基本地址变换结构的改进版本，可以让地址转换更快。快表也叫联想寄存器（TLB），是一种访问速度比内存快很多的高速缓存（注意，这可不是内存，而是在 CPU 内部的一种缓存），用来存放最近访问的页表项的副本，可以加快地址变换的速度。因为访问高速缓存比访问内存块，所以叫快表，对应的内存中的页表常叫慢表。</p>
<p>由于快表成本高，存储空间小，所以不能存放完整的页表。</p>
<h3 id="5-3-1-地址变换流程"><a href="#5-3-1-地址变换流程" class="headerlink" title="5.3.1 地址变换流程"></a>5.3.1 地址变换流程</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623164440.png" alt="image.png"></p>
<p>这玩意儿，就是一种缓存，具体流程如下：</p>
<ol>
<li>第一次访问 0-0 地址，除去基本流程外，会去看快表里面有没有页号为0的记录，发现没有，未命中。</li>
<li>按照慢表的思路，去内存里面找到页表，然后发现页号0对应页框600，然后将 0-600 复制到快表中一份。然后访问物理地址。</li>
<li>第二次访问0-4地址，去看快表，发现有了0号页表的记录，0号页表指向600号页框，那他就会拿着600直接去和偏移量拼接得到真实的物理地址，然后访问。</li>
<li>第三次访问0-8，同样的道理，不说了。</li>
</ol>
<p>如果快表存满了，会按照一种算法进行替换，这种算法后面会说。由于局部性原理，快表的命中率可以达到 90% 以上。假设访问一次快表1us，访问一次内存100us，那么平均访问内存时间 ：</p>
<p>$$<br>(1 + 100) * 0.9 + (1 + 100 + 100) * 0.1 &#x3D; 111us<br>$$</p>
<p>1 + 100 就是访问快表然后访问页框，1 + 200 就是先访问快表没命中，然后访问慢表，再访问页框。有些系统支持快表慢表同时访问，那么 （1+100+100）可以优化成 （100 + 100），最后的时间就是 110.9us。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623170308.png" alt="image.png"></p>
<h3 id="5-3-2-局部性原理"><a href="#5-3-2-局部性原理" class="headerlink" title="5.3.2 局部性原理"></a>5.3.2 局部性原理</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623170418.png" alt="image.png"></p>
<h3 id="5-3-3-总结"><a href="#5-3-3-总结" class="headerlink" title="5.3.3 总结"></a>5.3.3 总结</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623170441.png" alt="image.png"></p>
<h2 id="5-4-两级页表"><a href="#5-4-两级页表" class="headerlink" title="5.4 两级页表"></a>5.4 两级页表</h2><p>假设内存 4GB，页面大小 4KB，页表项长度 4B。则系统会将内存划分为 2^20 个页框，相应的用户进程最多有 2^20页，进而一个进程的页表中，最多有2^20个页表项，一个页表最大需要 2^22 B，共需要2^10个页框存储该页表。</p>
<p>然后，虽然说进程所对应的页框不一定要连续存放，但是表页却需要连续存放，因为我们要顺着页表找页框号，所以内存就需要给这个页表分配 1024 个页框。而且，进程在一段时间内，只需要用到几个页框，其他页框可能并不需要。</p>
<p>所以问题：</p>
<ul>
<li>页表必须连续存放，如果页表很大，则需要占用很多连续的页框</li>
<li>没有必要让页表常驻内存，因为一段时间内可能只需要访问某几个特定的页框。</li>
</ul>
<h3 id="5-4-1-两级页表设计"><a href="#5-4-1-两级页表设计" class="headerlink" title="5.4.1 两级页表设计"></a>5.4.1 两级页表设计</h3><p>为了解决上面的第一个问题，就出现了两级页表。之前，我们是将进程的逻辑内存空间按照页划分，这回我们将页表按同样的形式进行划分。</p>
<p>如果计算机内存 4GB，页表项 4B，页面大小 4KB，则一个页面可以装入 1024 个页表项，我们就可以按照1024将页表进行划分，然后将这些小页表离散的存储到内存中。然后，为这些小页表建立上层的页目录表（顶级页表或者叫外层页表）：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623214709.png" alt="image.png"></p>
<h3 id="5-4-2-如何地址变换"><a href="#5-4-2-如何地址变换" class="headerlink" title="5.4.2 如何地址变换"></a>5.4.2 如何地址变换</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623215054.png" alt="image.png"></p>
<p>这个顺着图看就行了：</p>
<ol>
<li>根据一级页号 0 去页目录表中找到了页框号3，也就是说二级页表存在了3号页框也就是起始地址为12KB的位置。</li>
<li>读取三号页框，得到了二级页表，根据二级页号 1 找到了页框号4，就是说我们要访问的地址在4号页框。</li>
<li>然后 4号页框的起始地址 4 x 4KB 加上偏移地址 111111111111 也就是 1023 得到了最终的物理地址。</li>
</ol>
<p>或者我们也可以把二级页号的哪个值理解成页框号在二级页表所在的页框中的偏移量。所以说，这里一个页面可以存 2^10 个页表项，那么二级页号就需要 10bit 来存储。</p>
<h3 id="5-4-3-如何按需访问页表"><a href="#5-4-3-如何按需访问页表" class="headerlink" title="5.4.3 如何按需访问页表"></a>5.4.3 如何按需访问页表</h3><p>这个是为了解决上面的第二个问题，这里涉及到虚拟存储技术，以后再说。可以在页表项中添加一个标志为，用于表示该页面是否已经调入内存。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623215457.png" alt="image.png"></p>
<h3 id="5-4-4-多级页表"><a href="#5-4-4-多级页表" class="headerlink" title="5.4.4 多级页表"></a>5.4.4 多级页表</h3><p>是一个例题：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623220447.png" alt="image.png"></p>
<p>这里解释一下为啥弄三级页表：题目规定各级页表的大小不能超过一个页面，一个页面只能存 1024 个页表项，也就需要 10bit 来表示偏移量。</p>
<p>假设我们让他是二级页表结构，则28bit的页号就分为了 18bit的一级页表和 10bit 的二级页表，则一级页表理论上就可以储存最多 2^18个页表项，一个页面显然存不下了，所以需要再给这个一级页表按页分层，然后上层设计更高级的目录。</p>
<h3 id="5-4-5-总结"><a href="#5-4-5-总结" class="headerlink" title="5.4.5 总结"></a>5.4.5 总结</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623220419.png" alt="image.png"></p>
<h2 id="5-5-基本分段存储管理"><a href="#5-5-基本分段存储管理" class="headerlink" title="5.5 基本分段存储管理"></a>5.5 基本分段存储管理</h2><p>这个是从进程本身出发，根据程序的自身逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序猿使用段名来编程），每段从0开始编址。进程的每个段可以在内存中不连续，但是段内是连续的。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623221313.png" alt="image.png"></p>
<p>分了段之后如何访问地址？</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623221515.png" alt="image.png"></p>
<p>系统为了找到程序的每个段在内存中的物理地址，就设计出了段表：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623221633.png" alt="image.png"></p>
<h3 id="5-5-1-地址变换"><a href="#5-5-1-地址变换" class="headerlink" title="5.5.1 地址变换"></a>5.5.1 地址变换</h3><p>这个和之前的分页存储很像，分段式系统里面同样会提供一个段表寄存器，里面存放段表地址F和段表长度M，这个东西也是存在PCB中，然后进程上 CPU 之后被放入寄存器。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623222346.png" alt="image.png"></p>
<p>这里所说的段表长度就是段长C和基址b所占的字节数。</p>
<h3 id="5-5-2-分段、分页对比"><a href="#5-5-2-分段、分页对比" class="headerlink" title="5.5.2 分段、分页对比"></a>5.5.2 分段、分页对比</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623222714.png" alt="image.png"></p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623222930.png" alt="image.png"></p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623223002.png" alt="image.png"></p>
<h3 id="5-5-3-总结"><a href="#5-5-3-总结" class="headerlink" title="5.5.3 总结"></a>5.5.3 总结</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623223110.png" alt="image.png"></p>
<h2 id="5-6-段页式存储管理"><a href="#5-6-段页式存储管理" class="headerlink" title="5.6 段页式存储管理"></a>5.6 段页式存储管理</h2><p>其实就是分段和分页式管理，先给进程分段，然后给每个段分页，将分好的页填到内存的页框中。按照这种方法的话，逻辑地址的设计如下：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628094725.png" alt="image.png"></p>
<ul>
<li>段号规定当前地址在哪个段，同时段号的位数也规定了这个进程最多可以分多少段</li>
<li>页号规定当前地址在段内的哪个页上，页号位数规定了一个段可以分出来多少页</li>
<li>页内偏移量好理解。同时位数规定了页面大小、内存快大小</li>
</ul>
<p>所以上面这图，进程可以分2^16个段，每个段可以分4个页，每个页 2^12页就是4K大小。对于程序员来说，段是程序猿决定的。</p>
<h3 id="5-6-1-段表、页表"><a href="#5-6-1-段表、页表" class="headerlink" title="5.6.1 段表、页表"></a>5.6.1 段表、页表</h3><p>同理，系统也会给进程维护一个段表，同时每个段还要分页，所以每个段自己还有一个页表。所以段表的结构就是：段号-页表长度-当前段的页表所在的页框号。根据页框号，就可以得到这个段自己的页表，然后页表里面记录 页号-内存页框号，再得到段里面页的实际物理地址。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628095607.png" alt="image.png"></p>
<p>一个进程对应一个段表，但是每个段都会对应一个页表。</p>
<h3 id="5-6-2-地址变换"><a href="#5-6-2-地址变换" class="headerlink" title="5.6.2 地址变换"></a>5.6.2 地址变换</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628095944.png" alt="image.png"></p>
<p>我们会发现这个寻址过程，三种内存管理方式都大差不差，一个套路。</p>
<ul>
<li>首先，肯定都会提供一个寄存器，什么段表寄存器，什么页表寄存器，他们的作用就是记录这个表的起始位置和每一个表项的大小，只要有了段号或者页号，就可以根据这两个数值访问到具体的表项。</li>
<li>拿到表项以后根据需求不同的到具体的段地址或者页地址，或者是这种情况得到的是段页表。</li>
</ul>
<h3 id="4-6-3-总结"><a href="#4-6-3-总结" class="headerlink" title="4.6.3 总结"></a>4.6.3 总结</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628100408.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>09.虚拟内存</title>
    <url>/2023/06/30/09-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>虚拟内存</p>
<span id="more"></span>

<h1 id="1-虚拟内存概念"><a href="#1-虚拟内存概念" class="headerlink" title="1. 虚拟内存概念"></a>1. 虚拟内存概念</h1><p>传统的内存管理分为连续分配和非连续分配，共同点都是需要将全部的进程数据加载到内存中才可以运行。这就会造成两个问题：</p>
<ul>
<li>作业很大时，不能全部装入内存，导致大作业无法运行，比如各种大型游戏</li>
<li>大量作业要求运行时，由于内存无法装入所有作业，因此只有少量作业能够运行，导致多道程序并发度下降</li>
</ul>
<p>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直到作业运行结束，实际上一个时间段内只需要访问作业的一小部分数据即可正常运行，这就导致内存中驻留大量的暂时用不到的数据，浪费资源。</p>
<h2 id="1-1-局部性原理"><a href="#1-1-局部性原理" class="headerlink" title="1.1 局部性原理"></a>1.1 局部性原理</h2><p>虚拟内存就是基于局部性原理出来的，局部性分为两种：</p>
<ul>
<li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很可能再次被执行</li>
<li>空间局部性：如果访问了某个存储单元，那么附近的其他存储单元也可能被访问</li>
</ul>
<h2 id="1-2-虚拟内存定义和特征"><a href="#1-2-虚拟内存定义和特征" class="headerlink" title="1.2 虚拟内存定义和特征"></a>1.2 虚拟内存定义和特征</h2><p>基于局部性原理，当程序装入内存时，可以将程序中很快会被用到的部分装入内存，暂时用不到的部分留在外存，然后开始执行。</p>
<p>执行过程中，当访问信息不在内存中时，操作系统将所需要信息从外存调入内存，然后继续执行进程。</p>
<p>如果内存空间不够，操作系统负责将内存中暂时不到的信息换出内存。</p>
<p>所以在操作系统的管理下，用户就会觉得似乎有一个比实际内存大的多的内存空间，这个就是虚拟内存。</p>
<p>虚拟内存的三个主要特征：</p>
<ul>
<li>多次性：无需在作业运行时一次性装入内存，而是允许多次调入内存</li>
<li>对换性：在作业运行时无需一直常驻内存，而是运行在作业运行过程中将作业换入换出</li>
<li>虚拟性：在逻辑上扩充了内存容量，在用户看来内存多于实际容量</li>
</ul>
<h2 id="1-3-如何实现虚拟内存技术"><a href="#1-3-如何实现虚拟内存技术" class="headerlink" title="1.3 如何实现虚拟内存技术"></a>1.3 如何实现虚拟内存技术</h2><p>既然允许多次调入内存，那么连续分配方式就不太合适了。因此虚拟内存的前提是操作系统支持离散分配内存的管理方式。</p>
<p>传统的离散管理方式：</p>
<ul>
<li>分页式管理</li>
<li>分段式管理</li>
<li>段页式管理</li>
</ul>
<p>虚拟内存的实现方式：</p>
<ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ul>
<p>区别在于，进程执行过程中，当访问的信息不在内存时，操作系统负责将所需信息从外存调入内存，然后继续执行，操作系统需要提供请求调页功能。空间不够时，操作系统负责将内存中暂时用不到的信息换出到外存，操作系统需要提供页面置换功能。</p>
<h2 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628231408.png" alt="image.png"></p>
<h1 id="2-请求分页存储管理方式"><a href="#2-请求分页存储管理方式" class="headerlink" title="2. 请求分页存储管理方式"></a>2. 请求分页存储管理方式</h1><p>对比基本分页管理方式，主要需要提供两个功能：</p>
<ul>
<li>请求调页：发现访问的信息不在内存中，OS将所需信息从外存调入内存</li>
<li>页面置换：内存空间不够，OS负责将不需要的信息换出到外存</li>
</ul>
<h2 id="2-1-页表机制"><a href="#2-1-页表机制" class="headerlink" title="2.1 页表机制"></a>2.1 页表机制</h2><p>与基本分页管理中的页表相比，有以下区别：</p>
<ul>
<li>OS 需要知道每个页面是否已经调入内存，如果没有，也需要知道页面在外存中的位置。</li>
<li>内存不够时需要进行页面置换，OS 需要通过某些指标来决定到底换出哪个页面；有的页面没有被修改过就不需要换出，修改过的页面就需要会写到外存覆盖旧数据。</li>
</ul>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628232041.png" alt="image.png"></p>
<h2 id="2-2-缺页中断机构"><a href="#2-2-缺页中断机构" class="headerlink" title="2.2 缺页中断机构"></a>2.2 缺页中断机构</h2><p>根据上图，假设我们现在要访问页号为0的页面，结果OS发现0号页面不在内存中，就会产生一个缺页中断，然后由OS的缺页中断处理程序处理中断。</p>
<p>此时缺页的进程阻塞，放入阻塞队列，调页完成后再唤醒，放回阻塞队列。</p>
<p>在调页的过程中，如果发现内存中有空闲页框，就将页框分配给0号页，同时修改页表中的内存块号为响应的页框号。如果发现内存中没有空闲位置了，就会由页面置换算法选择一个页面淘汰，比如淘汰2号页面，发现页面被修改，则将内存块c的内容覆盖回外存z的位置，然后修改内存块号为无，修改位为0，再将内存块c分配给0号页面，修改内存块号为c。</p>
<p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生，属于内中断，可以被修复，所以属于故障。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628232837.png" alt="image.png"></p>
<h2 id="2-3-地址转换"><a href="#2-3-地址转换" class="headerlink" title="2.3 地址转换"></a>2.3 地址转换</h2><p>这个和基本的分页管理其实没啥大的不同，只是多了三步：</p>
<ol>
<li>如果发现页面不在内存则请求调页</li>
<li>如果发现没有空闲的页框则则页面置换</li>
<li>需要修改页表中的页表项</li>
</ol>
<p>完整流程如下：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628233547.png" alt="image.png"></p>
<p>这里再说一个点：如果页面被调出内存放入外存，快表中的表项会一并删除，双写一致性了属于是。</p>
<h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628233922.png" alt="image.png"></p>
<h1 id="3-页面置换算法"><a href="#3-页面置换算法" class="headerlink" title="3. 页面置换算法"></a>3. 页面置换算法</h1><p>将页面置换出外存需要额外的IO开销，所以好的页面置换算法就要追求更少的缺页率，下面介绍5个页面置换算法。</p>
<h2 id="3-1-最佳置换算法OPT"><a href="#3-1-最佳置换算法OPT" class="headerlink" title="3.1 最佳置换算法OPT"></a>3.1 最佳置换算法OPT</h2><p>每次淘汰的页面都是以后永不使用，或者最长时间内不再被访问的页面，这样可以保证最低的缺页率。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628235452.png" alt="image.png"></p>
<p>第一次缺页发生在第四列，也就是第一次访问2的时候，当前内存中有7 0 1 三个页面，然后用这三个页面挨个往后数，最后出现的那个页面，就是要被置换出去的页面，所以置换出7，将2放在内存块1的位置。往后每次缺页都按照这个方法确定置换出的页面。</p>
<p>最佳置换算法可以保证最低的缺页率，但是进程执行过程中才能知道接下来会访问到哪个位置页面。操作系统无法提前预判页面访问序列，所以这种算法实际无法实现。</p>
<h2 id="3-2-先进先出置换算法FIFO"><a href="#3-2-先进先出置换算法FIFO" class="headerlink" title="3.2 先进先出置换算法FIFO"></a>3.2 先进先出置换算法FIFO</h2><p>很好理解，每次置换出去的页面都是最早进入内存的页面。实现方法也很简单，将调入内存的页面根据调入顺序排成一个队列，需要换出页面时选择队头页面即可，队列最大长度取决于系统为进程分配了多少个内存块。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628235917.png" alt="image.png"></p>
<p>这个图十分好理解，而且很有规律，反正就是依次往后按顺序置换就是了。</p>
<p>这种置换算法可能有个异常：Belady 异常：当为进程分配的内存块增多时，缺页次数不减反增。只有FIFO 算法会出现这种异常，另外，这种算法虽然实现简单，但是算法与进程的实际运行时的规律不适应，因此算法性能很差。</p>
<h2 id="3-3-最近最久未使用置换算法LRU"><a href="#3-3-最近最久未使用置换算法LRU" class="headerlink" title="3.3 最近最久未使用置换算法LRU"></a>3.3 最近最久未使用置换算法LRU</h2><p>每次淘汰的页面都是最近最久未使用的页面。实现方法也简单，页表中加一项访问字段，该字段记录该页面自上次被访问以来所经历的时间t。每当要淘汰一个页面时，选择现有页面中t最大的。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230629064833.png" alt="image.png"></p>
<p>怎么算呢，和前面的OPT一样的思路，在访问3号页面的时候需要调入页面，此时内存中有1、8、7、2 四个页面，那就从3开始往前数，这四个数字最晚出现的那个就是最近最久未使用的，淘汰即可。这里从3往前数分别是8、1、2、7，7最后出现，所以淘汰7号页面。</p>
<p>这种算法需要专门的硬件支持，虽然算法性能很好，但是实现困难，开销大。</p>
<h2 id="3-5-时钟置换算法CLOCK"><a href="#3-5-时钟置换算法CLOCK" class="headerlink" title="3.5 时钟置换算法CLOCK"></a>3.5 时钟置换算法CLOCK</h2><p>也叫最近未用算法NRU，分为两种：简单的CLOCK算法和改进型CLOCK算法。</p>
<h3 id="3-5-1-简单的时钟置换算法"><a href="#3-5-1-简单的时钟置换算法" class="headerlink" title="3.5.1 简单的时钟置换算法"></a>3.5.1 简单的时钟置换算法</h3><p>为每个页面设置一个访问位，再将内存中的页面都通过链接指针连接成一个循环队列。当某个页被访问时，其访问位时1。当要淘汰一个页面时，只需要检查页的访问位。如果是0，则该页换出；如果是1，则将其改为0，暂不换出，继续顺着循环队列检查下一个页面。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230629065651.png" alt="image.png"></p>
<p>如果第一轮扫描所有页面的访问位都是1，第二轮扫描肯定能扫到了。</p>
<p>假设系统为某个进程分配了5个内存块，并考虑到有以下页面号引用串：1，3，4，2，5，6，3，4，7.</p>
<p>首先一上来 1，3，4，2，5 五个页面会组成一个循环链表：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230629070308.png" alt="image.png"></p>
<p>然后访问6号页面的时候就会开始选择一个页面淘汰，从1号页面扫描到5号页面，访问位都是1，全部改为0后开始第二轮扫描，发现1的访问位是0，则换出1号页面，将6号页面加载进来，访问位设为1。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230629070501.png" alt="image.png"></p>
<p>然后访问3，4，7号页面。3号和4号页面再次访问，所以给访问位设为1，访问7号页面时需要置换，则从3号页面开始扫描，3号和4号的访问位刚刚被设为1，所以暂时不淘汰并访问位设为0，最终淘汰2号页面，将7号页面加载。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230629070703.png" alt="image.png"></p>
<p>我们会发现他的淘汰策略就像时钟一样一直在转圈扫描，所以这种算法就叫时钟置换算法。</p>
<h3 id="3-5-2-改进型时钟置换算法"><a href="#3-5-2-改进型时钟置换算法" class="headerlink" title="3.5.2 改进型时钟置换算法"></a>3.5.2 改进型时钟置换算法</h3><p>这种算法还考虑了页面是否被修改过。如果淘汰的页面没有被修改过，是不需要往外存里面回写的，因此在页表里面加一个修改位，修改位&#x3D;0，说明页面没有被修改，修改位&#x3D;1则修改过。根据（访问位，修改位）来决定是否淘汰。</p>
<p>算法规则：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230629071456.png" alt="image.png"></p>
<p>还是挺好理解的。</p>
<h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230629071520.png" alt="image.png"></p>
<h1 id="4-页面分配策略"><a href="#4-页面分配策略" class="headerlink" title="4. 页面分配策略"></a>4. 页面分配策略</h1><h2 id="4-1-页面分配、置换策略"><a href="#4-1-页面分配、置换策略" class="headerlink" title="4.1 页面分配、置换策略"></a>4.1 页面分配、置换策略</h2><p>首先说一个概念：驻留集：请求分页存储管理中给进程分配的物理块的集合；说白了就是进程持有的全部内存块。</p>
<p>页面分配策略有两种：</p>
<ul>
<li>固定分配：操作系统为每个进程分配一组固定数目的物理块，进程运行期间不再改变，也就是驻留集大小不变。</li>
<li>可变分配：很好理解，进程运行期间视情况修改物理块数目，也就是驻留集大小可变。</li>
</ul>
<p>页面置换策略也有两种：</p>
<ul>
<li>局部置换：一个进程只能将自己进程的页面置换出内存</li>
<li>全局置换：操作系统可以将空闲的内存块分配给缺页进程，也可以将其他进程的内存块置换到外存，在跟配给缺页进程。</li>
</ul>
<p>两种分配、置换策略组合，得到三种模式：</p>
<table>
<thead>
<tr>
<th></th>
<th>局部置换</th>
<th>全局置换</th>
</tr>
</thead>
<tbody><tr>
<td>固定分配</td>
<td>Y</td>
<td>-</td>
</tr>
<tr>
<td>可变分配</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
<p>三种策略具体如下，太多了直接看图吧，还算好理解：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230629073646.png" alt="image.png"></p>
<h2 id="4-2-如何调入页面"><a href="#4-2-如何调入页面" class="headerlink" title="4.2 如何调入页面"></a>4.2 如何调入页面</h2><p>两种办法：</p>
<ul>
<li>预调页策略：根据局部性原理，访问一个页的话，附近的页最近也可能被访问到。所以一次调入若干个相邻的页面可能比调入一个页面更高效。但是如果预先调入的页面没有被使用，则又是低效的。因此可以预测不久后会用到的页面将他们一批调入内存，但是预测率只有50%左右。所以这种策略主要用于进程首次调入内存，由程序猿制定应该先调入哪些部分。核心是运行前调入。</li>
<li>请求调页策略：这个就是之前说的，只有在运行期间发现缺页才会将页面调入内存。这种策略调入的页面肯定会被访问到，但是每次只能调入一个页面，因此IO开销大。运行时调入。</li>
</ul>
<h2 id="4-3-从哪里调入页面"><a href="#4-3-从哪里调入页面" class="headerlink" title="4.3 从哪里调入页面"></a>4.3 从哪里调入页面</h2><p>我们之前学进程挂起的时候学过磁盘中有一块地方叫对换区，里面数据连续存储，IO速度更快，所以围绕对换区，有三种办法：</p>
<ol>
<li>如果磁盘对换区空间够的话，在进程运行前就会将数据从文件区复制到对换区，往后的调页和页面置换都会在对换区完成</li>
<li>对换区空间不够，则不会被修改的数据直接从文件区调入内存，毕竟不需要回写，下次使用仍旧从文件区调入，需要被修改的数据一开始也是从文件区调入，但是页面置换会置换到交换区，下次再从置换去调页。</li>
<li>UNIX方式：运行前所有文件放在文件区，故未使用过的页面都可以从文件区调入。若被使用过的页面需要换出，则回写到交换区，下次再从交换区调入。</li>
</ol>
<h2 id="4-4-抖动（颠簸）现象"><a href="#4-4-抖动（颠簸）现象" class="headerlink" title="4.4 抖动（颠簸）现象"></a>4.4 抖动（颠簸）现象</h2><p>刚刚调入的页面马上又被换出内存，刚刚被换出的页面马上又被调入，这种频繁的调度行为称为抖动。主要原因就是进程频繁访问的页面数目高于实际可用的物理块，简单说就是物理块分配少了。</p>
<h2 id="4-5-工作集"><a href="#4-5-工作集" class="headerlink" title="4.5 工作集"></a>4.5 工作集</h2><p>上面的问题，如果分配的物理块少，会发生抖动，如果多了，可能造成浪费，所以提出了工作集的概念。</p>
<p>和驻留集类似，驻留集：给进程分配的所有物理块的集合。工作集：在某段时间内，进程实际访问页面的集合。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230630082003.png" alt="image.png"></p>
<h2 id="4-6-总结"><a href="#4-6-总结" class="headerlink" title="4.6 总结"></a>4.6 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230630082036.png" alt="image.png"></p>
<h1 id="5-内存映射文件"><a href="#5-内存映射文件" class="headerlink" title="5. 内存映射文件"></a>5. 内存映射文件</h1><h2 id="5-1-传统文件读写方式"><a href="#5-1-传统文件读写方式" class="headerlink" title="5.1 传统文件读写方式"></a>5.1 传统文件读写方式</h2><p>传统读文件方式相当复杂，假设有一个文件 index.txt，磁盘里面都是分块存的，所以文件也被分成了好几个块放在磁盘。读取的顺序如下：</p>
<ul>
<li>open 系统调用：打开文件</li>
<li>seek 系统调用：将读写指针移到某个位置，比如移到了第二个磁盘块的位置</li>
<li>read 系统调用：从读写指针位置读入多个数据放入内存，比如将第二个磁盘块调入内存</li>
<li>然后就可以访问内存读取文件</li>
<li>如果在内存中修改文件的话，最后要使用 write 系统调用，根据读写指针将内存中的制定数据写回磁盘</li>
</ul>
<h2 id="5-2-内存映射文件"><a href="#5-2-内存映射文件" class="headerlink" title="5.2 内存映射文件"></a>5.2 内存映射文件</h2><p>内存映射文件可以让读写文件变得更简单，操作文件的时候，会将文件在磁盘中的位置映射到进程的虚拟内存上，但不会真正将文件加载到内存。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230630103536.png" alt="image.png"></p>
<p>当我们真正访问1号地址的时候，就会发生缺页异常，操作系统就会自动将磁盘中的内存调入内存。如果我们要修改文件内容，直接修改内存中的数据即可，结束后操作系统会自动将修改过的内存块回写到磁盘。</p>
<p>流程如下：</p>
<ul>
<li>open 系统调用：打开文件</li>
<li>mmap 系统调用：将文件映射到进程的虚拟地址空间</li>
</ul>
<p>然后我们就可以以访问内存的方式访问文件数据，文件数据的读入和写出都由操作系统自动完成。进程关闭文件时，操作系统自动将文件被修改的数据写回磁盘。</p>
<p>同时，内存映射文件还可以实现文件共享。两个进程访问一个文件，两个进程的虚拟存储空间都会映射这个文件，两个进程的虚拟空间会通过页表映射到同一块物理内存。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230630104129.png" alt="image.png"></p>
<h2 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230630104147.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>JIT即时编译器</title>
    <url>/2022/06/02/JIT/</url>
    <content><![CDATA[<p>最早我们说运行时数据区的时候有一张图，就是runtime的构造，里面有PC，堆，栈，方法区，本地方法栈啥的，还有一个东西，叫JIT编译产物 CodeCache，这时啥玩意？我们这里就来介绍一下JIT是啥东西。</p>
<span id="more"></span>

<h1 id="1-JIT-即时编译器"><a href="#1-JIT-即时编译器" class="headerlink" title="1. JIT 即时编译器"></a>1. JIT 即时编译器</h1><p>首先明确几个概念：</p>
<ul>
<li><p>Java 运行在 JVM上，JVM 类似 物理机，二者都有指令，比如物理机有 汇编 机器码 JVM 就有JVM指令。</p>
</li>
<li><p>Java 是半解释半编译语言</p>
</li>
<li><p>这个编译，分为两部分：</p>
<ul>
<li><p>前端编译：javac 编译代码变成 class 文件</p>
</li>
<li><p>后端编译: JIT 编译代码为 计算机认识的指令</p>
</li>
</ul>
</li>
<li><p>翻译，指的是 JVM 通过 PC寄存器，逐条执行class文件里面的指令</p>
</li>
<li><p>JIT 是即时编译器，也就是在程序运行时编译，是否编译取决于热点探测，这个后面会说到。</p>
</li>
</ul>
<h1 id="2-Java代码的执行分类"><a href="#2-Java代码的执行分类" class="headerlink" title="2. Java代码的执行分类"></a>2. Java代码的执行分类</h1><p>如下图：</p>
<p><img src="/images/runtime/JIT.png"></p>
<p><img src="/images/runtime/JIT2.png" alt="jit2"></p>
<p>上图两个就是Java编译的方式。</p>
<p>途中，黄色的路线：程序源码一直到抽象语法树，都是javac 给我们处理， 目的是生成线性的指令集合，然后 要么是 JVM直接翻译运行，要么就是 JIT 编译成机器码 运行。</p>
<p>即时编译：</p>
<p>就是JIT编译完以后，机器码存起来了，如果再次调用这个方法，他就会直接去找机器码运行。</p>
<h1 id="3-HotSpot-采用的方式"><a href="#3-HotSpot-采用的方式" class="headerlink" title="3. HotSpot 采用的方式"></a>3. HotSpot 采用的方式</h1><p>HotSpot 是两种方式都在使用，在运行时 即时编译和翻译是同步进行，二者协调进行。</p>
<p>即时编译的好处就是一次编译，以后运行速度快，但是编译也耗费时间。</p>
<p>翻译的好处就是不需要翻译，直接运行。</p>
<p>当虚拟机启动时，翻译器会首先工作，省去编译的时间，然后随着时间的推移， 即时编译器开始起作用，将一些有价值的代码编译成机器指令，提高速度。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>生产环境中，热机能承受的负载大于冷机，如果项目体量大，流量大，那么吧一个项目部署到一个JVM刚刚启动的机器上，可能导致宕机。</p>
<h1 id="4-细说JIT"><a href="#4-细说JIT" class="headerlink" title="4. 细说JIT"></a>4. 细说JIT</h1><ul>
<li><p>java 语言的 “编译期” 其实是一段不确定的操作过程，因为他有三种情况：</p>
</li>
<li><p>既可能指的是前端编译 也就是 javac 编译，把java文件转化为class文件</p>
</li>
<li><p>也可能是后端编译，将JVM指令转化为机器码</p>
</li>
<li><p>还有可能是静态提前编译器(AOT 编辑器， Ahead Of Time Compiler) 直接吧 Java 编译成机器码</p>
</li>
</ul>
<p>问题来了，前面提到，Hotspot 虚拟机是 编译和翻译同时进行的，</p>
<p>那么jvm如何选择哪些编译哪些翻译？就用到了下面的东西</p>
<h1 id="5-热点代码及探测方法"><a href="#5-热点代码及探测方法" class="headerlink" title="5. 热点代码及探测方法"></a>5. 热点代码及探测方法</h1><p>是否需要启动JIT去编译代码取决于这个代码的执行频率，如果执行频率高，则启动JIT进行编译，同时JIT对其进行 <em>深度优化</em> ，然后编译成机器码，那么这部分执行频率高的代码，也叫做 <em>热点代码</em> 。</p>
<ul>
<li><p>一个被多起的方法，或者是一个方法题内循环册数比较大多的循环体，都可以称为 <em>热点代码</em> 。因为这个过程发生在方法执行过程中，所以这个方法也成为 <em>栈上替换</em> 简称 OSR(On Stack Replacement)</p>
</li>
<li><p>那么一个代码被执行多少次就算是热点代码了？这主要依赖<em>热点探测功能</em>。</p>
</li>
<li><p>Hotspot 的热点探测方式是基于计数器的热点探测</p>
</li>
<li><p>采用计数器，Hotspot VM 将给每一个方法都建立2个不同的计数器，分别是：</p>
<ul>
<li><p>方法调用计数器：统计方法调用次数</p>
</li>
<li><p>回边计数器：统计循环体执行的循环次数</p>
</li>
</ul>
</li>
<li><p>阈值：VM 的client模式下是 1500次，server 模式下 10000 次</p>
<blockquote>
<p>即便我们的是PC，个人电脑，但是VM也是server 模式，</p>
<p>可以 <code>java --version</code> 看一看.</p>
</blockquote>
</li>
<li><p>这个阈值可以通过 <code>-XX:CompileThreshold</code> 来人为设定。</p>
</li>
<li><p>超过阈值，就会提交编译请求，然后JIT编译，最后的编译结果，也就是机器指令，他会存在方法区里面，我们之前也说过 方法区里面有JIT的代码缓存 <em>CodeCache</em> 。</p>
</li>
</ul>
<p>具体流程如下图：</p>
<p><img src="/images/runtime/JIT3.png" alt="jit3"></p>
<hr>
<h2 id="热度衰减"><a href="#热度衰减" class="headerlink" title="热度衰减"></a>热度衰减</h2><ul>
<li><p>如果不做任何设置，方法调用计数器记录的并不是一个绝对的次数，而是一个相对的频率，也就是一段时间内的调用次数，如果超过了这个一段时间，方法的调用次数还不足以提交便已请求，那么调用计数器的值就会减半，这个过程称为程序计数器的<strong>热度衰减</strong>，这段时间叫<strong>半衰期</strong>。</p>
</li>
<li><p>热度衰减是 JVM在垃圾回收的时候顺便进行的行为，可以通过参数 <code>-XX:-UseCounterDecay</code> 来关闭热度衰减，这个时候，调用计数器记录的就是一个绝对的调用次数，只要运行时间够长，绝大多数的方法都可以被编译。</p>
</li>
<li><p>可以通过 <code>-XX:CounterHalfLifeTime</code>来设置半衰期时间，单位是秒。</p>
</li>
</ul>
<h1 id="6-JVM-关于JIT的参数"><a href="#6-JVM-关于JIT的参数" class="headerlink" title="6. JVM 关于JIT的参数"></a>6. JVM 关于JIT的参数</h1><ul>
<li><p><code>-Xint</code> 代码全部解释执行，也可以 java -Xint –version 我们会看到 interpreted mod，也就是解释执行</p>
</li>
<li><p><code>-Xcomp</code> 代码全部编译执行，同理上面，看到 compile mode 编译执行</p>
</li>
<li><p><code>-Xmixed</code> 代码混合执行，一边翻译一边编译。</p>
</li>
</ul>
<h1 id="7-JVM模式"><a href="#7-JVM模式" class="headerlink" title="7. JVM模式"></a>7. JVM模式</h1><p>我们之前说过，JVM分为两种模式：client 模式 和 server 模式，client 模式里面调用计数器阈值是1500 次 server 是 10000次，同事JIT也分为两种，一个 Client Compiler(简称C1)，一个 Server Compiler (简称C2)如何修改这两种模式：</p>
<ul>
<li><p><code>-client</code> 开启 client 模式，使用C1，优化比较简单，耗时短，达到最快的编译速度。</p>
</li>
<li><p><code>-server</code> 开启 server模式，使用C2，64位电脑是支持server模式的，同时默认开启，server模式优化的更深一点，所以得到的机器码比client 更快，但是编译时间更长。</p>
</li>
</ul>
<h1 id="8-扩展：AOT提前编译器"><a href="#8-扩展：AOT提前编译器" class="headerlink" title="8. 扩展：AOT提前编译器"></a>8. 扩展：AOT提前编译器</h1><p>AOT 提前编译器，不同于即时编译器是运行时编译，他是在运行之前编译。</p>
<p>jdk9 引入了实验性的 aot编译工具 jaotc，将java 类文件直接编译成机器码，存放到生成的代码共享库中。</p>
<p>具体流程：.java -&gt; .class — jaotc —&gt; .os</p>
<p>好处就是第一次运行快了，坏处就是降低了 Java 链接过程的动态性，破坏了 java 一次编译到处运行的原则。</p>
<h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h1><p>可以看出这一章东西倒不是很多，比较简单，就是一些简单的概念，了解我觉得就行了。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-this指向问题</title>
    <url>/2022/10/16/JS-this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>之前的JS一直就学了个皮毛，this问题倒是也不咋碰到所以不咋重视，结果这次做项目发现this我是一点也不懂，所以就百度了好久，总结了一下 JS 里面的this到底是个啥。</p>
<span id="more"></span>

<blockquote>
<p>create by P-F on 2022&#x2F;10&#x2F;16</p>
</blockquote>
<h1 id="1-function-作为对象"><a href="#1-function-作为对象" class="headerlink" title="1. function 作为对象"></a>1. function 作为对象</h1><p>JS 里面的 function 与其说是函数，不如说是我们理解的方法，Java 里面的方法中的 this 就是指向的当前类的实例化对象，JS 的 function 也一样，在 function 作为普通方法调用的时候，function 内的 this 指向的就是当前 function 所在的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">hello</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello, i&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>, i&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子中，this 就指向的是当前 hello 方法的所属对象 user，所以就可以使用 <code>this.name</code> 这种的来访问对象的成员。</p>
<h1 id="2-function-作为函数"><a href="#2-function-作为函数" class="headerlink" title="2. function 作为函数"></a>2. function 作为函数</h1><p>如果说 function 没有在对象内，而是直接放在了上下文中，比如直接放在了 script 标签内，那么 function 的 this 其实也同理指向了 function 的所属对象，但是这个时候 function 的所属对象就变成了 function 的上下文。</p>
<p>举个例子：如果 function 直接放在了 script 标签内，那么就可以理解成这个对象是当前页面 window 对象的方法，所以 function 的 this 就会指向 window，那如果在 nodejs 环境中，function 直接写在文件内，那么 this 就指向了 nodejs 中的上下文对象 <code>global</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)&#125;</span><br><span class="line">    <span class="title function_">a</span>()</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="variable language_">window</span>&#123;...&#125; --&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nodejs:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">a</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object [global]...</span></span><br></pre></td></tr></table></figure>

<h1 id="3-this-不可继承"><a href="#3-this-不可继承" class="headerlink" title="3. this 不可继承"></a>3. this 不可继承</h1><p>如果出现了嵌套函数，那内层函数的 this 又变成谁了？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">20</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">foo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> c = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">c</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p>这里分析一下：外层的 foo 方法是 obj 对象的方法，所以 foo 方法内的 this 肯定是指向了 obj，这个没毛病，但是里面的 c 函数也是指向了 obj 么？结果显示并非，内层函数的 this 仍然是 window，似乎也好理解，因为 c 函数虽然在obj 对象的方法内部，但是本身并不属于某个对象，所以 this 还是 window。</p>
<p>那怎么改才能让内层的函数可以访问 obj？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">self</span>: <span class="variable language_">this</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">foo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(self)</span><br><span class="line">        &#125;)()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p>这样就可以了。</p>
<h1 id="4-function-作为构造函数"><a href="#4-function-作为构造函数" class="headerlink" title="4. function 作为构造函数"></a>4. function 作为构造函数</h1><p>这里就涉及到了 JS 面向对象的内容了，面向对象还涉及到 JS 的原型和原型链，以后会详细看的，目前还不会。只是大致说一下：function 可以作为构造函数，使用 new 关键字可以创建对象，看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">name</span>: name, <span class="attr">age</span>: age&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Person</span>(<span class="string">&#x27;jack&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 this 不代表 window 了，而是代表当前要构造的对象 &#123;  &#125;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello, i&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>, i&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> u = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;jack&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">u.<span class="title function_">hello</span>()</span><br></pre></td></tr></table></figure>

<p>上面的例子里面，第一个 Person 方法，也可以创建一个对象，但是略有点麻烦，那么就可以使用下面这种办法：使用 new 关键字来创建对象。</p>
<p>new 后面跟一个函数，然后函数会被当做构造函数执行，作为构造函数时，函数内的 this 就代表我要构造出来的这个对象。</p>
<h1 id="5-箭头函数的this"><a href="#5-箭头函数的this" class="headerlink" title="5. 箭头函数的this"></a>5. 箭头函数的this</h1><p>而箭头函数中，this 又是另一番镜像。箭头函数中的 this 只是一个普通的变量，没错，就是一个普通的变量。根据函数作用域，当函数内访问变量时，会在函数声明的地方找这个变量，如果找不到，就会从声明位置往上找，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line">    <span class="title function_">a</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">b</span>()</span><br></pre></td></tr></table></figure>

<p>这里会打印 10，为啥？因为 b 函数内调用 a 函数，a 函数要找 a 变量，从 a 的声明位置开始找，a 函数内没有，则往外找，也就找到了全局里面的 <code>let a = 10</code>。</p>
<p>同理，调用一个箭头函数，对于箭头函数来说 this 就是一个普通变量，他会根据上面的原则去找这个 this 到底是个啥，比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> a = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">b</span> = (<span class="params"></span>) =&gt; &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">a</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">b</span>()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这俩输出的 this 全是 window，为啥？因为在 script 标签内，this 就是 window，a 函数看作是 window 的方法，所以 a 的 this 是 window，但是 b 不一样，b 函数里面找 this，没找到，就去 b 的上层作用域里面找，也就是 script 标签内，结果发现了 script 标签内有 this，还是 window，所以 b 打印 this 也是 window。</p>
<p>这里虽然俩 this 都是 window，但意义是不一样的，在 nodejs 环境：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">b</span> = (<span class="params"></span>) =&gt; &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">a</span>()</span><br><span class="line"><span class="title function_">b</span>()</span><br></pre></td></tr></table></figure>

<p>这回就不一样了，a 出来的 this 是 global，而 b 的 this 就是 { }，因为 nodejs 中，函数的看做是 global 的方法，但是这个 global 可不是这个 js 文件的作用域，一个 js 文件里面默认就有一个对象 this &#x3D; {}，所以调用 b 函数找 this 就找到了 { }。</p>
<p>一句这个特性，我们就可以优化上面提到的 this 继承问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">c</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">c</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<p>这次就可以正常让内层函数正确的访问到外层方法的 this 对象，原因也很简单，c 函数调用时，碰到了 this，但是不知道这个 this 是啥声明里面也没有，就跑到 c 的上层作用域也就是 foo 方法内去找 this，结果在 foo 里面找到了 this 也就是 obj 对象，所以就可以正确访问 obj 了。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-类加载子系统</title>
    <url>/2022/05/22/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>从这里开始正式开始JVM，首先我们要对类加载有一个大致的认识。类加载子系统 就是将 类 从磁盘中读取到 内存中的一个东西，包括 加载 链接 初始化 三个阶段。</p>
<span id="more"></span>

<h1 id="1-类加载三阶段"><a href="#1-类加载三阶段" class="headerlink" title="1. 类加载三阶段"></a>1. 类加载三阶段</h1><h2 id="1-1-加载"><a href="#1-1-加载" class="headerlink" title="1.1 加载"></a>1.1 加载</h2><ol>
<li><p>通过一个类的全限定命名，获取这个类的二进制流。</p>
<blockquote>
<p>class 文件来源：<br>Class文件；applet 网络；计算生成也就是动态代理；JSP；压缩文件(jar war)。。。</p>
</blockquote>
</li>
<li><p>将字节流代表的静态存储结构转化为方法区的运行时数据结构。</p>
</li>
<li><p>在内存中生成代表这个类的反射(java.lang.Class)，作为方法区这个类的各种数据访问入口。</p>
</li>
</ol>
<h2 id="1-2-链接"><a href="#1-2-链接" class="headerlink" title="1.2 链接"></a>1.2 链接</h2><h3 id="1-2-1-验证-verify"><a href="#1-2-1-验证-verify" class="headerlink" title="1.2.1 验证 verify"></a>1.2.1 验证 verify</h3><p>保证加载类的字节流包含的数据符合规范，不会危害到JVM。<br>主要验证：文件格式 元数据 字节码 符号引用</p>
<blockquote>
<p>这里举个例子，Java 的字节码文件有一个规范，二进制都以 CA FE BA BE 开头</p>
</blockquote>
<h3 id="1-2-2-准备阶段"><a href="#1-2-2-准备阶段" class="headerlink" title="1.2.2 准备阶段"></a>1.2.2 准备阶段</h3><p>给 类变量设置初始值为零值，仅限于类变量，也就是 static,不包含 final static，因为 final 的零值在编译的时候就已经分配了。</p>
<h3 id="1-2-3-解析"><a href="#1-2-3-解析" class="headerlink" title="1.2.3 解析"></a>1.2.3 解析</h3><p>常量池中的符号引用改为直接引用,举个例子，我们就写一个类里面有一个主方法，他就需要加载一大堆类，其实就是 lang 底下的各种类，总不能说都放到out目录下，所以就需要引用他们。</p>
<p>详细的以后细说，这里大致了解一下。</p>
<h2 id="1-3-初始化阶段"><a href="#1-3-初始化阶段" class="headerlink" title="1.3 初始化阶段"></a>1.3 初始化阶段</h2><ol>
<li><p>调用类的 clinit 方法，这个方法会把 所有对 static 成员的赋值操作收集起来，<br>写成一个方法 clinit(按顺序，按顺序，按顺序)，对 static 进行重新赋值</p>
<blockquote>
<p>这里举一个例子：<br> static{num &#x3D; 20;} private static int num &#x3D; 10;<br>首先因为链接阶段的 prepare，num 在初始化前就是 0，所以在初始化的时候，按照顺序生成 clinit，也就是先 num &#x3D; 20，再 num &#x3D; 10，所以最后，num &#x3D;&#x3D; 10 </p>
</blockquote>
</li>
<li><p>如果说 我们的类 里面没有 static，那么就不存在 clinit</p>
</li>
<li><p>clinit 不同于 构造函数，clinit 在 构造之前执行，在JVM 的角度，构造函数 是 &lt;init&gt;() 方法，在 &lt;clinit&gt;() 之后。</p>
</li>
<li><p>子类执行 clinint 之前，必须执行 超类 的 clinit</p>
</li>
<li><p>JVM 保证多线程下 clinit 方法被枷锁</p>
</li>
</ol>
<h1 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2. 类加载器"></a>2. 类加载器</h1><h2 id="2-1-概括"><a href="#2-1-概括" class="headerlink" title="2.1 概括"></a>2.1 概括</h2><p>JVM 支持两种类加载器：</p>
<ul>
<li><p>引导类加载器 Bootstrap ClassLoader</p>
</li>
<li><p>自定义类加载器 User-defined Class Loader</p>
<blockquote>
<p>这个自定义类加载器不是说我们自己写的，而是只要派生了抽象类ClassLoader的，<br>都叫自定义类加载器。</p>
</blockquote>
</li>
</ul>
<p>必须注意的是，Bootstrap ClassLoader 并没有继承 ClassLoader，它使用 C 实现的。</p>
<p>各个类加载器之间是包含关系，不是上下级，更不是继承。</p>
<pre><code>                  BootstrapClassLoader
                           |
                  ExtensionClassLoader
                           |
                    SystemClassLoader
                           |
              |------------+-----------|                      
     User-def ClassLoader     User-def ClassLoader
             ...                      ...
</code></pre>
<p>我们可以通过代码来验证这种关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 sun.misc.Launcher$AppClassLoader 表明得到了 SystemClassLoader</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">sysLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 sun.misc.Launcher$ExtClassLoader 表明ExtClassLoader包含 SystemClassLoader</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">extLoader</span> <span class="operator">=</span> sysLoader.getParent();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法得到 ExtClassLoader 的parent，因为他的上层 BootstrapClassLoader 不是Java写的。返回null</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">bootLoader</span> <span class="operator">=</span> extLoader.getParent();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类的类加载器，返回 AppClassLoader，也就是系统类加载器加载自定义类。</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">myClassLoader</span> <span class="operator">=</span> MyClass.class.getClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 由引导类加载器加载，返回 null 所以 Java 的核心类都被引导加载器加载</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">stringLoader</span> <span class="operator">=</span> String.class.getClassLoader();</span><br></pre></td></tr></table></figure>

<h2 id="2-2-JVM自带的类加载器"><a href="#2-2-JVM自带的类加载器" class="headerlink" title="2.2 JVM自带的类加载器"></a>2.2 JVM自带的类加载器</h2><h3 id="2-2-1-启动类加载器"><a href="#2-2-1-启动类加载器" class="headerlink" title="2.2.1 启动类加载器"></a>2.2.1 启动类加载器</h3><p>也叫引导类加载器 BootstrapClassLoader</p>
<ul>
<li><p>用 C&#x2F;C++ 实现，嵌套在JVM内部</p>
</li>
<li><p>用来加载Java核心类库</p>
<blockquote>
<p>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar resources.jar 或者<br>sun.boot.class.path 下的内容，用于提供JVM自身需要的类</p>
</blockquote>
</li>
<li><p>并没有继承ClassLoader，没有父加载器</p>
</li>
<li><p>加载扩展类和应用程序类加载器(ExtClassLoader &amp; AppClassLoader)，并制定他们的父加载器</p>
</li>
<li><p>出于安全考虑，只加载包名开头是 java javax sun 的类。</p>
</li>
</ul>
<h3 id="2-2-2-扩展类加载器"><a href="#2-2-2-扩展类加载器" class="headerlink" title="2.2.2 扩展类加载器"></a>2.2.2 扩展类加载器</h3><ul>
<li><p>用 Java 编写</p>
</li>
<li><p>派生于 ClassLoader，sun.misc.Launcher$ExtClassLoader</p>
</li>
<li><p>父加载器是 启动类加载器</p>
</li>
<li><p>从 java.ext.dirs系统属性指定的目录中加载，或者 加载 jre&#x2F;lib&#x2F;ext 下的类库。</p>
<blockquote>
<p>如果用户写的 jar文件放在这里，也被他加载。</p>
</blockquote>
</li>
</ul>
<h3 id="2-2-3-应用程序加载器"><a href="#2-2-3-应用程序加载器" class="headerlink" title="2.2.3 应用程序加载器"></a>2.2.3 应用程序加载器</h3><ul>
<li>Java 编写</li>
<li>派生于 ClassLoader， sun.misc.Launcher$AppClassLoader 实现</li>
<li>父加载器是 扩展类加载器</li>
<li>家在环境变量 classpath或系统属性 java.class.path目录下的类库</li>
<li>程序默认的类加载器，Java 应用程序都被他加载</li>
<li>调用 ClassLoader.getSystemClassLoader() 可以得到</li>
</ul>
<h3 id="2-2-4-自定义类加载"><a href="#2-2-4-自定义类加载" class="headerlink" title="2.2.4 自定义类加载"></a>2.2.4 自定义类加载</h3><ul>
<li>一般来说，类加载几乎都是上面三个 类加载器加载的，情况特殊我们可以用自己的。</li>
<li>什么时候需要自定义：<ul>
<li>隔离加载类 比如框架之间用 Jar包，为了相互不冲突，自定义类加载器</li>
<li>修改类的加载方式</li>
<li>扩展加载源，比如我们可以从数据库中加载</li>
<li>防止源码泄露，先对源码进行加密，然后自定义类加载器进行解密。</li>
</ul>
</li>
<li>如何自定义类加载器，以后再说，大致需要实现 继承 ClassLoader 重写 findClass</li>
</ul>
<h2 id="2-3-关于-ClassLoader"><a href="#2-3-关于-ClassLoader" class="headerlink" title="2.3 关于 ClassLoader"></a>2.3 关于 ClassLoader</h2><p>是一个抽象类，我们以后自己要实现类加载器的话可以继承这个类来实现一些我们自己的功能。</p>
<h1 id="3-双亲委派机制"><a href="#3-双亲委派机制" class="headerlink" title="3. 双亲委派机制"></a>3. 双亲委派机制</h1><p>一个类加载器接收到类加载请求后，并不会立马进行加载，而是把加载请求传给父加载器（虽然说父加载器，但是一直说 三个类加载器之间没有继承关系），然后一直递归，一直往上，最终给了 引导类加载器。如果父加载器可以完成加载，则返回结果，如果不能，再传回子加载器</p>
<p>举个例子：</p>
<p>加载我们的自定义类 User，首先AppClassLoader 收到加载请求，将请求发给ExtClassLoader，然后ExtClassLoader 再发给BootstrapClassLoader，BootstrapClassLoader 一看，我只负责加载 java javax 等，你这个 pri.entity.User 我不负责，将请求发回 ExtClassLoader，ext 也不管，则返回App，最终App进行加载。</p>
<p>再举个栗子：</p>
<p>我们自定义一个 java.lang.String，然后在别的地方 <code>String str = new String();</code> 那么加载的是哪个类，是我们自定义的，还是Java 的。根据这个机制，这个请求最终发给了 BootstrapClassLoader，那么很显然就会加载 系统的 String,而不是我们自己的String，因为我们自己的 String 需要 AppClassLoader 加载。</p>
<p>然后我们在我们自己的 String 里面定义main 方法，可不可3以运行？显然不行，因为执行main方法需要先进性类加载，直接加载 系统的 String。系统的String 很显然没有main</p>
<h2 id="3-1-优势"><a href="#3-1-优势" class="headerlink" title="3.1 优势"></a>3.1 优势</h2><ul>
<li>避免类的重复加载。</li>
<li>保护核心api不被破坏，比如上面的例子</li>
</ul>
<h2 id="3-2-如何判断两个Class-相同"><a href="#3-2-如何判断两个Class-相同" class="headerlink" title="3.2 如何判断两个Class 相同"></a>3.2 如何判断两个Class 相同</h2><ul>
<li>全限定命名一样</li>
<li>所用的类加载器一样</li>
</ul>
<h2 id="3-3-Java加载类的两种方式"><a href="#3-3-Java加载类的两种方式" class="headerlink" title="3.3 Java加载类的两种方式"></a>3.3 Java加载类的两种方式</h2><p>Java加载类就是两种方式：主动加载和被加载，下面是主动加载</p>
<ul>
<li>创建实例</li>
<li>访问静态变量或者赋值</li>
<li>调用静态方法</li>
<li>反射，比如 Class.forName()</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK7开始的同台语言支持，不知道啥意思</li>
</ul>
<p>除此之外，全是被动加载，被动加载不会进行初始化。我们上面说过，类加载经理加载链接初始化，只有主动加载一个类，这个类才会经历初始化过程，否则不会经历。那么不会初始化会导致什么后果？以后再说。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>OPTIONS请求BUG</title>
    <url>/2022/08/12/OPTIONS%E8%AF%B7%E6%B1%82BUG/</url>
    <content><![CDATA[<p>第一次做 Go 的项目，结果写 vue 前端的时候用的是 axios ，报错，一添加 header 就报错，这是为啥呢？</p>
<span id="more"></span>

<h1 id="1-症状"><a href="#1-症状" class="headerlink" title="1. 症状"></a>1. 症状</h1><p>什么个情况呢？我们 axios 设置了个请求拦截器，然后在拦截器里面设置请求头，把 token 放到 Authorization 请求头上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.<span class="property">headers</span>[<span class="string">&quot;Authorization&quot;</span>] = <span class="title function_">getToken</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>结果，这个请求就死活发不出去了，依次会发两个请求，第一次是 OPTIONS 第二次是 POST，但是无一例外报错，而且 chrome 浏览器贼傻逼，不告诉原因，就告诉我 NET:ERR。</p>
<p>一开始我以为是我拦截器的问题，然后今天没有使用拦截器，使用原始axios发了个请求，嘿，您猜怎么着，照样发不出去，然后定位错误，发现是 headers 的问题，只要我的 headers 带上 Authorization，那这请求铁定发布出去。都给我整麻了。</p>
<p>这次事故持续了近3个小时，期间崩溃了10次嚎啕大哭了9次晕厥了8次。</p>
<h1 id="2-定位"><a href="#2-定位" class="headerlink" title="2. 定位"></a>2. 定位</h1><p>发了两个请求，第一次是 OPTIONS，第二次才是 POST，所以初步认为这个 BUG 应该和 OPTIONS 这个请求有关系，所以我在服务端自己写了一个 OPTIONS 请求的处理器，直接给他返回字符串，嘿，您猜怎么着，即便如此，这个 OPTIONS 还是报错。</p>
<p>然后我打开了 firefox 浏览器，嘿，firefox 还是厚道，告诉我这么一串：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">CORS 预检响应的 &#x27;Access-Control-Allow-Headers&#x27;，不允许使用头 &#x27;contenttype&#x27;</span><br></pre></td></tr></table></figure>

<p>WTF? 火狐告诉我我这个请求头不允许？虽然这个请求头不是 Authorization 而是我写错的 contentType，但是还是给我提供了思路，很可能这个 Authorization 请求头是因为某种原因被 Ban 了。那么是出于什么原因？很可能就和这个 OPTIONS 有关。</p>
<p>所以我再次推测，可能是第一次 OPTIONS 请求询问了服务器，我下次的 POST 可以带哪些请求头啊？结果服务器告诉我：反正不能是 Authorization，结果下次 POST 请求，我带上 Authorization 就挂了。</p>
<h1 id="3-解决"><a href="#3-解决" class="headerlink" title="3. 解决"></a>3. 解决</h1><p>既然推测是这么回事，就得解决一下，因为我的服务器是 Beego 写的，所以我就查了一下 beego 解决 OPTIONS 请求的办法，真就查到了：</p>
<p><a href="https://cloud.tencent.com/developer/article/1719610">beego 解决 options</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> success = []<span class="type">byte</span>(<span class="string">&quot;SUPPORT OPTIONS&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> corsFunc = <span class="function"><span class="keyword">func</span><span class="params">(ctx *context.Context)</span></span> &#123;</span><br><span class="line">    origin := ctx.Input.Header(<span class="string">&quot;Origin&quot;</span>)</span><br><span class="line">    ctx.Output.Header(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;OPTIONS,DELETE,POST,GET,PUT,PATCH&quot;</span>)</span><br><span class="line">    ctx.Output.Header(<span class="string">&quot;Access-Control-Max-Age&quot;</span>, <span class="string">&quot;3600&quot;</span>)</span><br><span class="line">    ctx.Output.Header(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;X-Custom-Header,accept,Content-Type,Authorization&quot;</span>)</span><br><span class="line">    ctx.Output.Header(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>)</span><br><span class="line">    ctx.Output.Header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, origin)</span><br><span class="line">    <span class="keyword">if</span> ctx.Input.Method() == http.MethodOptions &#123;</span><br><span class="line">        <span class="comment">// options请求，返回200</span></span><br><span class="line">        ctx.Output.SetStatus(http.StatusOK)</span><br><span class="line">        _ = ctx.Output.Body(success)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    beego.InsertFilter(<span class="string">&quot;/*&quot;</span>, beego.BeforeRouter, corsFunc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我把这一段扔到了项目里，再试，嘿，真就行了。然后我再做了个测试，我把里面 Access-Control-Allow-Headers 里面的 Authorization 去掉了，然后再请求，果然，出现了以前的问题。</p>
<h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h1><p>很好，这么个恶心我好几个小时的 BUG 就这么被解决了，但是有这么个问题，为什么 axios 会发送一个 options 请求？我又去网上查了一下，查到个博客，这里直接复制：</p>
<p><a href="https://www.jianshu.com/p/9e52ca6b8818">axios 的 options请求</a></p>
<p><strong>简单请求</strong></p>
<p>满足下面两个条件的请求是简单请求：</p>
<p><strong>请求方式是以下三种之一：</strong> </p>
<ul>
<li>HEAD </li>
<li>GET </li>
<li>POST</li>
</ul>
<p><strong>HTTP的头信息不超出以下几种字段：</strong></p>
<ul>
<li>Accept </li>
<li>Accept-Language </li>
<li>Content-Language </li>
<li>Last-Event-ID </li>
<li>Content-Type</li>
</ul>
<p><strong>但是Content-Type的值，只限于三个值：</strong></p>
<ul>
<li>application&#x2F;x-www-form-urlencoded</li>
<li>multipart&#x2F;form-data</li>
<li>text&#x2F;plain</li>
</ul>
<p><strong>复杂请求</strong></p>
<p>非简单请求就是复杂请求。</p>
<p>复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为“预检”请求（preflight）。预检请求为OPTIONS请求，用于向服务器请求权限信息。预检请求被成功响应后，才会发出真实请求，携带真实数据。</p>
<p>axios默认请求就是application&#x2F;json,所以不需要自己加上头部（不需要在config中加headers），所以总是会发出options请求的，看看是不是配置的时候加了不必要的headers配置项。<br>另外，如果真的需要预检，后台也需要进行设置，允许options请求。</p>
<p>作者：LinkLiKang<br>链接：<a href="https://www.jianshu.com/p/9e52ca6b8818">https://www.jianshu.com/p/9e52ca6b8818</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>嗯哼，就这么回事，这个 BUG 就算过去了。</p>
]]></content>
      <categories>
        <category>bug</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>深入字符串</title>
    <url>/2022/06/02/String/</url>
    <content><![CDATA[<p>字符串，嗯，面试的重点，多少都会涉及。而且字符串看似简单，其实要深入JVM理解字符串还是有些难度的，所以这一章就来单独说一下字符串的小坑。</p>
<span id="more"></span>

<h1 id="1-String基础"><a href="#1-String基础" class="headerlink" title="1. String基础"></a>1. String基础</h1><h2 id="1-1-String基本特性"><a href="#1-1-String基本特性" class="headerlink" title="1.1 String基本特性"></a>1.1 String基本特性</h2><ul>
<li><p>String 不是基础数据类型，即便他能 String x &#x3D; “” 直接赋值</p>
</li>
<li><p>String 实现了 Comparable 和 Serializable，也就是可以序列化和比大小</p>
</li>
<li><p>String 被final 修饰不能继承</p>
</li>
<li><p>String 在 jdk8之前他的底层是char[] value,jdk9 以后修改成了byte[] value，为啥？</p>
</li>
</ul>
<h2 id="1-2-jdk8-9-对于String底层的修改"><a href="#1-2-jdk8-9-对于String底层的修改" class="headerlink" title="1.2 jdk8 9 对于String底层的修改"></a>1.2 jdk8 9 对于String底层的修改</h2><p>jdk8以前String底层是char数组，jdk9就变成了byte数组，为啥？</p>
<p>首先，可以去官网看：<u><span spellcheck="false" class="md-link md-pair-s"><a href="http://openjdk.java.net/jeps/254">JEP 254: Compact Strings</a></span></u> 里面的motivation详细说了，这里概括一下：</p>
<p>以前的java实现String 里面采用 char[] value的形式存储字符串，一个字符 占两个字节，然后String 是堆空间里面主要的存储单位，数量特别多。但是他们发现，大部分的字符串包含的都是一些 Latin-1(拉丁，简单理解，拼音) 字符，这些字符其实一个字节就可以表示了，也就是说，大部分情况下，字符串里面一半的空间都被浪费了。</p>
<p>那么问题又来了，有的时候的确要存非拉丁字符，比如汉字，这咋整，他们在String里面又存储了charset 字段用来保存这个字符的编码，按照编码来分配是一个字节存还是两个字节存。</p>
<p>凡是和String有关系的类，比如 StringBuilder StringBuffer 底层都变成了 byte[]。</p>
<h2 id="1-3-String-的不可变"><a href="#1-3-String-的不可变" class="headerlink" title="1.3 String 的不可变"></a>1.3 String 的不可变</h2><p>什么鬼，忘得特别干净，复习一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字面量赋值：  </span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 创建字符串，只要是这种通过字面量创建出来的字符串，他们的值都是存在字符串常量池中的，而且字符串常量池中不允许重复  </span></span><br><span class="line"><span class="comment">// 所以如果两个字符串通过字面量赋值相同，那么这两个字符串其实指向的是同一个地址，俩字符串的hashcode 相同。  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  </span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// 这里肯定是 true  </span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 如果对这种字符串进行重新赋值，他并不会修改常量池中的值，而是重新造一个值，然后改变指向，这就体现了字符串的不可变  </span></span><br><span class="line"><span class="comment">// 同理 字符串拼接，也是一个道理，并不是修改值，而是重新造一个值并修改指向  </span></span><br><span class="line"><span class="comment">// 包括 String.replace(old, new)，这个也是新造，不是修改。  </span></span><br><span class="line">s1 = <span class="string">&quot;hello&quot;</span>;  </span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// 这回就是 false，因为s1 已经改变了指向  </span></span><br><span class="line">​  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 下面这个，s 还是 hello，别问，不知道为啥，但是如果直接在main 方法里面设置 s = &quot;test&quot;，他是可以修改成功的  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);  </span><br><span class="line">    change(s);  </span><br><span class="line">    System.out.println(s);  </span><br><span class="line">&#125;  </span><br><span class="line">​  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String s)</span>&#123;  </span><br><span class="line">    s = <span class="string">&quot;test&quot;</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-字符串常量池"><a href="#1-4-字符串常量池" class="headerlink" title="1.4 字符串常量池"></a>1.4 字符串常量池</h2><ul>
<li><p>字符串常量池：String Pool 或者也叫 StringTable 是一个固定大小的HashMap，HashMap 总学过吧。默认大小是 1009 (jdk6)，如果存入的字符串过多，那么得到的HashKey也就会很多，从而导致链表过长，然后效率降低。</p>
</li>
<li><p>使用 <code>-XX:StringTableSize</code> 来指定常量池的大小。</p>
</li>
<li><p>jdk6中默认是 1009，固定的，可以通过参数修改，如果字符串过多则效率降低</p>
</li>
<li><p>jdk7以后默认就是60013，1009 是设置的最小长度</p>
</li>
</ul>
<h1 id="2-字符串拼接"><a href="#2-字符串拼接" class="headerlink" title="2. 字符串拼接"></a>2. 字符串拼接</h1><p>详细的说一说字符串拼接的操作, 当然也是介绍概念：</p>
<ul>
<li><p>常量和常量拼接结果在常量池，原理是编译期优化</p>
</li>
<li><p>常量池中不会重复</p>
</li>
<li><p>只要拼接的东西里面有一个是变量，那么拼接结果就放在堆里面，变量拼接原理是StringBuilder</p>
</li>
<li><p>如果拼接的结果调用inturn() 方法，则主动将常量池中还没有的字符串对象放入池中，返回地址</p>
</li>
</ul>
<p>然后我们一个一个说：</p>
<h2 id="2-1-常量拼接常量结果在常量池"><a href="#2-1-常量拼接常量结果在常量池" class="headerlink" title="2.1 常量拼接常量结果在常量池"></a>2.1 常量拼接常量结果在常量池</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s1 是常量拼接字符串，所以他的结果在常量池里面，所以s1 == s2 是 true  </span></span><br><span class="line"><span class="comment">// 而且，如果我们把编译出来的class文件在idea里面打开，让idea 给我们做反编译，我们就会看到  </span></span><br><span class="line"><span class="comment">// s1 里面写的根本不是拼接操作，而是直接 String s1 = &quot;abc&quot;;  </span></span><br><span class="line"><span class="comment">// 这个就是编译期优化，他在编译的时候，发现你常量拼接，他就直接给你转化成拼接结果了。  </span></span><br><span class="line">​  </span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>+<span class="string">&quot;c&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  </span><br><span class="line">System.out.println(s1 == s2);  </span><br><span class="line">System.out.println(s1.equals(s2));</span><br></pre></td></tr></table></figure>

<h2 id="2-2-拼接变量结果入堆"><a href="#2-2-拼接变量结果入堆" class="headerlink" title="2.2 拼接变量结果入堆"></a>2.2 拼接变量结果入堆</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;  </span><br><span class="line">​  </span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javahadoop&quot;</span>;  </span><br><span class="line"><span class="comment">// 什么是编译期优化，就是两个字面值的字符串做拼接，在javac编译的时候就已经可以知道拼接结果了</span></span><br><span class="line"><span class="comment">// 那么他就会在编译的时候就给你把值赋好</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span> + <span class="string">&quot;hadoop&quot;</span>; <span class="comment">// 编译期优化，等同于 s4 = &quot;javahadoop&quot;;  </span></span><br><span class="line"></span><br><span class="line">s3 == s4  <span class="comment">// true，且 s3 和 s4 都指向了字符串常量池中的javahadoop</span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 这里拼接出现了变量，如果我们去看字节码就会发现，他这里会创建一个StringBuilder给你进行拼接操作</span></span><br><span class="line"><span class="comment">// 然后拼接完成后给你return StringBuilder.toString(); </span></span><br><span class="line"><span class="comment">// 然后这个 toString() 方法会new String().</span></span><br><span class="line"><span class="comment">// 所以四舍五入就相当于在堆中 new String(),拼接结果位 javahadoop  </span></span><br><span class="line"><span class="comment">// 也就是，下面三个，都是独立的对象，那肯定是不相等了。  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span> + s2;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;  </span><br><span class="line"></span><br><span class="line">s3 == s5; <span class="comment">// false，而且s3和 s5 s6 s7 都不相等，愿意你很简单，一个是字符串常量池，另外的是堆中对象</span></span><br><span class="line">s5 == s6; <span class="comment">// false  </span></span><br><span class="line">s5 == s7; <span class="comment">// false  </span></span><br><span class="line">s6 == s7; <span class="comment">// false</span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// s6 是 javahadoop 是吧，很好，intern()就是判断常量池里面有没有 javahadoop，  </span></span><br><span class="line"><span class="comment">// 如果存在，则返回他的地址，如果不存在，则在常量池中创建一个，然后返回他的地址。  </span></span><br><span class="line"><span class="comment">// 至于这个intern方法后面会专门说。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();   </span><br><span class="line">​  </span><br><span class="line">s3 == s8; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="3-变量拼接的底层原理"><a href="#3-变量拼接的底层原理" class="headerlink" title="3. 变量拼接的底层原理"></a>3. 变量拼接的底层原理</h1><p>我们写一个变量拼接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="string">&quot;def&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">a3</span> <span class="operator">=</span> a1 + a2;</span><br></pre></td></tr></table></figure>

<p>然后我们看他的字节码文件，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">00 ldc #10 &lt;abc&gt;</span><br><span class="line">02 astore_0</span><br><span class="line">03 ldc #11 &lt;def&gt;</span><br><span class="line">05 astore_1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面就对应a1 和 a2 的赋值操作，不说了，主要是下面：</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先new一个StringBuilder</span></span><br><span class="line">06 new #12 &lt;java/lang/StringBuilder&gt;</span><br><span class="line">09 dup</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后调用构造函数</span></span><br><span class="line">10 invokespecial #13 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取局表的0位也就是 a1</span></span><br><span class="line">13 aload_0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用了StringBuilder的 append 方法，把a1传入</span></span><br><span class="line">14 invokevirtual #14 &lt;java/lang/StringBuilder.append :...;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取局表1位也就是a2</span></span><br><span class="line">17 aload_1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同理调用append方法</span></span><br><span class="line">18 invokevirtual #14 &lt;java/lang/StringBuilder.append : ...;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再调用toString 方法,这个toString 方法比较特殊，他的实现是 <span class="built_in">return</span> new String();</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所以 toString 约等于 new String() 为啥说约等于，以后再说。</span></span><br><span class="line">21 invokevirtual #15 &lt;java/lang/StringBuilder.toString : ...;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把结果存储到局表2位</span></span><br><span class="line">24 astore_2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">剩下就是输出了</span></span><br><span class="line">25 getstatic #2 &lt;java/lang/System.out :...;&gt;</span><br><span class="line">28 aload_2</span><br></pre></td></tr></table></figure>

<p>注意，用StringBuilder底层去拼接的，必须是变量，可不是说必须是引用，举个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span> + <span class="string">&quot;def&quot;</span>;  </span><br><span class="line">​  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 这个，它仅仅是应用，而不是变量，所以这种情况下他也不会用StringBuilder来构建  </span></span><br><span class="line"><span class="comment">// 所以这里仍旧会进行编译期优化  </span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;  </span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;def&quot;</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + s2;</span><br></pre></td></tr></table></figure>

<h2 id="3-1-执行效率问题"><a href="#3-1-执行效率问题" class="headerlink" title="3.1 执行效率问题"></a>3.1 执行效率问题</h2><p>直接创建StringBuilder来拼接肯定是快，而且快很多，所以我们要字符串拼接我们不如直接创建一个StringBuilder或者StringBuffer来得实在。</p>
<p>默认情况下 StringBuilder的容量是16，如果不够了会进行扩容，也消耗性能，所以我们尽可能的给他确定一下容量。</p>
<h2 id="3-2-创建对象数"><a href="#3-2-创建对象数" class="headerlink" title="3.2 创建对象数"></a>3.2 创建对象数</h2><p>我们创建一个字符串：<code>new String(&quot;abc&quot;)</code>，这行代码创建了几个对象。很好，遇事不决字节码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一步，创建一个 String，也就是 new</span></span><br><span class="line">00 new #16 &lt;java/lang/String&gt;</span><br><span class="line">03 dup</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后，在常量池里面创建字符串 <span class="string">&quot;abc&quot;</span>,然后把 abc 传入 构造函数</span></span><br><span class="line">04 ldc #10 &lt;abc&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用构造，根据常量池里面的字符串在堆中创建对象</span></span><br><span class="line">06 invokespecial #17 &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;</span><br><span class="line">09 astore_0</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure>

<p>所以这么来看创建了几个对象？很显然是两个：一个是堆中的String，一个是常量池中的abc。</p>
<p>然后再说一下这个常量池的问题，为啥这里创建String的时候会在常量池中也创建一个？我个人觉得是因为我们传入的是一个字面量的字符串，所以他会把这个字面量存入常量池。</p>
<h2 id="3-3-更高级的对象数问题"><a href="#3-3-更高级的对象数问题" class="headerlink" title="3.3 更高级的对象数问题"></a>3.3 更高级的对象数问题</h2><p>一行代码：<code>String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);</code> ，这行代码创建了几个对象。同理，于是不决字节码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 创建 StringBuilder 对象，用来待会的拼接操作</span></span><br><span class="line">00 new #5 &lt;java/lang/StringBuilder&gt;</span><br><span class="line">03 dup</span><br><span class="line">04 invokespecial #6 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.创建 String 对象，对应 new String(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line">07 new #2 &lt;java/lang/String&gt;</span><br><span class="line">10 dup</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.在字符串常量池里面创建 <span class="string">&quot;a&quot;</span></span></span><br><span class="line">11 ldc #7 &lt;a&gt;</span><br><span class="line">13 invokespecial #4 &lt;java/lang/String.&lt;init&gt; :...&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里 StringBuilder 进行了 append操作。</span></span><br><span class="line">16 invokevirtual #8 &lt;java/lang/StringBuilder.append :...;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.创建String对象，对应 new String(<span class="string">&quot;b&quot;</span>);</span></span><br><span class="line">19 new #2 &lt;java/lang/String&gt;</span><br><span class="line">22 dup</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5.常量池里面创建 <span class="string">&quot;b&quot;</span></span></span><br><span class="line">23 ldc #9 &lt;b&gt;</span><br><span class="line">25 invokespecial #4 &lt;java/lang/String.&lt;init&gt; : ...&gt;</span><br><span class="line">28 invokevirtual #8 &lt;java/lang/StringBuilder.append :  ...;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6.StringBuilder 调用 toString 方法，这里又创建一个 String</span></span><br><span class="line">31 invokevirtual #10 &lt;java/lang/StringBuilder.toString : ...;&gt;</span><br><span class="line">34 astore_0</span><br><span class="line">35 return</span><br></pre></td></tr></table></figure>

<p>根据上面的解析，可以知道，一个语句总共创建了6个对象，只得注意的是，最终结果是 “ab”，但是直到最后 常量池里面也没有 “ab” 这个字符串，虽然说在toString 里面创建了字符串，通过 new String() ，我们之前说 new String(xxx) 会在pool中创建xxx，但是这里为啥就不创建了？我觉得是因为构造函数里面传入的不是字面量了，而是变量，所以不会再创建ab常量了。</p>
<h1 id="4-intern方法"><a href="#4-intern方法" class="headerlink" title="4. intern方法"></a>4. intern方法</h1><p>可以去String类里面看看他的注释，全英语的，反正我看不懂，所以下面大致给说一下</p>
<h2 id="intern-方法介绍"><a href="#intern-方法介绍" class="headerlink" title="intern 方法介绍"></a>intern 方法介绍</h2><p>首先，本地方法。</p>
<p>一个不是用字面量创建的字符串(注意，不是字面量创建的)，调用这个方法，他就会去 pool 里面找，有没有和当前字符串相等的字符串常量，如果有，则返回这个字符串的引用；如果没有，则在pool里面创建一个，然后返回引用。</p>
<p>如果有两个字符串 s t, s.intern() &#x3D;&#x3D; t.intern() 成立，当且仅当 s.equals(t) 成立。</p>
<p>举个例子：</p>
<p><code>String s = new String(&quot;hello world&quot;).intern()</code></p>
<p>这行代码就是：堆中创建了一个 字符串 “hello world”，然后调用 intern 去看 StringTable 里面有没有 helloworld，如果没有，则创建一个，然后返回引用给s。</p>
<p>再看一个例子：</p>
<p><code>(&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;</code></p>
<p>这个必然是 true，因为在 最前面拼接的时候，就已经在pool里面创建了”abc”。</p>
<p>所以总结一下，就是去字符串常量池中找有没有当前字符串的字面量常量，如果有则返回，如果没有则创建后返回。总之执行完这个方法，可以保证返回的东西指向了字符串常量池。</p>
<h1 id="5-一道String面试题"><a href="#5-一道String面试题" class="headerlink" title="5. 一道String面试题"></a>5. 一道String面试题</h1><p>上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">// 首先，创建了 s1，堆中一个，pool中一个，都是 &quot;a&quot;  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 这条代码是在pool中创建对象，但是已经有了，所以这行没用，同时他没有接收，s1 不变。  </span></span><br><span class="line">s1.intern();  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 又创建了一个对象，指向pool中的 &quot;a&quot;  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 所以这个没有异议，肯定是 false  </span></span><br><span class="line"><span class="comment">// jdk6/7/8   false  </span></span><br><span class="line">System.out.println(s1 == s2);            </span><br><span class="line">​  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 这里就开始扯淡了，看这行代码，创建了一堆对象，常量池中的 &quot;a&quot; 堆中的 &quot;a&quot;,  </span></span><br><span class="line"><span class="comment">// s3 是堆中的 aa，但常量池中可没有aa，老生常谈了，上面就重点说过。  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 然后在常量池中创建 &quot;aa&quot;,这里就开始有区别了，  </span></span><br><span class="line"><span class="comment">// jdk6 中，常量池在永久代里面，和堆没半毛钱关系，所以就是你想的那样，在pool中创建了 &quot;aa&quot;  </span></span><br><span class="line"><span class="comment">// 然后s4是常量池中的，s3 是堆中的，没关系，所以结果是 false。  </span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 而jdk7/8 不一样，jdk7/8的常量池在堆中，他在常量池创建对象的时候，一看，哎，  </span></span><br><span class="line"><span class="comment">// 堆里面已经有了一个对象(注意是堆中，不是常量池中)，所以他为了节省资源，他不会在常量池中再次创建对象，  </span></span><br><span class="line"><span class="comment">// 而是在常量池中创建一个引用，这个引用指向堆中，在这里就是s3,  </span></span><br><span class="line"><span class="comment">// 最后的结果就是，s4 指向常量池中的那个值，结果常量池中的值指向了s3，相当于 s4 变相的指向了 s3.  </span></span><br><span class="line"><span class="comment">// 所以结果是 true  </span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 但是注意，jdk7/8 中这种从常量池指向堆这种行为，只有 intern() 才会触发，  </span></span><br><span class="line"><span class="comment">// 你正常的 s5 = &quot;aa&quot;; 他是不会触发这种指向的，他还是会正常的在常量池中创建。  </span></span><br><span class="line">s3.intern();  </span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;  </span><br><span class="line"><span class="comment">// jdk6 false   jdk7/8 true  </span></span><br><span class="line">System.out.println(s3 == s4);</span><br></pre></td></tr></table></figure>

<h2 id="变式"><a href="#变式" class="headerlink" title="变式"></a>变式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这回的结果就是 false，原因很简单，根据上面的叙述，常量池引用堆只有intern才会触发，  </span></span><br><span class="line"><span class="comment">// 这里改变顺序，先创建 s2，这里就会在常量池中创建 &quot;aa&quot;,然后intern() 就会发现已经存在 &quot;aa&quot;，就不会指向堆。  </span></span><br><span class="line"><span class="comment">// 所以 s1 和 s2 是两个不同的对象，结果是false  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);  </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;  </span><br><span class="line">s1.intern();  </span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>

<h2 id="总结-intern-的使用："><a href="#总结-intern-的使用：" class="headerlink" title="总结 intern 的使用："></a>总结 intern 的使用：</h2><h3 id="jdk6"><a href="#jdk6" class="headerlink" title="jdk6"></a>jdk6</h3><ul>
<li><p>如果池中有，则不会创建，而是返回地址</p>
</li>
<li><p>池中没有，把当前字符串拷贝一份放入池中</p>
</li>
</ul>
<h3 id="jdk7-x2F-8"><a href="#jdk7-x2F-8" class="headerlink" title="jdk7&#x2F;8"></a>jdk7&#x2F;8</h3><ul>
<li><p>池中有，则返回地址，和上面一样</p>
</li>
<li><p>池中没有，则拷贝当前字符串的地址放到池中，让池指向堆，节约空间，然后返回地址。</p>
</li>
</ul>
<h1 id="6-G1的String去重行为"><a href="#6-G1的String去重行为" class="headerlink" title="6. G1的String去重行为"></a>6. G1的String去重行为</h1><blockquote>
<p>首先说一下G1，简单说，就是jdk7以后jvm里面的一个垃圾回收器。</p>
<p>这个gc并不分minor gc 还是 major gc，我查了一下，他似乎是一个整体的垃圾回收器，然后里面细分为回收年轻代 老年代等的行为。所以G1(G First) 就是一个全局的垃圾回收器。</p>
</blockquote>
<p>明确一个概念，这里的去重，当然不是指的字符串常量池中去重，pool中本来就没有重复对象，这个去重指的是堆中去重。</p>
<h2 id="6-1-去重的背景"><a href="#6-1-去重的背景" class="headerlink" title="6.1 去重的背景"></a>6.1 去重的背景</h2><p>对于许多java应用，经过测试发现如下：</p>
<ul>
<li><p>堆存活数据集合里面String 对象占25%</p>
</li>
<li><p>堆存活数据集合里面重复的String 占 13%</p>
</li>
<li><p>String 平均长度 45</p>
</li>
</ul>
<h2 id="6-2-实现"><a href="#6-2-实现" class="headerlink" title="6.2 实现"></a>6.2 实现</h2><ul>
<li><p>当垃圾收集器工作时会访问堆上的存活对象，检查是否是候选的去重字符串</p>
</li>
<li><p>如果是，把字符串加入一个队列，一个去重的后台线程对这个队列进行处理，处理就是删除队列元素然后尝试进行去重操作</p>
</li>
<li><p>使用一个hashtable来记录所有被String使用的不重复的char数组(就是String底层的char数组，去重主要是去重这个)，进行去重的时候会去查这个char数组，来检查堆上是否已经存在了一个一模一样的char数组。</p>
</li>
<li><p>如果存在，那么当前String就会改为引用已有的那个char数组，它本身的那个char数组会被释放。</p>
</li>
<li><p>如果不存在，那么当前char数组进入hashtable，然后对下一个String去重。</p>
</li>
</ul>
<h2 id="6-3-开启"><a href="#6-3-开启" class="headerlink" title="6.3 开启"></a>6.3 开启</h2><p>UseStringDeduplication(boolean) 开启String去重，默认是不开启的。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>字节码指令</title>
    <url>/2022/06/13/bytecode-command/</url>
    <content><![CDATA[<p>这章就是具体的各种字节码指令，深入的说一下每个指令都是干嘛的。</p>
<span id="more"></span>

<h1 id="1-加载与存储指令"><a href="#1-加载与存储指令" class="headerlink" title="1. 加载与存储指令"></a>1. 加载与存储指令</h1><p>因为我们之前说过了，数据的来源可以是局部变量表，常量池，方法调用，所以这里还得区分。</p>
<h2 id="1-1-局部变量压栈指令"><a href="#1-1-局部变量压栈指令" class="headerlink" title="1.1 局部变量压栈指令"></a>1.1 局部变量压栈指令</h2><p>从局部变量表中的取得相应的数据，压入操作数栈，大体可以分为两类：</p>
<ul>
<li><p>xload (x 可以是 i l f d a)</p>
</li>
<li><p>xload&lt;_n&gt; (n 从 0 - 3)</p>
</li>
</ul>
<p>为啥要分出两个，_n 有啥用？很简单，根据概率来说，xload 0 1 2 3 用的最多，所以封装成了 xload_0 1 2 3.在字节码文件中，一个指令只有一个字节，而操作数2个字节，用 xload_n可以省地方。</p>
<p>然后这里面涉及到了局部变量表，这里复习一下：局部变量表里面有槽位，一个槽slot是4个字节，然后如果我们把long放进去，那long就是占两个slot，比如 0 位是this，1位是long，那3位就是int，没有2了，1 2 都被long占用了。</p>
<p>然后具体说说后面的操作数，现在有一个指令: xload 5，那他就是把局部变量表中index&#x3D;5的东西，压入栈。注意，是index&#x3D;5，索引为5的局表数据，看好了，可不是局表里面第一列那个数字，那是个数。</p>
<h2 id="1-2-常量入栈指令"><a href="#1-2-常量入栈指令" class="headerlink" title="1.2 常量入栈指令"></a>1.2 常量入栈指令</h2><p>指令const系列：这个命令用于特定常量压操作数栈，注意是特定常量，这个常量直接写在指令中，且后面没有操作数，注意这个很重要，const指令没有操作数，而且这个常量得注意，不是说非得是 final 修饰的常量，字面量也算是这里的常量，我们定义一个字面量 int i &#x3D; 10 那这里也会用这些指令进行压栈操作。具体指令如下：</p>
<ul>
<li><p>iconst_i (i -&gt; -1(m1) 到 5)</p>
</li>
<li><p>lconst_l (l -&gt; 0到1)</p>
</li>
<li><p>fconst_f (f -&gt; 0 到 2)</p>
</li>
<li><p>dconst_d (d -&gt; 0 到 1)</p>
</li>
<li><p>aconst_null (压null)</p>
</li>
</ul>
<p>是的，这些数据范围没有任何规律，别问为啥，反正就是这样。</p>
<p>比如，将常量 2 压入栈，那就是 iconst_2，那压6呢？iconst 6么，我们之前说了，const系列指令没有操作数，所以显然不行。这里得用另外一个系列指令：push系列指令。</p>
<p>指令 push 系列：主要就是 bipush 和 sipush，主要就是接收数据类型不同，bipush接收8位整数压栈，sipush接收16位整数压栈。(128就已经是16位了)，具体范围就是 bipush：-128 - 127. sipush：-32768 - 32767</p>
<p>如果还是不行，那就可以使用 ldc 指令，这个指令是干嘛的呢，他接受一个8位参数，这个参数指向常量池中 int float String 索引，然后将常量池中的指定内容压入栈。如果索引比较大，可以使用 ldc_w指令，接受两个8位参数，仅仅是索引范围变大了而已。如果压入 long double，那就是用 ldc2_w，怎么理解呢，粗略的理解成double 和 long 占两个槽位吧。</p>
<p>三个的区别就是 const -&gt; push -&gt; ldc 范围依次增大。</p>
<h2 id="1-3-出栈装入局部变量表指令"><a href="#1-3-出栈装入局部变量表指令" class="headerlink" title="1.3 出栈装入局部变量表指令"></a>1.3 出栈装入局部变量表指令</h2><p>首先我先猜测一下，一般来说数据不会直接装入局表，除非是方法的形参已经实例方法的this。一般来说局部变量都是先进入操作数栈，再从栈出来进入局表，大致应该是啊。</p>
<p>装入局表指令 store 系列：</p>
<ul>
<li><p>xstore&lt;_n&gt; 同理x可以是 i l f d a. n可以是 0 - 3</p>
</li>
<li><p>xstore</p>
</li>
</ul>
<p>这个命令的意思是，把操作数栈 栈顶的元素，弹出，然后放入局部变量表index 为 n 的地方。注意，始终弹得是栈顶元素。</p>
<p>当然了，有特殊的东西，比如存入数组这种的，去看尚硅谷的手册，我这里不提供了。</p>
<h1 id="2-算数指令"><a href="#2-算数指令" class="headerlink" title="2. 算数指令"></a>2. 算数指令</h1><p>加法指令：iadd，ladd，fadd，dadd</p>
<p>减法指令：isub，lsub，fsub，dsub</p>
<p>乘法指令：imul，lmul，fmul，dmul</p>
<p>除法指令：idiv，ldiv，fdiv，ddiv</p>
<p>取余指令：irem，lrem，frem，drem # remainder</p>
<p>取反指令：ineg，lneg，fneg，dneg # negation</p>
<p>自增指令：iinc xx(局表index) by xx(增加的具体数值)</p>
<p>需要注意的是，前面的很多指令，比如 add，div这种，其实是把操作数栈中的栈顶两个数，弹出，运算，再压栈，所以没有操作数。但是比较特殊的就是 iinc，比如我们 <code>int i = 0; int j = i + 10;</code> 这里就会用到自增，int j &#x3D; i + 10的指令就是 <code>iinc i在局表的位置 by 10</code>.</p>
<h1 id="3-数据类型转化"><a href="#3-数据类型转化" class="headerlink" title="3. 数据类型转化"></a>3. 数据类型转化</h1><p>基本格式很简单，就是 x2y，x y 分别代表俩类型呗，然后 to 呗，很简单，然后我们细分一下。</p>
<p>首先，根据转化的类型，分为两种：宽化数据类型转换，窄化数据类型转换，其实很简单，就是 小范围到大范围 和 大范围到小范围，我们先说宽化：</p>
<h2 id="3-1-宽化数据类型转换"><a href="#3-1-宽化数据类型转换" class="headerlink" title="3.1 宽化数据类型转换"></a>3.1 宽化数据类型转换</h2><ul>
<li><p>int 到大范围：i2l, i2f, i2d</p>
</li>
<li><p>long 到大范围：l2f, l2d</p>
</li>
<li><p>float 到大范围：f2d</p>
</li>
</ul>
<p>说白了就是： int –&gt; long –&gt; float –&gt; double，这个也就是自动类型转换，虽然你的代码没有体现任何的类型转换，但是字节码会给你加上这部分的。</p>
<h2 id="3-2-精度问题"><a href="#3-2-精度问题" class="headerlink" title="3.2 精度问题"></a>3.2 精度问题</h2><p>既然这里宽数据类型转换，那就肯定要涉及到精度问题：</p>
<ul>
<li><p>首先 int 转换为 long，double 不会发生精度丢失。</p>
</li>
<li><p>int 或者 long 转换为 float，或者 long 转化成 double，都有可能造成精度丢失，可能会丢失最低有效位上的某些值，转化后的浮点数值是根据 IEEE754最接近舍入模式所得到的正确整数值。</p>
</li>
</ul>
<p>这里举个例子，有如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">123123123</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">System.out.println(j);</span><br></pre></td></tr></table></figure>

<p>这里的 j 就是 1.2312312E8，也就是 123123120。</p>
<h2 id="3-3-关于-byte-short-char-的问题"><a href="#3-3-关于-byte-short-char-的问题" class="headerlink" title="3.3 关于 byte short char 的问题"></a>3.3 关于 byte short char 的问题</h2><p>是的，你没有看到任何关于 byte short char 的转换指令，为啥？因为压根就没有，比如 byte -&gt; long，其实jvm底层是用的 i2l 来实现的，JVM 肯定会把 byte short long 当做int处理。</p>
<p>至于为什么这么设计，因为在局部变量表中一个slot就是4个字节的，或者说32bit，那你这个 byte short long 存进去，那不还是用int的slot来存么，那在底层就完全没有必要区分byte short char了，而且，如果再设计这些指令，指令集可就不够了，毕竟一个指令就是一个字节，所以最多只有256 个指令。</p>
<h2 id="3-4-窄化类型转换"><a href="#3-4-窄化类型转换" class="headerlink" title="3.4 窄化类型转换"></a>3.4 窄化类型转换</h2><p>说的好高级啊，其实就是强制类型转化，把大范围数据类型强制转化为小范围</p>
<ul>
<li><p>int 转化为 byte short char：i2b, i2s, i2c</p>
</li>
<li><p>long转化为 int：l2i</p>
</li>
<li><p>float 转化为 int 或者 long：f2i, f2l</p>
</li>
<li><p>double 转化为 int, long, float：d2i, d2l, d2f</p>
</li>
<li><p>如果是 float 或者 long 转化为 byte 这种，没有直接的指令支持，那就只好两步走：f2i + i2b</p>
</li>
<li><p>如果是 double -&gt; byte，肯定不会 d2f, f2i, i2b, 直接就是 d2i, i2b。一般来说转化最多就是两步</p>
</li>
</ul>
<p>这个也会有精度损失问题，而且很有可能出现精度损失，但是不管精度损失成啥样，都不会抛出异常，特殊的，如果是 byte 转化为 short，直接就是 i2s，没有b2i这一说啊记着。</p>
<h2 id="3-5-窄化的特殊情况："><a href="#3-5-窄化的特殊情况：" class="headerlink" title="3.5 窄化的特殊情况："></a>3.5 窄化的特殊情况：</h2><p>当一个浮点数转化为整数时，遵循以下规则：</p>
<ul>
<li><p>浮点数是 NaN，转化结果就是 int 或者 long 的0</p>
</li>
<li><p>如果浮点数不是无穷大，那没啥好说的，直接取舍就行了</p>
</li>
</ul>
<p>当一个double转化为 float的时候：</p>
<ul>
<li><p>double如果特别接近0，接近到float都没法表示了，转化结果就为正负0</p>
</li>
<li><p>如果double是无穷大，float没法表示，结果就是 float的正负无穷大 Infinity</p>
</li>
<li><p>如果double是NaN，那float转化完也是NaN</p>
</li>
</ul>
<p>那当double转化为 long 或者 int 呢，如果double大到int long 没法表示，那int 和long 就会被转化为他们所能表示的最大值。</p>
<h1 id="4-对象创建与访问指令"><a href="#4-对象创建与访问指令" class="headerlink" title="4. 对象创建与访问指令"></a>4. 对象创建与访问指令</h1><p>因为 Java是面向对象的语言，所以在字节码层面就对对象做了非常好的支持，有很多指令都是用于对象的。同时对象又分出两类，一类就是类的实例，另一类就是数组，各种各样的数组。</p>
<h2 id="4-1-对象创建指令"><a href="#4-1-对象创建指令" class="headerlink" title="4.1 对象创建指令"></a>4.1 对象创建指令</h2><p>分为两种，创建类实例和创建数组。</p>
<ul>
<li><p>创建类实例：new，操作码就是new，操作数是一个指向常量池的索引，这个索引就是具体的类全限定名</p>
</li>
<li><p>创建数组：newarray 创建基本数据类型数组，anewarray 创建引用数据类型数组，multianewarray 创建多维数组，如果是基本数据类型数组，后面的操作数就是数组长度，如果是引用数据类型，操作数就是指向常量池的索引，具体就是你引用的类型的全限定命名。</p>
</li>
</ul>
<p>创建完成后，自动把创建好的对象压入操作数栈。</p>
<p>关于数组的创建这里，有点坑，就是 关于 multianewarray这个指令，什么时候会用这个指令呢？就是你多维数组的维数完全确定，才会用这个指令，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[][] s1 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>][<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 这里的指令是 multianewarray</span></span><br><span class="line"></span><br><span class="line">String[][] s2 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>][];</span><br><span class="line"><span class="comment">// 这里的指令是 anewarray</span></span><br></pre></td></tr></table></figure>

<p>至于为啥，如果你的维数不确定，那JVM只能知道你创建了一个一维数组，但是一维数组里面的数组长度是多少JVM不知道，所以JVM不确定你里面的是不是数组，只有维数确定的情况下，JVM才能肯定你是要创建一个多维数组，才给你用 multianewarray 这个指令</p>
<h2 id="4-2-类成员-字段-的访问指令"><a href="#4-2-类成员-字段-的访问指令" class="headerlink" title="4.2 类成员(字段)的访问指令"></a>4.2 类成员(字段)的访问指令</h2><p>这里只针对类里面的字段，对于数组的还有专门的指令。</p>
<ul>
<li><p>访问类字段：getstatic，putstatic。分别代表 把类字段压入操作数栈，和 给类字段赋值。</p>
</li>
<li><p>访问类实例字段：getfield，putfield。代表的东西和上面一样。</p>
</li>
</ul>
<p>get 这个指令没啥好说的其实，就是后面跟这个常量池索引，把响应的内容（也就是字段信息，fieldref）压入操作数栈。</p>
<p>put 这个还真得说说，看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123; id = <span class="number">10</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">order.id = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// new #x &lt;....Order&gt;</span></span><br><span class="line"><span class="comment">// dup</span></span><br><span class="line"><span class="comment">// invokespecial #x &lt;....Order.&lt;init&gt;</span></span><br><span class="line"><span class="comment">// astore_1</span></span><br><span class="line"><span class="comment">// aload_1</span></span><br><span class="line"><span class="comment">// bipush 20</span></span><br><span class="line"><span class="comment">// putfield #x &lt;...Order.id&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后就是 putfield #x，所以这个putfield到底是怎么运作的？</p>
<p>我们在给 id 赋值的之前，操作数栈栈顶就是order对象的地址（为了省事，以后直接说对象），然后赋值的时候又压入操作数栈 20，然后putfield，putfield这个时候就会把栈里面的前两个东西弹出来，根据后面的操作数（一个fieldref_info）确定要给对象的哪个字段赋值，然后就会给弹出来的第二个对象的相应字段赋上第一个弹出来的值。</p>
<p>说人话，就是现在操作数栈里有一个对象和一个待赋的值，然后putfield给他俩弹出来，根据接收的操作数，就给对象的响应字段赋上那个值。</p>
<p>注意，这两种指令：getstatic 和 putstatic 指令，他们的操作数都是一个 fieldref_info，表示要给哪个字段赋值或者取出，但是具体执行这个操作的对象，以及要被赋的值，都是从操作数栈中弹出来的。</p>
<h2 id="4-3-数组元素操作指令"><a href="#4-3-数组元素操作指令" class="headerlink" title="4.3 数组元素操作指令"></a>4.3 数组元素操作指令</h2><ul>
<li>把数组元素压入操作数栈指令：baload, saload, caload, iaload, laload, faload, daload, aaload，首先 aload 代表 arrayLoad，然后这些首字母分别代表：byte short char int long float double 引用。</li>
</ul>
<p>xaload系列的指令需要从操作数栈中弹出2个值，分别是：数组元素索引（int），数组引用，然后他就会把指定数组里面的指定索引的元素对应的值重新压回操作数栈。</p>
<ul>
<li>把操作数栈的值赋值给数组元素：bastore, castore, sastore, iastore, lastore, fastore, dastore, aastore，和上面差不多，不多解释。</li>
</ul>
<p>这个xastore系列指令需要从操作数栈弹出3个值，分别是（按顺序）：待赋的值，数组元素的引用（int），数组引用。astore指令就会给对应的数组的指定索引的元素赋上对应的值。</p>
<ul>
<li>获取数组长度：arraylength，也没有操作数，从操作数栈栈顶弹出数组引用，获取长度，然后把长度（int）重新压回操作数栈。</li>
</ul>
<p>这两类指令可都没有操作数，只有一个操作码，操作数全都是从操作数里弹出来的。</p>
<p>还有就是上面的那些数据类型没有boolean，很简单，boolean数组用的指令也是 baload和bastore。</p>
<h2 id="4-4-类型检查指令"><a href="#4-4-类型检查指令" class="headerlink" title="4.4 类型检查指令"></a>4.4 类型检查指令</h2><p>Java语法层面有instanceof 关键字，就是判断一个对象是不是一个类的实例，如果是，那就可以强制类型转换，那么强制转换在JVM层面怎么执行的？</p>
<ul>
<li><p>instanceof 指令：跟着一个操作数，这个操作数是一个常量索引，一个类名，他会从操作数栈中弹出栈顶的实例引用，然后把弹出的引用和操作数的类型作对比。如果满足，把true压入操作数栈，如果不满足，压入false。（其实我也不知道他到底最后压回栈的是啥，姑且说是true&#x2F;false）。</p>
</li>
<li><p>checkcast 指令：类型进行强制转换的时候会有，他会判断能否进行转换，和 instanceof 差不多，他有一个操作数也是指向常量池的，一个类，然后也会从操作数栈弹出栈顶的实例引用，如果可以强制转换，那就转换就行了，如果不行，抛出 ClassCastException。</p>
</li>
</ul>
<h1 id="5-方法指令"><a href="#5-方法指令" class="headerlink" title="5. 方法指令"></a>5. 方法指令</h1><h2 id="5-1-方法调用"><a href="#5-1-方法调用" class="headerlink" title="5.1 方法调用"></a>5.1 方法调用</h2><p>方法调用总共就几个指令，分别是：</p>
<ul>
<li><p>invokevirtual：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态，是Java中最常见的调用指令。这个具体说说，就是说JVM在执行你的方法的时候，并不知道你这个方法是谁的，还真不一定是当前类型的，因为很可能你这里用到了类的上转型（可不是接口的啊，接口引用调用方法可就是invokeinterface了），比如 <code>Thread t = new XXXThread(); t.run(); </code>，你这个run，已经被你XXXThread重写了，所以JVM搞不清楚了，这个得具体情况具体分析，得运行以后根据你具体的实现类，去调用方法，这就叫虚方法分派。</p>
</li>
<li><p>invokeinterface：这个就是调用接口回调的方法，比如 <code>XXXInterface xx = new XXXInterfaceImpl(); xx.func();</code>，这个情况下就是 invokeinterface指令。</p>
</li>
<li><p>invokespecial：调用 构造器，私有方法，父类方法的时候的指令，这三种方法比较特殊，因为都不能重写，构造器和私有方法那是废话，子类是铁定不能重写的，那调用父类方法？这个调用父类方法就是 super.xxx() 这种形式，这个就算你子类重写了，你super也是调用的父类的方法，和你当前子类没半毛钱关系。</p>
</li>
<li><p>invokestatic：调用静态方法，这个好理解。</p>
</li>
<li><p>invokedynamic：这个比较复杂，不说了。</p>
</li>
</ul>
<p>特别的，如果一个方法是 private static 的，那优先考虑 static，指令那就是 invokestatic。</p>
<p>如果是接口中的已经实现的方法呢？众所周知（我还真不知道JDK8的接口可以有静态方法），jdk8的接口可以有default 方法和 static 方法（都可以实现），那么我们调用这两种方法，指令是啥？看例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">method1</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="title function_">method2</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> <span class="keyword">implements</span> <span class="title class_">AA</span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">    aa.method2(); <span class="comment">// invokeinterface</span></span><br><span class="line">    AA.method1(); <span class="comment">// invokestatic</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，即便是方法在接口中已经实现了，指令仍旧是 invokeinterface，但是接口中的静态方法可不是invokeinterface，即便他是在接口中定义的，调用接口中的静态方法指令是 invokestatic，可以看得出来static的优先级比interface高。</p>
<h2 id="5-2-方法返回："><a href="#5-2-方法返回：" class="headerlink" title="5.2 方法返回："></a>5.2 方法返回：</h2><p>这个倒是很简单，分为有返回值和无返回值：</p>
<ul>
<li><p>有返回值：ireturn（返回 boolean byte char short int），lreturn，freturn，dreturn，areturn。这个返回值类型啊，主要看的是你定义方法的时候写的方法返回值，就算你是 <code>public float f()&#123;int i = 10; return i;&#125;</code> 最后返回也是freturn，和你具体返回的啥没太大关系。</p>
</li>
<li><p>无返回值：return</p>
</li>
</ul>
<p>如果有返回值，那他具体会干啥？他会把当前栈帧的操作数栈的栈顶元素弹出，然后结束方法，方法一结束栈帧出栈，操作数栈也没了，然后把这个栈顶元素，压入调用这个方法的方法的操作数栈。</p>
<h1 id="6-操作数栈管理指令："><a href="#6-操作数栈管理指令：" class="headerlink" title="6. 操作数栈管理指令："></a>6. 操作数栈管理指令：</h1><p>这里的管理，指的是不需要借助任何的东西，操作数栈自己进行操作。</p>
<ul>
<li><p>直接废弃栈顶元素，直接弹出：pop，pop2。区别就是 pop 弹出一个slot的元素，pop2弹出两个slot的元素。</p>
</li>
<li><p>复制操作：dup，dup2，dup_x1，dup2_x1，dup_x2，dup2_x2。</p>
</li>
<li><p>交换：swap，交换栈顶的两个 1slot元素，注意，只能是两个 1slot的元素交换，JVM没有提供两个 2slot的元素的交换指令。</p>
</li>
<li><p>nop：啥也不干，对应的16进制是0x00，就是用来站位。</p>
</li>
</ul>
<p>dup需要特别说一下，这个复制是复制栈顶的一个或者两个元素，注意，可以一次复制两个的。然后 dup 和 dup2的区别就是 dup复制1slot的元素，dup2复制占2slot的对应元素，注意我说的可以占2slot的东西，还真不一定是仅仅复制一个2slot的单个元素。比如dup2可以复制栈顶的long，double，也可以复制栈顶的两个元素，一个是int，另一个是float。</p>
<p>然后，dup指令如果后面带有_x，那就不是单纯的复制，而是复制完了以后把复制品插入到另外的位置。那么具体插入到哪呢？有个技巧：</p>
<p>dup[n]_xm，对吧，n 如果没有那就是 1，有了那就是2。这条指令的具体意思是，先复制，然后把复制结果往下挪 n + m 个slot。</p>
<p>首先举例子：什么情况下会pop，看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的指令省略，不用想，肯定是 new dup invokespecial astore，着重看下面两行：</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">hash</span> <span class="operator">=</span> obj1.toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invokevirtual &lt;...Object.toString&gt;</span></span><br><span class="line">    <span class="comment">// astore_2</span></span><br><span class="line">    <span class="comment">// 这里因为我们把他赋值给了局部变量，所以存入局部变量表，那么说明这个 toString 的返回值有用</span></span><br><span class="line">    obj2.toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invokevirtual &lt;...Object.toString&gt;</span></span><br><span class="line">    <span class="comment">// pop</span></span><br><span class="line">    <span class="comment">// return</span></span><br><span class="line">    <span class="comment">// 这里为啥就pop了？因为我们就是调用了一下 toString 方法，返回值并没有保存，所以没用，没用操作数栈就把结果直接弹出</span></span><br><span class="line">    <span class="comment">// 又因为是个 String，引用类型，所以弹出一个slot的值就行了</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">bar</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    bar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invokespecial &lt;...bar&gt;</span></span><br><span class="line">    <span class="comment">// pop2</span></span><br><span class="line">    <span class="comment">// return</span></span><br><span class="line">    <span class="comment">// 这里为啥就是 pop2？因为返回值没用，所以需要弹栈，然后因为返回值是long，占用了操作数栈两个slot，索引pop2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-比较指令："><a href="#7-比较指令：" class="headerlink" title="7. 比较指令："></a>7. 比较指令：</h1><p>比较指令，说白了就是比较大小的呗，从栈中弹出俩数比较大小。</p>
<p>这里我先规定：现在操作数栈中有俩数，按顺序是 v2 和 v1，注意是按顺序，也就是v2 压在 v1上面，是栈顶（其实也很好理解，v1 &gt; v2，肯定是先压入v1，再压入 v2，所以v2 在 v1上面）。然后有下面指令：</p>
<ul>
<li><p>fcmpl, fcmpg</p>
</li>
<li><p>dcmpl, dcmpg</p>
</li>
<li><p>lcmp</p>
</li>
</ul>
<p>第一个字母代表类型（float，double，long），cmp不说，最后一个字母 l 和 g 代表 lower 和 greater。其实没啥区分，正常情况下，这些指令都是弹出v2 和 v1 进行比较，如果 v1 &gt; v2，操作数栈压入1，如果 v1 &#x3D;&#x3D; v2，操作数栈压入0，如果 v1 &lt; v2，压-1。唯一的区别就是：如果v1 或者 v2有一个出现NaN，那么 lower 压入 -1，greater 压入 1.仅此而已。</p>
<p>所以为啥 lcmp 没有lg，因为long没有 NaN。</p>
<h1 id="8-控制转移指令："><a href="#8-控制转移指令：" class="headerlink" title="8. 控制转移指令："></a>8. 控制转移指令：</h1><h2 id="8-1-条件跳转指令："><a href="#8-1-条件跳转指令：" class="headerlink" title="8.1 条件跳转指令："></a>8.1 条件跳转指令：</h2><p>条件跳转指令一般是用栈顶元素和0或者null去进行跳转，和比较指令关联很大，一般情况下都是比较指令先把比较结果压入栈顶，然后判断指令从栈顶获取结果进行跳转。</p>
<p>必须要注意的是，这些跳转指令 后面都有一个操作数，代表如果判断位真则跳转到第几行指令。</p>
<ul>
<li><p>ifeq（if_equals），ifne（if_nonequals）如果栈顶元素 &#x3D;&#x3D; 0 &#x2F; !&#x3D; 0 ，则跳转。</p>
</li>
<li><p>iflt，ifle，ifgt，ifge。当栈顶元素 &gt; &gt;&#x3D; &lt; &lt;&#x3D; 0 时跳转。</p>
</li>
<li><p>ifnull，ifnonnull。如果栈顶元素是null&#x2F;不是null 时跳转。</p>
</li>
</ul>
<p>特别需要注意一个地方，看下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// iconst_0, istore_1</span></span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span>) <span class="comment">// iload_1, ifne xx &lt;a = 20&gt;</span></span><br><span class="line">        a = <span class="number">10</span>; <span class="comment">// bipush 10, istore_1, goto xx &lt;return&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a = <span class="number">20</span>; <span class="comment">// bipush 20, istore_1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a; <span class="comment">// iload_1, ireturn</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是的，我知道很简单，我们仔细看一看，如果if判断的结果为真，那他会接着if后面的按顺序执行，也就是走if路线的话根本没有跳转，只有在 if 判断不通过的情况下，走到else，这个时候才发生了指令跳转。但是这些判断指令后面又必须跟一个跳转地址，所以说这里我们判断得是 a&#x3D;&#x3D;0，如果等于则干啥，但是指令其实是反过来的，指令中判断 如果 a !&#x3D; 0，则跳转到else的地方。</p>
<p>总结一下，就是条件跳转指令会给我们写的if判断的条件取反，我们让他判断 a 是否等于0，指令则会判断 a 是否不等于0，如果是，则直接跳转到 else，如果不是，则不跳转，接着按顺序执行if后面的指令。</p>
<p>还有啊，这个条件跳转指令，针对的是 一个 int 和 一个常数比较，比如你直接 a &#x3D;&#x3D; 0，就会用条件跳转，如果是连个float，那就是两个float先 cmp，往操作数栈中压入比较结果，然后再条件跳转。</p>
<h2 id="8-2-比较条件跳转指令"><a href="#8-2-比较条件跳转指令" class="headerlink" title="8.2 比较条件跳转指令"></a>8.2 比较条件跳转指令</h2><p>这个东西就是把条件跳转和比较 结合在一起了，仅此而已。主要针对两个int（或者说JVM给你转换以后是int，害，其实就是 byte short）或者两个引用的比较，当然这里的比较引用肯定是比较的hashcode。</p>
<ul>
<li><p>if_icmpeq，if_icmpne，if_icmplt，if_icmple，if_icmpgt，if_icmpge：从栈顶弹出v2 和 v1 两个int，如果 &#x3D;&#x3D; !&#x3D; &lt; &lt;&#x3D; &gt; &gt;&#x3D; 的话，就跳转</p>
</li>
<li><p>if_acmpeq，ifacmpne：从栈顶弹出两个引用，判断 &#x3D;&#x3D; !&#x3D;</p>
</li>
</ul>
<h2 id="8-3-多条件跳转指令"><a href="#8-3-多条件跳转指令" class="headerlink" title="8.3 多条件跳转指令"></a>8.3 多条件跳转指令</h2><p>这个多条件不是else if 啊，指的是 switch case 结构。</p>
<p>具体分为两个：tableswitch 和 lookupswitch，这两个都是规定了如何跳转。区别就是 如果case 的后面的东西连续，那就是tableswitch，可以直接定位。如果不连续，那就需要用到 lookupswitch。</p>
<p>lookupswitch 优化为题：</p>
<p>因为lookupswitch不连续，所以他的效率可能慢一点，但是这个指令自己会优化，他会把你所有的case 条件，按顺序排序，比如你是 case 100, 500, 200，那他最后优化就会变成：100, 200, 500.但是这是不是说明，如果你不break，那他就不按从上到下的顺序一溜往下走了？不是的，具体为啥，你可以去看字节码。</p>
<p>还有jdk7支持的 case 字符串。这个东西更玄学，不细说了，挺多的，可以看：cn.chl.SwitchCase.java 这个文件。</p>
<h2 id="8-4-无条件跳转指令"><a href="#8-4-无条件跳转指令" class="headerlink" title="8.4 无条件跳转指令"></a>8.4 无条件跳转指令</h2><p>goto 指令，后面跟着一个2字节的操作数，代表往哪里跳转，如果两个字节（65535，无符号的2字节数）不够，那就是用 goto_w 这个指令，和goto一样，区别就是goto_w 接受一个4字节的操作数。</p>
<p>这里还可以涉及到循环，JVM中可没有任何的循环指令，其实循环都是 条件跳转指令 + 无条件跳转指令实现的。</p>
<h1 id="9-异常与异常处理"><a href="#9-异常与异常处理" class="headerlink" title="9. 异常与异常处理"></a>9. 异常与异常处理</h1><p>很好，我们都很讨厌异常</p>
<h2 id="9-1-异常的生成"><a href="#9-1-异常的生成" class="headerlink" title="9.1 异常的生成"></a>9.1 异常的生成</h2><p>众所周知，Java中的异常，其实就是 Exception对象，说的再准确点，就是 Throwable 实现类，所以异常，首先也要创建，然后使用关键字throw出来。</p>
<p>JVM层面，throw 的指令：athrow。但是这个指令仅限于我们手动抛出异常，如果是自动抛出的异常，比如除以0的异常，会在执行指令idiv和ldiv时自动抛出，那么这里自动抛出的异常就不会涉及athrow指令。</p>
<p>一旦抛出异常，直接清空方法的操作数栈（不光是清空操作数栈，整个栈帧都会直接弹出），然后把异常对象，压入方法调用者的操作数栈上。</p>
<h2 id="9-2-异常的捕获"><a href="#9-2-异常的捕获" class="headerlink" title="9.2 异常的捕获"></a>9.2 异常的捕获</h2><p>早期的JVM采用了 jsr ret 等指令来对异常进行处理，但是是早期，现在JVM已经把这些指令废弃了，取而代之的是异常表。</p>
<p>异常表其实很简单，就是一张表，规定了如果发生哪类异常，则跳转到哪条指令。一般来说只要你存在try catch 或者 try finally 则会出现这个东西。当</p>
<p>异常表有有你catch的所有异常，如果发生异常，就会去和你异常表匹配，匹配到哪个异常，跳转到哪个异常的处理位置，如果没有匹配，则弹出当前栈帧。</p>
<p>异常表结构如下：</p>
<table>
<thead>
<tr>
<th>Nr.</th>
<th>Start PC</th>
<th>End Pc</th>
<th>Handler PC</th>
<th>Catch Type</th>
</tr>
</thead>
<tbody><tr>
<td>第几个，毛用没有</td>
<td>try的起始位置</td>
<td>try的结束位置</td>
<td>抛出异常后的处理位置</td>
<td>处理的异常类型</td>
</tr>
</tbody></table>
<p>这个举个例子，看 cn.chl.ExceptionByteCode，里面的test5 方法，他的异常表如下：</p>
<table>
<thead>
<tr>
<th>Nr.</th>
<th>Start PC</th>
<th>End PC</th>
<th>Handler PC</th>
<th>Catch Type</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>6</td>
<td>9</td>
<td>java.lang.ClassNotFoundException</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>6</td>
<td>21</td>
<td>java.lang.RuntimeException</td>
</tr>
</tbody></table>
<p>所以具体什么意思呢？很简单，第一个，如果在 0 - 6 行字节码出现ClassNotFoundException，则跳转到 9 行进行处理，第二个，如果在 0 - 6 行出现RuntimeException，则跳转到 21行进行处理。就是这么简单。</p>
<h1 id="10-同步控制指令"><a href="#10-同步控制指令" class="headerlink" title="10. 同步控制指令"></a>10. 同步控制指令</h1><p>说白了，就是同步代码块。</p>
<p>首先，同步，有两种办法：</p>
<ul>
<li><p>直接给方法加上 synchronized 关键字，然后这个方法就是一个同步方法，一次只允许一个线程调用。这种办法在字节码指令角度看不到任何东西，是的，任何，一个方法你加不加同步，字节码都是那样。唯一的区别就是，方法的访问标识符会变。加上的话，方法的访问标识就会变成 public synchronzied。</p>
</li>
<li><p>使用同步代码块：synchronized(临界资源)。这个比较牛逼了，下面主要说这个东西。</p>
</li>
</ul>
<p>如果方法内想要进入同步代码块，使用 monitorenter指令，这个指令从操作数栈中弹出这个临界资源（一般是一个对象），我们之前讲对象头结构的时候说过，对象头中存储着线程的信息，比如当前对象是否有锁，这个锁是谁拿着的。那么现在 monitorenter指令得到这个临界资源后，会去对象头中找这俩属性：</p>
<ul>
<li><p>看当前对象有没有被加锁，如果没有，ok，我给加上，然后我进入同步代码块</p>
</li>
<li><p>如果有锁，看看这个锁是谁拿着的，如果是我拿着的，行，我也可以进入这个代码块</p>
</li>
<li><p>如果这个锁不是我拿着，那很遗憾，我就得等着了。</p>
</li>
</ul>
<p>所以我进入了同步代码块，怎么出来？monitorexit指令，这个指令也会从操作数栈得到临界资源，然后修改他的对象头，释放锁。</p>
<p>需要注意的是，即便我们在同步代码块中没有使用try catch，JVM也会给我们生成异常表，为啥？如果出现异常，难道说当前线程就不释放锁了？不能吧。只要出现异常，则马上跳出同步代码块来释放锁。</p>
<p>细说一下：上面我们提到，对象头中有一个东西记录这个对象是否有锁，这个东西叫 “监视器计数器”，如果计数器&#x3D;0，说明没有锁，线程可以进入，如果为1，那说明有锁，你得等着了。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-字节码</title>
    <url>/2022/06/13/bytecode/</url>
    <content><![CDATA[<p>前面几经讲完了JVM的一些底层原理，从这章开始，我们会深入字节码文件，说一说字节码的各种指令，从指令层面了解Java代码。</p>
<span id="more"></span>

<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>从这里开始，就进入了字节码和类加载器篇，这一篇讲字节码文件，可能还有类加载器。</p>
<h2 id="1-1-正式开始之前，先来道题"><a href="#1-1-正式开始之前，先来道题" class="headerlink" title="1.1 正式开始之前，先来道题"></a>1.1 正式开始之前，先来道题</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(i3 == i4);</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">System.out.println(i5 == i6);</span><br></pre></td></tr></table></figure>

<p>解决这个问题，光看代码不行，你这一看，行啊，false   false   false 呗，为啥？那对象和int能比么,对象比对象那不是比的hashCode吗，俩对象，hash不一致，对吧。结果让你头疼，结果还真就不是，而是 true      false      true。</p>
<p>所以为了解决这道题，我们就得看字节码，我们会发现，在字节码的角度来说 Integer i1 &#x3D; 10 其实是 <code>Integer i1 = Integer.valueOf(10);</code>  而不是 <code>Integer i1 = new Integer(10)</code>，那问题肯定是在valueOf 上了，所以我们进入源码看 valueOf。我们就会发现惊人的事实，以下高能：</p>
<p>Integer 内部有一个IntegerCache，里面缓存了一部分Integer对象，这部分对象是已经创建好的，范围是 -128 - 127，如果他发现你传入的int是在这个范围内的话，他就会把对应的Integer直接给你而不会创建新的Integer，所以说上面 i1 和 i2 其实都是一个IntegerCache中的一个固定的Integer，压根就是同一个对象所以肯定想等。</p>
<p>i5 和 i6 是咋回事？还得看字节码，我们会发现在判断的时候其实i5做了一个intValue的动作得到了 int 5，所以 i5 &#x3D;&#x3D; i6 其实是 i5.intValue() &#x3D;&#x3D; i6，那这个intValue是一个int，所以说也相等。</p>
<h2 id="1-2-正式开始前，再来一道阴间题目"><a href="#1-2-正式开始前，再来一道阴间题目" class="headerlink" title="1.2 正式开始前，再来一道阴间题目"></a>1.2 正式开始前，再来一道阴间题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.print();</span><br><span class="line">        <span class="built_in">this</span>.x = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.x=&quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.print();</span><br><span class="line">        <span class="built_in">this</span>.x = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son.x=&quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 1. Father f = new Son();</span></span><br><span class="line">        <span class="comment">// 2. Father f = new Father();</span></span><br><span class="line">        System.out.println(f.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这家伙，要想想明白这个事，咱们先不看2，咱们先看1.</p>
<p>众所周知，这个成员变量的赋值顺序：</p>
<ul>
<li>默认赋值</li>
<li>显式赋值 &#x2F; 实例代码块中赋值</li>
<li>构造器赋值</li>
<li>后期直接 XXX.xxx 或者 XXX.setXxx(xxx)</li>
</ul>
<p>那现在，直接 <code>Father f = new Father();</code> 对吧，根据顺序，首先 x &#x3D; 10，然后构造，所以一上来打印：Father.x &#x3D; 10,然后打印 f.x，那就是 20呗，这个没啥异议。</p>
<p>然后看2，这个时候看不太懂了，我们去看看字节码，我们又会发现一个小秘密：我们以前说过，创建子类对象会首先调用父类的构造方法，也就是有一个隐藏的 super()，这个super我们说必须放在构造器第一行，对吧。但是我们看字节码我们发现，何止是第一行，父类构造器是整个 &lt;init&gt; 方法的第一步。</p>
<p>我们的Son类，首先 int x &#x3D; 30 对吧，这个按顺序应该是&lt;init&gt;() 方法的第一步，这是正常情况下，但是在继承中， x &#x3D; 30 和 x &#x3D; 40 却在后面，第一步是调用了 Father.&lt;init&gt;() 方法，然后进入了Father.init，Father调用了 print 方法，但是print已经被子类重写了， 所以调用的其实是子类的print方法，子类要打印子类的x，这个时候因为我们前面说的原因，x &#x3D; 30 还没有执行，所以目前x 只有默认0值，所以打印出来的结果居然是 son.x &#x3D; 0。</p>
<p>父类构造器执行完成，返回子类构造器，子类x必定是显式初始化了对吧，所以30，调用print，没有异议，然后最后打印 f.x，Java中，成员可没有多态，所以打印的父类的x，也就是20。~~~~</p>
<p>最后结果：</p>
<p>Son.x&#x3D;0;Son.x&#x3D;30;20</p>
<h2 id="1-3-普及几个概念"><a href="#1-3-普及几个概念" class="headerlink" title="1.3 普及几个概念"></a>1.3 普及几个概念</h2><p>这些概念后面要用：</p>
<p>操作码：opcode</p>
<p>就是字节码指令的前面那部分，比如 bipush</p>
<p>操作数：operand</p>
<p>就是操作码后面的参数，一般是一个数</p>
<h1 id="2-解析字节码文件"><a href="#2-解析字节码文件" class="headerlink" title="2. 解析字节码文件"></a>2. 解析字节码文件</h1><p>很好，终于是到了这步了，很显然我们的 class文件都是乱码，那么我们就需要把他转成16进制看。以后肯定不用这么的，直接 JClassLib 插件看就行，但是刚开始嘛，多学点，总是好的。</p>
<p>Windows特别方便，直接notepad++安装一个 hex editor 插件就行了，Ubuntu 不行啊，好吧，vim 走起，弄一个class文件，然后：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim xxx.class</span><br><span class="line">:%!xxd</span><br></pre></td></tr></table></figure>

<p>就行了。</p>
<h2 id="2-1-Class文件存储方式"><a href="#2-1-Class文件存储方式" class="headerlink" title="2.1 Class文件存储方式"></a>2.1 Class文件存储方式</h2><p>Class 文件整体采用一种类似 C 语言结构体的存储方式，存储单位有两个：无符号数 和 表，下面具体区分：</p>
<ul>
<li>无符号数：用于存储基本数据类型，分为 u1 u2 u4 u8 4种类型，分别代表  1 2 4 8 个字节的无符号数，这个东西可以用来描述：数字，索引引用，数量，或者 utf-8 编码的字符串值。</li>
<li>表：表是由多个无符号数或者其他表构成的复合数据类型，所有表都习惯性的以 _info 结尾。表 用于描述有层次关系的复合结构的数据，整个class文件其实就是一张表，由于一个表长度不一定，所以一般会在表前面加一个数字来表示表长。</li>
</ul>
<h2 id="2-2-Class文件结构"><a href="#2-2-Class文件结构" class="headerlink" title="2.2 Class文件结构"></a>2.2 Class文件结构</h2><p>这里写一下java虚拟机规范中的说明：</p>
<table>
<thead>
<tr>
<th>所用类型</th>
<th>文件结构</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>u4</td>
<td>magic 魔数</td>
<td>识别class文件的标识</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version : class文件副版本</td>
<td>识别class文件版本</td>
</tr>
<tr>
<td>u2</td>
<td>major_version: class文件主版本</td>
<td>识别class文件版本</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count：常量池长度</td>
<td>记录常量池长度.就像之前说的.一个表会在前面记录表长</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool[c_p_c-1]：常量池</td>
<td>特别重要.以后再说</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags：访问标志</td>
<td>体现你这个东西是个类还是个接口.public还是private</td>
</tr>
<tr>
<td>u2</td>
<td>this_class：类索引</td>
<td></td>
</tr>
<tr>
<td>u2</td>
<td>super_class：父类索引</td>
<td></td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count：接口索引集合长度</td>
<td></td>
</tr>
<tr>
<td>u2</td>
<td>interfaces[interfaces_count-1]:接口索引集合</td>
<td></td>
</tr>
<tr>
<td>u2</td>
<td>fields_count：字段表集合 长度</td>
<td>记录字段表长度,这里的字段就是成员.或者我们平常说属性</td>
</tr>
<tr>
<td>field_info</td>
<td>fields[fields_count-1]：字段表集合</td>
<td>记录所有的字段</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count：方法表集合 长度</td>
<td>记录方法表长</td>
</tr>
<tr>
<td>method_info</td>
<td>methods[methods_count-1]：方法表集合</td>
<td>记录所有方法</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count：属性表集合 长度</td>
<td>这个属性指的是当前类自己的属性,比如类名这种的信息,不是字段</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes[attributes_count-1]：属性表 集合</td>
<td></td>
</tr>
</tbody></table>
<p>是不是觉得上面的特别多，其实很多东西是合二为一的，下面总结一下，ClassFile的结构：</p>
<ul>
<li>魔数</li>
<li>class文件版本</li>
<li>常量池</li>
<li>访问标志</li>
<li>类索引 父类索引 接口索引集合</li>
<li>字段表集合</li>
<li>方法表集合</li>
<li>属性表集合</li>
</ul>
<p>很好，知道了这些以后，来吧，开始手撕16进制字节码。</p>
<h1 id="3-字节码文件详解"><a href="#3-字节码文件详解" class="headerlink" title="3. 字节码文件详解"></a>3. 字节码文件详解</h1><p>上面已经说了字节码文件分为了那么多部分，所以这里详细说一说每个部分都是干嘛的</p>
<h2 id="3-1-Magic-魔数"><a href="#3-1-Magic-魔数" class="headerlink" title="3.1 Magic 魔数"></a>3.1 Magic 魔数</h2><p>魔数，占用4个字节，用于表示这个class文件是一个合法的class文件，可以被jvm识别。</p>
<p>肯定是 0xCAFEBABE，如果不是，那说明不是合法的class文件，就会抛出错误，具体啥错误我就不说了。</p>
<p>这个东西应用比较广，比如两张图片，你去对比他们的十六进制，会发现他们的第一行基本一样。</p>
<h2 id="3-2-class文件版本号"><a href="#3-2-class文件版本号" class="headerlink" title="3.2 class文件版本号"></a>3.2 class文件版本号</h2><p>跟在magic后面， 5 6 字节一组，7 8 字节一组，56是 minor version，也叫小版本，78是major version，大版本。两个东西共同组成class文件的版本号，比如 大版本是M，小版本是m，那么class文件的版本就是 M.m。</p>
<p>那这玩意有啥用，不同的编译器，编译出来的版本不一样，下面是一个对照表：</p>
<table>
<thead>
<tr>
<th>大版本(后面)</th>
<th>小版本(前面)</th>
<th>对应编译器版本</th>
</tr>
</thead>
<tbody><tr>
<td>45</td>
<td>3</td>
<td>1.1</td>
</tr>
<tr>
<td>46</td>
<td>0</td>
<td>1.2</td>
</tr>
<tr>
<td>47</td>
<td>0</td>
<td>1.3</td>
</tr>
</tbody></table>
<p>不往后写了，因为后面的小版本都是0，然后编译器每加一个版本，大版本+1.</p>
<p>别犯傻啊，字节码文件里面可是16进制，你看到是34，其实是52，也就是 jdk1.8.</p>
<p>目前，高版本的编译器可以执行低版本编译器编译出来的字节码文件，但是反过来不行，如果class文件版本高于当前编译器版本，会抛出异常</p>
<blockquote>
<p>java.lang.UnsupportedClassVersionError</p>
</blockquote>
<h2 id="3-3-常量池-ConstantPool"><a href="#3-3-常量池-ConstantPool" class="headerlink" title="3.3 常量池 ConstantPool"></a>3.3 常量池 ConstantPool</h2><p>这东西是class文件中内容最丰富的地方之一，而且这个对class文件的字段和方法解析也非常的重要。</p>
<p>随着java的发展，常量池的内容日渐丰富，可以说常量池是class文件的基石。</p>
<p>这东西分为两部分，首先是版本号后面紧跟着的 常量池计数器，毕竟字节码文件没有分隔符，jvm又得分隔，所以这里就写一个计数器，告诉jvm后面的东西到第几个就结束了，不同于java语言，这个计数器从1开始，而不是0。第二部分是若干常量池表项，常量池表项中，用于存放编译时期产生的各种字面量和符号引用，这部分内容将在类加载以后进入方法区，存在运行时常量池中。</p>
<h3 id="3-3-1-常量池计数器-Constant-pool-count"><a href="#3-3-1-常量池计数器-Constant-pool-count" class="headerlink" title="3.3.1 常量池计数器 Constant_pool_count"></a>3.3.1 常量池计数器 Constant_pool_count</h3><p>说过了，起始是1，也就是如果常量池计数器&#x3D;1，说明常量池中没东西，那为啥从1开始？因为常量池的东西相互之间各种引用，如果里面的一项谁都没有引用怎么整，怎么表示，那就是引用0呗，所以把0空出来。这里我的常量池计数器是16，也就是22，那么常量池的范围就是1-21.</p>
<h3 id="3-3-2-常量池表-ConstantPool"><a href="#3-3-2-常量池表-ConstantPool" class="headerlink" title="3.3.2 常量池表 ConstantPool"></a>3.3.2 常量池表 ConstantPool</h3><p>常量池主要存放两大类常量：字面量Literal和符号引用SymbolicReferences。</p>
<ul>
<li><p>字面量：两种，第一种是文本字符串，第二种是声明为final的常量值。</p>
</li>
<li><p>符号引用：类和接口的全限定名，字段的名称和描述符，方法的名称和描述符。</p>
<ul>
<li><p>全限定名：包名+类名，但是和全类名不一样，他把全类名的 . 换成了 &#x2F;，比如：cn&#x2F;zhzp&#x2F;commons&#x2F;JwtUtils 这就是全限定名，为了不混淆，一般在最后面加一个 ; 表示结尾，就是 cn&#x2F;zhzp&#x2F;commons&#x2F;JwtUtils;</p>
</li>
<li><p>简单名称：上面提到的 字段名，方法名，仅仅是那个名字，就是简单名称，比如 main 方法的 main这个单词，就是一个简单名称。</p>
</li>
<li><p>描述符：用于描述字段的数据类型，方法的形参列表，返回值类型。这里提到了数据类型，按照规定，有以下规则来表示类型：</p>
<table>
<thead>
<tr>
<th>标志符</th>
<th>数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>基本数据类型 byte</td>
</tr>
<tr>
<td>C</td>
<td>基本数据类型 char</td>
</tr>
<tr>
<td>D</td>
<td>基本数据类型 double</td>
</tr>
<tr>
<td>F</td>
<td>基本数据类型 float</td>
</tr>
<tr>
<td>I</td>
<td>基本数据类型 int</td>
</tr>
<tr>
<td>J</td>
<td>基本数据类型 long</td>
</tr>
<tr>
<td>S</td>
<td>基本数据类型 short</td>
</tr>
<tr>
<td>Z</td>
<td>基本数据类型 boolean</td>
</tr>
<tr>
<td>V</td>
<td>代表void类型</td>
</tr>
<tr>
<td>L</td>
<td>代表对象类型，L + 全限定名，比如 Ljava&#x2F;lang&#x2F;Object</td>
</tr>
<tr>
<td>[</td>
<td>代表一维数组，比如 int[][][][][] [] [] -&gt; [[[I</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>这里我们再回到我们刚学jvm的时候学到的类加载三个阶段：加载链接初始化，链接阶段分为 验证 准备 解析，最后一步解析当时说的是：把字节码文件中的符号引用替换成直接引用。这里我们详细的说一说：</p>
<p>这里我们提到符号引用记录全限定名，比如我们用到了 System.out.println()，那他符号引用就会记录 Ljava&#x2F;lang&#x2F;System（不一定对，我猜的啊，只是举个例子），就说明我们当前这个类需要引用到 System，但这只是一个符号。然后在类加载阶段，就会解析这个符号引用，然后去加载这个 System类，加载完以后我们也学过方法区了，System这个类就会放在方法区，就会有一个内存地址，这个时候，把常量池中的符号引用，替换成内存地址，让常量池可以真正引用到方法区的System类。</p>
<p>这个不局限于类或者接口，同理方法也是这样的，常量池中有一个 add 符号，啥也不是，然后类加载之后把他真正的指向方法区中的add方法内存。</p>
<p>所以再说啥叫符号引用和直接引用：</p>
<p>符号引用，和内存半毛钱关系没有，仅仅是一个符号，用来表示这个class引用了啥。</p>
<p>直接引用，一个内存地址，偏移量，或者句柄，总之可以定位到真正的对象，和内存有直接关系。</p>
</blockquote>
<p>常量池中包含了这个class结构和他的子结构中包含的所有：字符串常量，类和接口名，字段名，和其他常量。</p>
<p>常量池中的每一项都具有相同的结构，每一项的第一个字节是类型标记符，用于确定这一项的格式，这个字节叫做 tag byte。</p>
<p>再具体的，就是说常量池中每一部分都是怎么构成的，不说了，太多了，我在里面又放了一个尚硅谷的md文件，看那个就行了。</p>
<h2 id="3-4-访问标志-Access-Flag"><a href="#3-4-访问标志-Access-Flag" class="headerlink" title="3.4 访问标志 Access_Flag"></a>3.4 访问标志 Access_Flag</h2><p>常量池后面u2是访问标志，访问标志有很多啊，比如 ACC_PUBLIC, ACC_SUPER 这种的，每一种访问标志都有一个十六进制数值表示，然后class文件中的这个访问标志其实个加和，是多个访问标志加到一起得到的数字。</p>
<p>各个访问标志也在尚硅谷的md里面，需要的话自己看，不多说了。</p>
<p>补充说明：</p>
<ul>
<li>带有 ACC_INTERFACE 标识的class，说明他是一个接口，没带，那就是类。</li>
<li>如果一个class有 ACC_INTERFACE,那他必须同时有 ACC_ABSTRACT，不能有 ACC_SUPER  ACC_ENUM  ACC_FINAL.</li>
<li>注解类型必须有 ACC_ANNOTATION 标识，如果有 ACC_ANNOTATION，那必须同时有 ACC_INTERFACE 标识。</li>
<li>ACC_SUPER，只要是类，那基本都有这个标志，详细的不多说了。</li>
</ul>
<h2 id="3-5-类索引-父类索引-接口索引集合"><a href="#3-5-类索引-父类索引-接口索引集合" class="headerlink" title="3.5 类索引 父类索引 接口索引集合"></a>3.5 类索引 父类索引 接口索引集合</h2><p>先说啥叫索引，上面不是有常量池吗，常量池中有符号引用对吧，然后常量池里面的每一项都一个位置对吧，那么索引的意思就是指向了常量池的哪个位置，指向了常量池的第几项。所以索引是一个u2。</p>
<p>放在这里也很好理解了，类索引就是常量池中本类符号引用的位置，父类索引同理，然后接口索引集合，首先他是个集合，那他肯定前面肯定有一个u2的计数器，然后后面才是每一个索引。</p>
<h2 id="3-6-字段表集合"><a href="#3-6-字段表集合" class="headerlink" title="3.6 字段表集合"></a>3.6 字段表集合</h2><p>首先，集合，所有u2的计数器，不多说。</p>
<p>然后，我们着重看看字段表里面包含了啥，包含以下内容：</p>
<ul>
<li>访问标志，这里的访问表示还不同于上面的class文件访问标识，而是字段自己的一套访问表示，在尚硅谷那里都有写，这里不说了，占用u2</li>
<li>字段名索引，显然是指向常量池中的属性名称。</li>
<li>字段描述符搜因，字段的描述符就是这个字段的类型，同理指向常量池</li>
<li>字段属性表集合，这个东西比较特殊，有些字段也是有属性的，用于存放一些额外信息，比如初始化值(主要针对常量)，注释等信息，这里不举例了，了解就行。</li>
</ul>
<h2 id="3-7-方法表集合"><a href="#3-7-方法表集合" class="headerlink" title="3.7 方法表集合"></a>3.7 方法表集合</h2><p>在字节码文件中，每一个 method_info 都对应着当前类或接口中的方法，用于描述这个方法的方法名，访问标识，返回值类型，参数列表等信息。</p>
<p>如果一个方法不是abstract 不是native的，那么这个方法就会在字节码中体现出来。</p>
<p>methods 中只会有当前类或者接口中声明的方法，不会有父类的方法，同时，methods中可能会有些类加载期间自动加上的方法，比如 clinit init 这种方法。</p>
<p>方法表中包含的信息，总的来说，包括这些：u2访问标识，u2方法名索引，u2描述符索引，u2属性计数器，attribute_info属性集合。</p>
<p>然后属性里面有啥东西？特别麻烦，各种 code，什么 本地变量表，操作数栈深度，还什么line_number_table，不说了，太恶心了，这里不说了。</p>
<h2 id="3-8-属性表集合"><a href="#3-8-属性表集合" class="headerlink" title="3.8 属性表集合"></a>3.8 属性表集合</h2><p>一上来u2计数器，不说了。</p>
<p>只要是属性，不管是这里的属性，还是字段表的属性，还是方法表的属性，都有有些共同的地方，一般来说，属性表肯定有三个东西：</p>
<ul>
<li>属性名索引</li>
<li>属性长度</li>
<li>属性表</li>
</ul>
<p>然后，根据属性名索引找到属性名，然后拿着属性名去找这个名字的属性里面包含了哪些信息，就这么个过程，不细说了。</p>
<h1 id="4-字节码相关命令"><a href="#4-字节码相关命令" class="headerlink" title="4. 字节码相关命令"></a>4. 字节码相关命令</h1><p>上面的字节码，一个一个16进制扣，看得我反胃了开始，不看了，太恶心了。</p>
<p>说一说一些命令，以及一些命令的参数：</p>
<h2 id="4-1-javac-命令"><a href="#4-1-javac-命令" class="headerlink" title="4.1 javac 命令"></a>4.1 javac 命令</h2><p>肯定都用过这个东西，有个小知识点得说一说，使用这个命令的时候如果加上 -g 参数，就会生成局部变量表，不加的话，是没有局部变量表的。</p>
<p>idea 或者 eclipse 给我们编译都会把局部变量表编译出来。</p>
<p>其他参数：</p>
<ul>
<li><p>-version，返回 javac所在的jdk的版本，而不是class是被哪个jdk生成的，和class文件没关系，直接 javac -version就行了</p>
</li>
<li><p>-public，仅显示当前class中的公开成员</p>
</li>
<li><p>-protected，显示当前class中的高于protected成员</p>
</li>
<li><p>-p、-private，显示高于private成员</p>
</li>
<li><p>-package，显示程序包&#x2F;受保护的&#x2F;公开类 和成员</p>
</li>
<li><p>-sysinfo，显示正在处理的类的系统信息，比如路径，大小，md5，散列 等等信息。</p>
</li>
<li><p>-constants，显示静态常量，和上面的其实差不多，只是上面的显示常量不显示值，这里会显示值而已。</p>
</li>
</ul>
<h2 id="4-2-javap命令"><a href="#4-2-javap命令" class="headerlink" title="4.2 javap命令"></a>4.2 javap命令</h2><p>也用过吧，这玩意用来反编译的，参数如下：</p>
<ul>
<li><p>-s，输出内部类型签名，其实就是返回每个成员的描述信息</p>
</li>
<li><p>-l，返回行号和局部变量表，前提是你得有局部变量表</p>
</li>
<li><p>-c，对代码进行反汇编，挺高深奥，其实就是返回你每个方法的code属性，代码都给你转成jvm指令</p>
</li>
<li><p>-v、-verbose，输出附加信息，包括行号，本地变量表，反汇编等详细信息。简单说，一个v包括上面的所有东西，但是不包括私有，你要包括私有咋办，直接 <code>javap -v -p xxx.class</code></p>
</li>
</ul>
<p>常用的是 -v -c -l</p>
<p>顺带说一句，javap里面你看不到clinit和init，因为javap又给你还原成了你的构造方法，或者代码块。</p>
<h1 id="5-字节码指令"><a href="#5-字节码指令" class="headerlink" title="5. 字节码指令"></a>5. 字节码指令</h1><p>字节码指令，首先众所周知，分为两个部分，操作符 和 操作数，然后每个操作符都会有一个助记符，说白了，就是每一个指令，都会有一个对应的16进制数字来表示，方便在字节码文件中体现，然后助记符后面又会有一个16进制操作数。这就是一个指令具体在字节码中的结构。</p>
<h2 id="5-1-执行模型"><a href="#5-1-执行模型" class="headerlink" title="5.1 执行模型"></a>5.1 执行模型</h2><p>jvm执行指令的流程，如果不考虑异常处理的话，可以概括成以下过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    自动计算PC寄存器的值 + <span class="number">1</span>;</span><br><span class="line">    根据PC寄存器的值到相应的地方取出指令;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(指令存在操作数)</span><br><span class="line">        取出操作数;</span><br><span class="line"></span><br><span class="line">    执行操作码对应的操作;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(字节码长度 &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="5-2-字节码数据类型"><a href="#5-2-字节码数据类型" class="headerlink" title="5.2 字节码数据类型"></a>5.2 字节码数据类型</h2><p>一般情况下，字节码指令是有数据类型区分的，比如 iload，这个i就是int，fload 自然就是 load float。常见的数据类型：</p>
<ul>
<li><p>int -&gt; i</p>
</li>
<li><p>float -&gt; f</p>
</li>
<li><p>double -&gt; d</p>
</li>
<li><p>char -&gt; c</p>
</li>
<li><p>byte -&gt; b</p>
</li>
<li><p>short -&gt; s</p>
</li>
<li><p>long -&gt; l</p>
</li>
</ul>
<p>需要注意的是，绝大多数指令对于整数，一般不支持 byte short char，甚至不支持 boolean，其实在运算的时候，会通过带符号扩展 变为 int，而对于boolean，boolean这会通过 零位扩展转化为char进行运算。这个规则也适用于数组，数组里面的各个元素也会转为int。所以大部分对于 char byte short boolean 的操作，其实都是用int操作的。</p>
<h2 id="5-3-指令分类"><a href="#5-3-指令分类" class="headerlink" title="5.3 指令分类"></a>5.3 指令分类</h2><p>指令，那太多了，所以我们先分个类，对于字节码指令，有以下分类：</p>
<ul>
<li><p>加载与存储指令</p>
</li>
<li><p>算数指令</p>
</li>
<li><p>类型转换指令</p>
</li>
<li><p>对象的创建和访问指令</p>
</li>
<li><p>操作数栈管理指令</p>
</li>
<li><p>比较控制指令</p>
</li>
<li><p>异常处理指令</p>
</li>
<li><p>同步控制指令</p>
</li>
</ul>
<p>注意：</p>
<p>一个指令，可以从局部变量表，常量池，堆中对象，方法调用，系统调用中获取数据，这些数据会压入操作数栈</p>
<p>一个指令，也可以从操作数栈获取多个数据，也就是pop多次，然后可以进行各种操作，然后结果还可以存入操作数栈</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-类加载</title>
    <url>/2022/06/13/classload/</url>
    <content><![CDATA[<p>类加载，说一说类加载的时候各种成员的初始化如何进行。</p>
<span id="more"></span>

<h1 id="1-类加载"><a href="#1-类加载" class="headerlink" title="1. 类加载"></a>1. 类加载</h1><p>是的，字节码说完了，然后就是下面的一大块东西：类加载。</p>
<p>之前学Java反射的时候了解过，类加载分为5个阶段，如下：</p>
<ul>
<li>加载：通过类加载器加载一个二进制流数据</li>
<li>链接：又分为 验证 准备 解析 三个阶段</li>
<li>初始化</li>
<li>使用：比如调用方法，创建对象等</li>
<li>卸载</li>
</ul>
<p>后面我们就开始着重看这5个阶段。</p>
<h1 id="2-类加载-Loading-阶段"><a href="#2-类加载-Loading-阶段" class="headerlink" title="2. 类加载 Loading 阶段"></a>2. 类加载 Loading 阶段</h1><h2 id="2-1-加载的理解"><a href="#2-1-加载的理解" class="headerlink" title="2.1 加载的理解"></a>2.1 加载的理解</h2><p>什么是加载，或者说loading阶段到底干了啥？很简单，类加载器读取一大堆二进制流，然后转化成一个类模版对象，然后把这个类模版对象存储到方法区。这样在运行时，我们就可以通过反射来获取类的属性，比如这个类的属性，方法等。</p>
<p>但是需要注意的是，这个类模版，并不是我们获取的 Class对象，不是的，两回事，有关系，但不是一个。</p>
<h2 id="2-2-加载完成的操作"><a href="#2-2-加载完成的操作" class="headerlink" title="2.2 加载完成的操作"></a>2.2 加载完成的操作</h2><p>就是一件事，读取class文件，生成类模版。具体说 JVM 需要完成下面三件事：</p>
<ul>
<li>获取类的全限定命名，从而得到这个类的class文件，进而获取二进制流（当然这个流可以从数据库中获得，获取其他的方式，总之，要的就是二进制流）；</li>
<li>解析这个二进制流，生成对应的Java类模版，存储在方法区</li>
<li>创建 Class对象，这个对象作为方法区类模版的访问入口，也就是说，Class对象其实是指向了方法区中的模版。</li>
</ul>
<h2 id="2-3-类模版和Class的位置"><a href="#2-3-类模版和Class的位置" class="headerlink" title="2.3 类模版和Class的位置"></a>2.3 类模版和Class的位置</h2><p>在完成类加载后，会在方法区（jdk8的话就是元空间）生成一个类模版对象，然后又会在堆中，没错，就是堆中，生成这个类的Class对象，然后这个Class指向了方法区中的类模版，然后我们就可以通过Class得到类的属性。</p>
<p>只是作为了解，不展开说，挺复杂的东西。</p>
<h2 id="2-4-数组类的创建"><a href="#2-4-数组类的创建" class="headerlink" title="2.4 数组类的创建"></a>2.4 数组类的创建</h2><p>数组比较特殊，数组并不是类加载器创建的，而是JVM根据你数组类型和数组维度动态创建的，过程如下：</p>
<ul>
<li>如果数组是引用数据类型，那么JVM则会根据需要 递归的去加载数据类型</li>
<li>根据数组所需要的数据类型和数组维度，JVM动态的声明数组</li>
</ul>
<h1 id="3-链接阶段"><a href="#3-链接阶段" class="headerlink" title="3. 链接阶段"></a>3. 链接阶段</h1><p>众所周知，链接阶段分为三个步骤：验证，准备，解析。ok，我们一个一个说：</p>
<h2 id="3-1-验证阶段"><a href="#3-1-验证阶段" class="headerlink" title="3.1 验证阶段"></a>3.1 验证阶段</h2><p>所谓验证阶段，那肯定就是验证文件是否合法这种的。所以在这一步，它主要验证一下内容：</p>
<ul>
<li>格式检查：检查字节码的魔数，版本以及指令长度等其他信息（没有在方法区中生成类模版）</li>
<li>语义检查：检查有没有格式错误，比如继承final，是否存在父类，抽象方法有没有实现等（这个时候已经在方法区中生成了模版）</li>
<li>字节码验证：跳转指令的跳转位置是否合法，函数调用传参类型是否正确，变量赋值的类型是否一致 等。</li>
<li>符号引用验证：符号引用是否有直接饮用</li>
</ul>
<p>这个阶段有个特殊的东西：StackMapTable 栈映射帧，是干嘛的呢？用来检测操作数栈中的数据类型和局部变量表的数据类型是否匹配，然而并不能100%判断字节码没错，只是尽可能的判断。</p>
<p>第四步的符号引用验证，简单说就是：常量池中有个ClassRefInfo信息，比如指向了一个 java.lang.String，这里就需要判断这个 String 是否存在，既视感这个的。</p>
<p>顺带一提，验证阶段和加载阶段分的没有那么开，一般都是同时进行的。</p>
<h2 id="3-2-准备阶段"><a href="#3-2-准备阶段" class="headerlink" title="3.2 准备阶段"></a>3.2 准备阶段</h2><p>准备阶段 Preparation，简单说，就是给这个类的静态变量（注意，是变量，是变量，不是常量，static final 可不在这里处理）分配内存空间，并给他们赋一个默认值，这个默认值应该不用说了吧，数字类型都是0，boolean是false，ref 是 null。</p>
<p>注意：</p>
<ul>
<li>说过了，这里不对final进行操作，static final 的常量在编译的时候就已经被显式的赋值了，在准备阶段静态常量已经有值了。</li>
<li>这里不对实例变量进行操作，类变量的内存被分配到了方法区，和类模版在一起，实例变量则是在堆中，和对象在一起。</li>
<li>这个过程没有任何的代码被执行</li>
</ul>
<p>有个特殊情况，如果有如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;CONST&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个属性的赋值也是在编译阶段完成的，但是仅限于通过字面量给String赋值，如果你是 new String，那也就不行了。</p>
<h2 id="3-3-解析阶段"><a href="#3-3-解析阶段" class="headerlink" title="3.3 解析阶段"></a>3.3 解析阶段</h2><p>解析 Resolution 阶段，简单说，把符号引用替换成直接饮引用。听不懂是吧，来，举个例子：</p>
<p>我们都已经学过字节码了，字节码文件中有常量池没毛病吧，比如常量池中有个常量 Methodref_info 这个信息，这个信息里面有两部分：Class_name 和 Name_And_Type，然后这俩又是俩常量池索引，比如：Class_name #3， Name_and_type #8。这里非常的敷衍，就告诉你是 #3和#8，和内存完全没关系，这就是符号引用。</p>
<p>这个阶段下，你不能在敷衍的告诉我 Class_name 是#3啦，太费劲了，咋办，比如这个Methodref_info是 System.out.println() 方法，行，这里你得具体告诉我 System.out 这个 Class_name 的真实内存地址，#3我不认可啦，那么在这个阶段下，Class_name #3 Name_and_type #8 就被替换成了：</p>
<p>同时，JVM会给每个类提供一个方法表，那么你这个println方法在方法表中是第几个位置，这个就相当于方法的直接引用。</p>
<h1 id="4-初始化阶段"><a href="#4-初始化阶段" class="headerlink" title="4. 初始化阶段"></a>4. 初始化阶段</h1><blockquote>
<p>create  by  陈HL_pthef on  2021&#x2F;11&#x2F;4 下午6:58</p>
</blockquote>
<h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>初始化阶段，简单说就是给static进行赋值。很重要的一点，在初始化阶段，真正的涉及一些Java代码的执行。</p>
<p>这个过程最重要的就是生成 &lt;clinit&gt; 方法，这个方法主要就是用来给static赋值的，他会按顺序收集你类中所有的static赋值语句（包括static代码块），整合到一起，然后生成 clinit方法，这个方法只能由JVM生成，并由JVM调用。</p>
<h2 id="4-2-说明"><a href="#4-2-说明" class="headerlink" title="4.2 说明"></a>4.2 说明</h2><ul>
<li><p>一个类调用 clinit 方法时，总会先去调用 父类的clinit方法，所以说，父类的static代码块优先级高于子类</p>
</li>
<li><p>什么情况下不会生成 clinit方法：</p>
<ul>
<li>一个类压根没有静态</li>
<li>有静态，但是没有赋值，就是光秃秃一个 <code>public static int num;</code></li>
<li>有静态，也有赋值，但是这个静态是常量，而且赋值的方式还是字面量赋值，也不会clinit。</li>
</ul>
</li>
</ul>
<h2 id="4-3-static-final-显式赋值到底发生在哪个阶段？"><a href="#4-3-static-final-显式赋值到底发生在哪个阶段？" class="headerlink" title="4.3 static final 显式赋值到底发生在哪个阶段？"></a>4.3 static final 显式赋值到底发生在哪个阶段？</h2><p>这玩意，越来越不会了，太恶心了。</p>
<p>首先，看最简单的；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">I</span> <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>这个倒是好说，i 肯定是在clinit中赋值，然后 I 是在链接阶段的准备环节赋的值，所以说，是不是final修饰的就一定不在clinit中赋值？再看下面这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">int1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">INT2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>这俩是在哪赋的值？直接说，这俩都是在 clinit 中赋值。那我们又猜，是不是说 引用数据类型不管是不是final都在clinit中赋值？再看下面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello1&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">S</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这俩都是引用，在哪里赋值啊？s 在准备阶段，S 在clinit赋值。</p>
<p>所以说，总结一下，什么情况下会在链接阶段的准备过程赋值：</p>
<ul>
<li>大前提，static final 修饰的</li>
<li>基本数据类型，给他赋一个确定的值，且不需要代码支持（比如 new Random().random() 这种的），在准备过程赋值</li>
<li>字符串，且通过字面量的形式给他赋值，也发生在准备阶段。</li>
</ul>
<p>首先明确的是，绝对不是说 static final 就一定在准备阶段完成赋值。</p>
<h2 id="4-4-clinit-方法的线程安全问题"><a href="#4-4-clinit-方法的线程安全问题" class="headerlink" title="4.4 clinit 方法的线程安全问题"></a>4.4 clinit 方法的线程安全问题</h2><p>首先，clinit是线程安全的，但是这个方法的访问修饰只有static，并没有synchronized，所以他这个锁是一个隐式的锁，JVM给自动加的。</p>
<p>正是因为这玩意线程安全，所以说如果一个类的clinit过于繁琐，耗时较长，则会导致很多线程阻塞，有可能导致死锁。</p>
<h2 id="4-5-类的主动使用和被动使用问题"><a href="#4-5-类的主动使用和被动使用问题" class="headerlink" title="4.5 类的主动使用和被动使用问题"></a>4.5 类的主动使用和被动使用问题</h2><p>首先，主被动使用会影响啥？不是说一个类被动使用就不会加载了，不是的，一个类要用，那就肯定需要加载，但是如果一个类是被动使用的，那么这个 初始化阶段是很有可能不执行的。注意，仅限于初始化阶段不执行。那么初始化阶段不执行就可能导致结果不一致。</p>
<p>顺带一提，这里说的使用不是说的类的第四个阶段：使用。更多说的是首次使用。</p>
<h3 id="4-5-1-类的主动使用"><a href="#4-5-1-类的主动使用" class="headerlink" title="4.5.1 类的主动使用"></a>4.5.1 类的主动使用</h3><p>类的主动使用会调用 &lt;clinit&gt;() 方法，也就是会经过初始化过程。</p>
<ul>
<li><p>创建一个类的实例，比如 new，通过反射，反序列化（是的，反序列化也是主动使用）</p>
</li>
<li><p>调用类的静态方法，对应指令就是执行 invokestatic 指令，很简单，不说了</p>
</li>
<li><p>操作类的静态字段（static修饰的，没有final），对应指令就是 getstatic 和 putstatic。同时还有接口的静态字段。</p>
<p>这里得特别说明：并不是绝对的，不是说我们操作static final 就一定不触发初始化。我认为是啥呢，就是说你这个static final 是不是在&lt;clinit&gt;() 中被赋值，如果是，那么这里你操作static final也照样会触发初始化，如果不是，那这里就不触发初始化。</p>
<p>同时，对于接口，也是差不多的道理，如果接口中的 static final 不需要代码支持，那就不会clinit，如果需要，那就也会被初始化</p>
</li>
<li><p>使用反射类的方法，比如 Class.forName() 这种的，触发初始化。</p>
</li>
<li><p>初始化子类之前，会初始化父类。</p>
<p>特殊：JVM加载一个类，要求是所有父类都必须初始化，但是这条规则并不适用与接口。</p>
<ul>
<li>初始化一个类，并不会初始化他所有实现的接口</li>
<li>初始化一个接口，并不会初始化他继承的所有的类</li>
</ul>
<p>只有当程序首次使用特定字段的时候才会触发接口的初始化。</p>
</li>
<li><p>如果你的接口存在default 方法，那么直接或间接实现这个接口的类 触发了初始化，那么这个接口也会被初始化</p>
</li>
<li><p>当虚拟机启动时，用户会指定一个主类，那么JVM会优先家在这个主类</p>
</li>
<li><p>使用 MethodHandle 类，JVM会初始化这个方法指向的方法所在的类</p>
<p>我猜啊，这个类是用来调用方法的，他可以调用任何一个类的任何一个方法（不绝对啊，private我不知道行不行）</p>
</li>
</ul>
<h3 id="4-5-2-类的被动使用"><a href="#4-5-2-类的被动使用" class="headerlink" title="4.5.2 类的被动使用"></a>4.5.2 类的被动使用</h3><p>被动使用，就是类加载不会经过初始化过程。</p>
<ul>
<li>访问static字段，只有真正定义了这个static字段的类才会被初始化。举个例子，父类有个static，然后我们通过子类访问这个字段，最终被初始化的只有父类，自卑不会被初始化。具体看 cn.chl.PassiveUse</li>
<li>创建引用数据类型数组，数组数据类型对应的类不会初始化。就是说你 XXX[] a &#x3D; new XXX[10]; 这个时候 XXX 不会初始化，只有 a[0] &#x3D; new XXX() 的时候才会初始化（废话）</li>
<li>访问类的 final static（具体得看你这个final static需不需要被clinit进行赋值，上面有说，具体问题具体分析）</li>
<li>调用 ClassLoader 的loadClass 方法，加载一个类，不会初始化</li>
</ul>
<h1 id="5-类卸载"><a href="#5-类卸载" class="headerlink" title="5. 类卸载"></a>5. 类卸载</h1><p>是的，类的使用没有说，废话，有啥说的，就是用呗。没的说。这里直接开始说类的卸载。</p>
<p>要想说明白这个类卸载，我们先要明白 类 类加载器 类实例 的关系。大致的关系就是：我们加载一个类，首先在方法区中创建这个类的模版，然后在堆区创建这个类的Class对象作为方法区模版的访问入口，同时这个类的类加载器也保存在堆区，加载器和Class互相指向，创建实例的话，实例也存在堆区，并指向Class对象。接下来我们具体说说每个部分。</p>
<h2 id="5-1-类-类加载器-类实例的关系"><a href="#5-1-类-类加载器-类实例的关系" class="headerlink" title="5.1 类  类加载器   类实例的关系"></a>5.1 类  类加载器   类实例的关系</h2><p>我们之前说过，JVM中的类加载器主要分为三类：</p>
<ul>
<li>BootstrapClassLoader：启动类加载器，或者说 引导类加载器，Java核心类库使用这个</li>
<li>ExtensionClassLoader：扩展类加载器，第三方jar包多数用这个</li>
<li>ApplicationClassLoader：应用程序类加载器，或者叫系统类加载器，我们自己写的用这个</li>
</ul>
<p>Class对象和ClassLoader之间双向关联，Class里面有个方法：<code>getClassLoader()</code> 方法，可以得到这个类的类加载器。所以大体结构如下：</p>
<p><img src="/../images/Class.png" alt="image-20211106131529171"></p>
<p>看的非常清楚，不再多说。</p>
<h2 id="5-2-类的生命周期"><a href="#5-2-类的生命周期" class="headerlink" title="5.2 类的生命周期"></a>5.2 类的生命周期</h2><p>简单说，什么时候一个类就被回收了？以上面这图来说，当 Sample 类的Class对象不再被引用，也就是不可触及时，Sample的生命周期结束，就会卸载方法区中的 Sample类模版。</p>
<p>看似简单，其实不然，我们通过上面这图可以看出，什么时候Class就不会被引用？</p>
<ul>
<li>没有任何的实例引用。没有实例，那么 Sample实例到Class的引用就相当于断开了</li>
<li>没有 Class对象的引用。这是废话</li>
<li>没有 Sample 类加载器的引用，这样 MyClassLoader的引用断开，就相当于Loader到Class的引用断开</li>
</ul>
<p>只有达到这三个条件，才说明类不再使用。</p>
<p>所以总结一下，卸载一个类，其实对应的就是方法区中的GC。方法区GC主要针对不再使用的常量和不再使用的类，常量好说，不用了呗，但是类，必须满足下面三个条件：</p>
<ul>
<li>这个类的所有实例，也包括派生子类的实例，全部被回收</li>
<li>类的ClassLoader被回收（这个条件极其难以达成，除非是被精心设计的一些类的类加载器）</li>
<li>没有引用指向 Class对象</li>
</ul>
<h2 id="5-3-类的卸载"><a href="#5-3-类的卸载" class="headerlink" title="5.3 类的卸载"></a>5.3 类的卸载</h2><ul>
<li>引导类加载器不可能被卸载，也就是说被引导类加载器加载的类，运行期间你是别想卸载了</li>
<li>系统类加载器和扩展类加载器被收集的可能性极小，因为在运行期间他们的类总是能被直接或者间接的指向</li>
<li>我们自己写的类加载器有可能被回收，但是仅限与在简单的上下文环境中，复杂环境下依旧是直接间接引用满天飞。而且就算是回收了加载器，我们也得强制调用GC方法</li>
</ul>
<p>方法区回收垃圾，时间是不确定的，而且效果也不好，因为没几个类是不用的。所以，千万不要在类卸载的前提下考虑业务。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收</title>
    <url>/2022/06/02/garbage-collect/</url>
    <content><![CDATA[<p>这章开始进入垃圾回收，只是这一章不讲垃圾回收的具体回收器，而是讲一下垃圾回收的一些基本概念。</p>
<span id="more"></span>

<h1 id="1-GC-垃圾收集"><a href="#1-GC-垃圾收集" class="headerlink" title="1. GC 垃圾收集"></a>1. GC 垃圾收集</h1><p>同理，首先明确几个概念：</p>
<ul>
<li><p>什么是垃圾</p>
</li>
<li><p>为啥要清理垃圾</p>
</li>
<li><p>垃圾回收机制</p>
</li>
</ul>
<h2 id="1-1-什么是垃圾"><a href="#1-1-什么是垃圾" class="headerlink" title="1.1 什么是垃圾"></a>1.1 什么是垃圾</h2><p>垃圾指的是，在程序运行期间没有任何指针指向的对象，这个对象就是垃圾。</p>
<p>如果不及时清理垃圾，这些垃圾对象就会一直存在占用空间，可能导致内存溢出。</p>
<h2 id="1-2-为什么要GC"><a href="#1-2-为什么要GC" class="headerlink" title="1.2 为什么要GC"></a>1.2 为什么要GC</h2><ul>
<li><p>对于高级语言来说，如果不进行GC，内存迟早消耗完，所以需要不断地分配内存和回收内存</p>
</li>
<li><p>除了垃圾回收，GC同时还能整理内存碎片，碎片整理把堆内存移到堆的一端，给新对象腾地方</p>
</li>
<li><p>业务越来越庞大，没有GC程序就没法运行，而经常GC会导致频繁地STW，所以就需要不断的对GC进行优化。</p>
</li>
</ul>
<h2 id="1-3-Java垃圾回收机制"><a href="#1-3-Java垃圾回收机制" class="headerlink" title="1.3 Java垃圾回收机制"></a>1.3 Java垃圾回收机制</h2><ul>
<li><p>自动内存管理，无需开发人员手动分配和释放，降低了内存溢出的可能性。</p>
</li>
<li><p>能让我们更专注于 业务逻辑的开发</p>
</li>
</ul>
<h1 id="2-GC-机制与算法-标记阶段"><a href="#2-GC-机制与算法-标记阶段" class="headerlink" title="2. GC 机制与算法-标记阶段"></a>2. GC 机制与算法-标记阶段</h1><p>大纲：</p>
<ul>
<li><p>标记阶段：引用计数算法</p>
</li>
<li><p>标记阶段：可达性分析算法</p>
</li>
<li><p>对象的 finalization 机制</p>
</li>
<li><p>MAT和JProfiler 的 GC roots 溯源</p>
</li>
<li><p>清除阶段：标记清除算法</p>
</li>
<li><p>清除阶段：复制算法</p>
</li>
<li><p>清除阶段：标记-压缩 算法</p>
</li>
</ul>
<h2 id="2-1-垃圾标记阶段"><a href="#2-1-垃圾标记阶段" class="headerlink" title="2.1 垃圾标记阶段"></a>2.1 垃圾标记阶段</h2><ul>
<li><p>在堆中存放着几乎所有的Java实例，在回收之前，首先要区分哪些是存活对象，哪些对象已经死了，只有已经死亡的对象，GC才会在收集的时候释放他们的内存，这个区分死活的阶段就是<strong>垃圾标记阶段</strong></p>
</li>
<li><p>如何判断一个对象已经死了？就是，没有任何指针指向他，不被任何存活对象引用，那他就死了</p>
</li>
<li><p>判断没有引用的算法有两个：<strong>引用计数算法</strong> 和 <strong>可达性分析算法</strong></p>
</li>
</ul>
<h3 id="2-1-1-引用计数算法"><a href="#2-1-1-引用计数算法" class="headerlink" title="2.1.1 引用计数算法"></a>2.1.1 引用计数算法</h3><ul>
<li><p>Reference Counting，比较简单，就是给每一个对象保留一个引用计数器来记录被引用的情况</p>
</li>
<li><p>当一个对象引用A对象，A的计数器+1，同理，引用失效，计数器 - 1</p>
</li>
<li><p>优点：实现简单，垃圾对象便于标识；判定效率高，没有延迟</p>
</li>
<li><p>缺点：</p>
<ul>
<li><p>需要另外的字段存储计数器，有额外存储空间开销</p>
</li>
<li><p>每次操作都需要更新计数器，伴随着 - + 操作，额外时间开销</p>
</li>
<li><p>无法处理循环引用问题，导致 Java 垃圾回收器不使用这个东西</p>
<blockquote>
<p>什么叫循环引用：</p>
<p><img src="/images/gc/gc_ref_counting.png"></p>
<p>如上图第二种情况，如果三个对象循环引用，那么根据技术算法，他们的计数器都是1，不是0，但是其实，这三个对象已经是垃圾了，但是由于算法问题，这个垃圾不被回收。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>小结：</p>
<ul>
<li><p>引用计数算法是很多语言的标记算法，比如python</p>
</li>
<li><p>具体场景下，可能还会使用引用计数，来提高系统的吞吐量</p>
</li>
<li><p>Java没有选择引用计数是因为循环依赖不好处理</p>
</li>
<li><p>python如何解决循环依赖：1. 解除相互之间的引用；2.引入强引用和弱引用</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-1-2-可达性分析算法-根搜索，追踪性垃圾收集"><a href="#2-1-2-可达性分析算法-根搜索，追踪性垃圾收集" class="headerlink" title="2.1.2 可达性分析算法(根搜索，追踪性垃圾收集)"></a>2.1.2 可达性分析算法(根搜索，追踪性垃圾收集)</h3><ul>
<li><p>相对引用计数来说，可达算法同样简单高效，而且这个算法可以很好的解决循环引用问题</p>
</li>
<li><p>Java C# 都采用可达算法</p>
</li>
</ul>
<p>说先说一个基本概念：GC Roots：一个必须活跃的引用集合，在这个基础上，进行可达性分析算法的基本思路</p>
<ul>
<li><p>以GC Roots 为起始点，往下<strong>搜索被根对象集合连接的目标对象是否可达</strong></p>
</li>
<li><p>经过可达性分析后，内存中存活的对象直接或间接的被根对象集合连接着，搜索过的路径就叫做 <strong>引用链</strong></p>
</li>
<li><p>如果目标对象没有被任何引用链相连，则不可达，说明对象已经死亡，需要被收集</p>
</li>
<li><p>可达算法中，只有被根对象集合直接或间接引用的对象，才是存活对象</p>
</li>
<li><p>可达性分析必须在数据的快照中进行，来保证数据一致性</p>
</li>
<li><p>这个算法会导致 STW，即使是号称不会STW的CMS(新的垃圾回收器)，在枚举根节点的时候也是会停顿的。</p>
</li>
</ul>
<h2 id="2-2-详细说说-GC-Roots"><a href="#2-2-详细说说-GC-Roots" class="headerlink" title="2.2 详细说说 GC Roots"></a>2.2 详细说说 GC Roots</h2><p>GC Roots 中包含一下内容：</p>
<ul>
<li><p>虚拟机栈中引用的对象，比如方法参数和局部变量</p>
</li>
<li><p>本地方法栈中 JNI(本地方法) 中引用的对象</p>
</li>
<li><p>方法区中，类的静态属性引用的对象</p>
</li>
<li><p>方法区中，常量引用的对象</p>
</li>
<li><p>被同步锁 synchronized 所持有的对象</p>
</li>
<li><p>JVM内部的引用，比如基本数据类型的 Class，各种异常等常驻对象</p>
</li>
<li><p>除了这些以外，根据用户所选用的垃圾收集器和和内存区域不同，还可能有其他的对象临时加入roots，举个例子就是 分代收集和局部回收。就是说，你要收集堆中年轻代的数据，那么年轻代外面，老年代的数据也可能被认为是roots。</p>
</li>
<li><p>可以这么认为，如果一个指针指向堆中的一个对象，但是这个指针不在堆中，那么他就可能是 root，那么根据上面所说的分代回收，我认为可以这么理解，指针指向了一个待回收区域但是指针不在这个区域，对于这个区域来说，这个指针就是 root。当然，这个区域一般都是堆，毕竟只有 堆 和 方法区有垃圾收集，而且方法区一般不收集。</p>
</li>
</ul>
<p>我觉得可以这么理解，如果GC区域不同，那么GC Roots 也就不确定，GC Roots归根到底就是除了这个被回收区域以外有可能用到这个区域中对象的地方，就是GC Roots，比如我们要收集堆，那么堆中的对象大多被栈指向，所以栈在这里就是堆的GC Roots，那么如果我们要回收年轻代，那么老年代也有可能是GC Roots。</p>
<h2 id="2-3-对象的-finalize机制"><a href="#2-3-对象的-finalize机制" class="headerlink" title="2.3 对象的 finalize机制"></a>2.3 对象的 finalize机制</h2><p>对象Object内有一个方法：finalize() 方法，这个方法是对象被GC的时候，释放之前，会调用这么一个方法，有那么点类似于析构函数，我们最好不要手动去调用他，最好让JVM去调用他。</p>
<p>就是因为finalize的存在，导致一个对象在虚拟机中存在三种状态：</p>
<ul>
<li><p>可触及的：GC Roots 连接的对象，肯定是存活的</p>
</li>
<li><p>可复活的：对象的所有引用都被释放，但是对象可能在 finalize方法中复活</p>
</li>
<li><p>不可触及的：对象的finalize方法被调用，且对象没有复活，那么这个对象就是不可触及的，一个不可触及的对象肯定不能复活，因为一个对象的finalize方法只能调用一次。</p>
</li>
</ul>
<p>只有不可触及的对象，才会被回收。</p>
<h2 id="2-4-总结标记过程"><a href="#2-4-总结标记过程" class="headerlink" title="2.4 总结标记过程"></a>2.4 总结标记过程</h2><p>就因为有finalize方法的存在，gc不能仅仅通过引用链来判断是否回收，总共需要两次标记：</p>
<ul>
<li><p>如果对象到GC Roots 之间没有引用链，进行第一次标记</p>
</li>
<li><p>进行筛选，判断该对象的finalize方法有没有必要执行：</p>
<ul>
<li><p>如果对象没有重写 finalize 方法或者 finalize方法已经被调用过了，则被判定位不可触及对象</p>
</li>
<li><p>如果对象重写了finalize方法，且还未执行过，则会把这个对象插入F-Queue 中，一个被虚拟机自动创建的，低优先级的线程 Finalizer，挨个触发队列里面的finalize方法。</p>
</li>
<li><p>finalize方法是对象最后逃离死亡的机会，稍后GC会对 F-Queue里面的对象进行第二次标记，如果调用finalize，方法里面和引用链中任何一个对象建立了联系，那么这个对象就被移出“即将回收集合”。之后，如果对象再次没有引用的情况，这时finalize方法不会调用，finalize方法只执行一次，然后对象直接变成不可触及。</p>
</li>
</ul>
</li>
</ul>
<h2 id="省略"><a href="#省略" class="headerlink" title="省略"></a>省略</h2><p>中间差了一堆东西，有堆相关工具的使用，以后有需要看 P144 - P146</p>
<h1 id="3-GC-清理阶段"><a href="#3-GC-清理阶段" class="headerlink" title="3. GC -清理阶段"></a>3. GC -清理阶段</h1><p>成功区分出存活对象和死亡对象后，JVM要进行下一步，也就是清理垃圾，释放内存，给下面的对象腾地方</p>
<p>具体算法下面三个：</p>
<ul>
<li><p>复制算法 Copying</p>
</li>
<li><p>标记-清除 算法 Mark-Sweep</p>
</li>
<li><p>标记-压缩 算法 Mark-Compact</p>
</li>
</ul>
<h2 id="3-1-标记清除算法"><a href="#3-1-标记清除算法" class="headerlink" title="3.1 标记清除算法"></a>3.1 标记清除算法</h2><p>标记清除是一个比较低级，常见的垃圾回收算法，第一次被用在 Lisp语言上(Lisp：世界上第一个有GC的语言)。</p>
<h3 id="3-1-1-执行过程"><a href="#3-1-1-执行过程" class="headerlink" title="3.1.1 执行过程"></a>3.1.1 执行过程</h3><p>当内存满了以后，就会停止整个程序(包括用户线程，这个停止就叫 Stop The World，也就是我们说的 STW)，然后进行下面两件事：</p>
<ul>
<li><p>Collector进行标记，从GCRoots 开始遍历可达对象(很显然就是我们前面说的可达性分析算法)，在对象头header中标记这是个可达对象，被引用对象，注意，标记的不是垃圾，没被标记的才是垃圾。</p>
</li>
<li><p>Collector进行清理，遍历对象，检查对象头的可达标记，如果没有，则被回收。</p>
</li>
</ul>
<h3 id="3-1-2-缺点"><a href="#3-1-2-缺点" class="headerlink" title="3.1.2 缺点"></a>3.1.2 缺点</h3><ul>
<li><p>效率不高，主要原因就是需要遍历，怎么遍历的？递归</p>
</li>
<li><p>在GC的时候需要停止整个程序，用户体验不好</p>
</li>
<li><p>清理出来的内存不是连续的，所以同时还需要维护一个内存空闲列表，我们之前说对象内存分配的时候 Chapter07-23 下说过。</p>
</li>
</ul>
<h3 id="3-1-3-注-清除到底指的啥"><a href="#3-1-3-注-清除到底指的啥" class="headerlink" title="3.1.3 注:清除到底指的啥"></a>3.1.3 注:清除到底指的啥</h3><p>清除指的不是说直接这块内存上的东西就清空了，并非。</p>
<p>垃圾还会留着，但是内存地址会写到空闲列表中，如果再次分配对象，新对象会覆盖垃圾对象。</p>
<h2 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h2><p>为了解决标记清除算法低效的问题，提出的复制算法，这个算法同理 堆中年轻代的GC。</p>
<p>思路：</p>
<p>将内存分为两半，一半空着，另一半放数据，当数据区进行垃圾回收时，同理先进行可达性分析，但是，在分析的同时，如果发现对象是可达的，就会把对象复制到另一半内存中，不是复制内存地址，而是整个对象拷贝(拷贝肯定是规整的拷贝)。然后可达性分析完成，数据也就全部复制到另一半，就说明当前这块内存已经没有有用数据了，全都是垃圾，所以直接清理这一半内存即可。然后下一次GC，把对象全都复制到这里即可。</p>
<h3 id="3-2-1-优点"><a href="#3-2-1-优点" class="headerlink" title="3.2.1 优点"></a>3.2.1 优点</h3><ul>
<li><p>简单，快速</p>
</li>
<li><p>复制以后内存连续，不会出现内存碎片</p>
</li>
</ul>
<h3 id="3-2-2-缺点"><a href="#3-2-2-缺点" class="headerlink" title="3.2.2 缺点"></a>3.2.2 缺点</h3><ul>
<li>需要两倍大的内存空间</li>
</ul>
<h3 id="3-2-3-注意"><a href="#3-2-3-注意" class="headerlink" title="3.2.3 注意"></a>3.2.3 注意</h3><p>如果空间的存活对象多，那一次直接全盘复制一轮，垃圾没几个，就会导致效率过低。</p>
<p>这个算法的应用场景最好是存活对象不太多的时候。垃圾多，复制的少，就会效率高。所以这就解释了为啥新生代采用类似这个算法来GC，原因就是新生代的对象大多数朝生暮死。</p>
<h2 id="3-3-标记-压缩-整理-算法"><a href="#3-3-标记-压缩-整理-算法" class="headerlink" title="3.3 标记-压缩(整理) 算法"></a>3.3 标记-压缩(整理) 算法</h2><h3 id="3-3-1-背景"><a href="#3-3-1-背景" class="headerlink" title="3.3.1 背景"></a>3.3.1 背景</h3><p>复制算法适用于存活对象少，垃圾多的地方，比如新生代，所以新生代采用复制算法，但是老年代普遍对象比较大，岁数大，复制算法不再适用，所以基于老年代，就需要其他的垃圾收集算法。</p>
<p>标记清除算法可以用在老年代，但是效率底下，会产生内存碎片，所以JVM在次基础上，退出了 标记压缩算法。</p>
<h3 id="3-3-2-执行过程"><a href="#3-3-2-执行过程" class="headerlink" title="3.3.2 执行过程"></a>3.3.2 执行过程</h3><p>第一阶段和标记清除算法一样，也是需要进行遍历标记。</p>
<p>然后，将所有存活对象按顺序压缩到内存的一端，然后这一端以外的对象全部清除。</p>
<h3 id="3-3-3-优点"><a href="#3-3-3-优点" class="headerlink" title="3.3.3 优点"></a>3.3.3 优点</h3><ul>
<li><p>解决了标记清除算法中 内存碎片的问题</p>
</li>
<li><p>解决了复制算法中内存双倍的问题</p>
</li>
</ul>
<h3 id="3-3-4-缺点"><a href="#3-3-4-缺点" class="headerlink" title="3.3.4 缺点"></a>3.3.4 缺点</h3><ul>
<li><p>效率低于复制算法</p>
</li>
<li><p>移动数据时，指针的指向需要修改</p>
</li>
<li><p>移动过程中 STW</p>
</li>
</ul>
<h1 id="4-垃圾收集拓展"><a href="#4-垃圾收集拓展" class="headerlink" title="4. 垃圾收集拓展"></a>4. 垃圾收集拓展</h1><p>拓展两个东西：</p>
<ul>
<li><p>增量收集算法</p>
</li>
<li><p>分区算法</p>
</li>
</ul>
<p>这两个算法都是为了提高垃圾收集效率，降低STW。</p>
<h2 id="4-1-增量收集算法"><a href="#4-1-增量收集算法" class="headerlink" title="4.1 增量收集算法"></a>4.1 增量收集算法</h2><p>我们之前看三种垃圾收集算法，有个共同的特点，就是STW时间长，垃圾攒的太多了，一次收集有点费劲，所以出现了增量收集算法。</p>
<p>思想如下：</p>
<p>弄一个GC线程，一个用户线程，咱们也别等到他内存沾满了GC，咱们直接 用户线程和GC线程交替执行，这样就会节省GC时间，减短STW时间，特别好。</p>
<p>然而问题就是：切换线程也很消耗资源。</p>
<h2 id="4-2-分区算法"><a href="#4-2-分区算法" class="headerlink" title="4.2 分区算法"></a>4.2 分区算法</h2><p>众所周知，堆空间越大，收集的区域越大，收集就越费劲，所以我们干脆把堆分成n多不同小区域，分开收集，这样就可以降低消耗时间，降低STW。</p>
<p>分代算法把对象分为了年轻代和老年代，分区算法就是把整个堆分成了若干小区域。</p>
<p>每个区域独立分配，独立回收，好处就是可以控制一次收集多少个区域。</p>
<p>缺点：可能会导致GC 频繁，线程切换频率提高，降低吞吐量。</p>
<h1 id="5-垃圾回收的相关概念"><a href="#5-垃圾回收的相关概念" class="headerlink" title="5. 垃圾回收的相关概念"></a>5. 垃圾回收的相关概念</h1><ul>
<li><p>System.gc() 的理解</p>
</li>
<li><p>内存溢出与泄露</p>
</li>
<li><p>Stop The World</p>
</li>
<li><p>垃圾回收的并行与并发</p>
</li>
<li><p>安全点与安全区域：只有在安全点才能停止用户线程</p>
</li>
</ul>
<h2 id="5-1-System-gc"><a href="#5-1-System-gc" class="headerlink" title="5.1 System.gc()"></a>5.1 System.gc()</h2><blockquote>
<p>本地方法，System.gc() 调用 Runtime.getRuntime().gc()</p>
</blockquote>
<p>我们可以通过 System.gc() 和 Runtime.getRuntime().gc() 来显式调用 FullGC(对整个堆进行回收)。</p>
<p>但是同时，JVM附带一个免责声明，JVM不保证你调用gc() 就一定能执行GC。</p>
<p>一般情况下，GC应该是自动进行的，不应该是我们手动进行，否则就太麻烦了，有一种应用场景是我们要写一个性能基准，我们手动调用gc。</p>
<p>所以说，我们可以认为 System.gc() 是提醒JVM进行垃圾收集，至于JVM干不干活？不知道。</p>
<p>详细请看：pri.TestSystemGC 和 pri.LocalVarGC</p>
<h2 id="5-2-内存溢出-Out-Of-Memory"><a href="#5-2-内存溢出-Out-Of-Memory" class="headerlink" title="5.2 内存溢出(Out Of Memory)"></a>5.2 内存溢出(Out Of Memory)</h2><p>首先，什么叫内存溢出：java给的解释是，内存不够了，而且gc完了也不够，那就内存溢出</p>
<p>为什么会内存溢出：</p>
<ul>
<li><p>堆空间大小设置的不够</p>
</li>
<li><p>大对象太多而且不能回收，最后就会沾满。jdk7中会抛出：java.lang.OutOfMemory: PermGen space; jdk8中则会抛出：java.lang.OutOfMemory: Metaspace</p>
</li>
</ul>
<p>这里可以看出，再抛出 OOM 之前，肯定要触发一次GC，去尽可能腾出空间</p>
<ul>
<li>比如：他会尝试去回收软引用指向的对象</li>
</ul>
<p>但是，也并非任何情况下都会进行GC，如果我们要分配一个超大的对象，JVM判断整个堆压根就不够用，GC没有意义，就不会GC，直接抛出OOM。</p>
<h2 id="5-3-内存泄露-Memory-Leak"><a href="#5-3-内存泄露-Memory-Leak" class="headerlink" title="5.3 内存泄露(Memory Leak)"></a>5.3 内存泄露(Memory Leak)</h2><p>总的来说，就是一个对象，程序不会再用到他了，但是GC又不能把它回收，这就很恶心，这就是内存泄露.</p>
<p>实际情况是，我们的一些代码习惯不好，导致一些对象有了特别长的生命周期，最终导致 OOM，这个也可以理解成<strong>宽泛意义上的内存泄露。</strong></p>
<p>尽管发生内存泄露不会立马导致程序崩溃，但是会逐步侵蚀内存，最终有可能导致内存溢出。</p>
<blockquote>
<p>注意：这里说的所有内存不是真实内存，而是虚拟机内存，虚拟机内存取决于物理内存。</p>
</blockquote>
<p>尤其注意：要举内存泄露的例子，不要举循环引用。循环引用是不是内存泄露？是，但是Java不会发生这种情况，因为Java没有采用引用计数算法。</p>
<p>具体举几个例子：</p>
<ul>
<li><p>单例模式的某些对象，因为是单例，所以可能生命周期特别长，然后单例里面引用了外部的一些生命周期短的对象，用完了不释放</p>
</li>
<li><p>各种流，比如 socket，io 等东西，用完了不close</p>
</li>
<li><p>看弹幕说有ThreadLocal？</p>
</li>
</ul>
<h2 id="5-4-并发和并行"><a href="#5-4-并发和并行" class="headerlink" title="5.4 并发和并行"></a>5.4 并发和并行</h2><p>并发：就是单核CPU，来回切换时间片，来达到宏观并行，看似同时操作，实际频繁切换。同一个时间段上同时发生。</p>
<p>并行：多核CPU，每个CPU都在干活，好多任务同时进行，就是并行。同一个时间点上同时发生</p>
<h2 id="5-5-垃圾回收的并发与并行"><a href="#5-5-垃圾回收的并发与并行" class="headerlink" title="5.5 垃圾回收的并发与并行"></a>5.5 垃圾回收的并发与并行</h2><p>并行(Parallel)的垃圾回收器：</p>
<p><strong>多条垃圾回收线程并行工作</strong>，但是用户线程仍然停止，比如：ParNew，Parallel Scavenge，Parallel Old</p>
<p>串行(Serial) 的垃圾回收器：</p>
<p>与并行的对应，只有一个垃圾回收线程工作，同样STW</p>
<p>并发(Concurrent)的垃圾回收器：</p>
<p>回收线程和用户线程同时进行，但是不一定是并行的。得看你CPU，单核CPU那就是靠线程切换来达到并发效果，多核那就是GC和用户在两个CPU上。这样看起来不会暂停用户线程(只要是GC，就必定需要暂停用户线程)。</p>
<p>比如G1,CMS。</p>
<h2 id="5-6-安全点-Safe-Point"><a href="#5-6-安全点-Safe-Point" class="headerlink" title="5.6 安全点 Safe Point"></a>5.6 安全点 Safe Point</h2><p>并非任何时间都可以停下来GC，只有在特定的时间点才会进行GC，STW，那么这个时间点就是 sp。</p>
<p>sp的选择挺重要的，如果sp过少，那么gc次数少，如果sp多，那么经常gc就会导致性能下降。大多数指令的执行时间都比较短。那么选择sp的一个标准就是 “是否具有让程序长时间执行的特征”。选择一个执行时间长的指令作为sp，比如 方法调用 循环跳转 异常跳转。</p>
<p>所以，如果保证所有线程都走到了安全点？两种办法：</p>
<ul>
<li><p>抢先式中断：先让所有线程停下来，然后让没有到达安全点的线程继续跑到安全点。然后这种方法已经不用了</p>
</li>
<li><p>主动式中断：设置一个中断标志，线程跑到安全点主动轮询这个标志，如果标志是true，说明JVM现在要GC，那么线程停止。</p>
</li>
</ul>
<h2 id="5-7-安全区域-Safe-Region"><a href="#5-7-安全区域-Safe-Region" class="headerlink" title="5.7 安全区域 Safe Region"></a>5.7 安全区域 Safe Region</h2><p>安全点确保了正在执行的线程可以停止进行GC，如果一个线程sleep了，他没法运行，咋办，这时候引入安全区域。</p>
<p>在一个区域内，引用不会发生改变，就说明在这个区域内任何地方都是安全的，那么就可以进行GC。这个区域就是sr。sr可以看作是sp的扩展。</p>
<h1 id="6-四种引用"><a href="#6-四种引用" class="headerlink" title="6. 四种引用"></a>6. 四种引用</h1><p>我们希望有这么一类对象，当我们内存不够的时候，触发GC，然后GC完了还是不够，那么JVM就会根据引用的不同，自动抛弃一些对象来腾地方。那么这里就涉及到了四种引用：强 软 弱 虚。四种引用的强度依次递减。</p>
<p>涉及到的对象：</p>
<p>父类：java.lang.ref.Reference 这是个抽象类</p>
<p>实现：WeakReference(弱), SoftReference(软), PhantomReference(虚)</p>
<h2 id="6-1-概括的说一下四种引用："><a href="#6-1-概括的说一下四种引用：" class="headerlink" title="6.1 概括的说一下四种引用："></a>6.1 概括的说一下四种引用：</h2><ul>
<li><p>强引用 StrongReference：最传统的引用方式，代码中最普遍存在的引用赋值，Object o &#x3D; new Object() 这种引用关系，只要引用关系还在，任何情况下GC都不能释放对象。</p>
</li>
<li><p>软引用 SoftReference：在系统要内存溢出之前，会把这些引用指向的对象进行二次回收，如果还是不够，才会抛出OOM</p>
</li>
<li><p>弱引用 WeakReference：被弱引用关联的对象只能活到下一次GC，下一次GC无论内存够不够，都会回收</p>
</li>
<li><p>虚引用 PhantomReference：一个对象是否存在虚引用，完全不会影响他的生存时间，我们也无法通过虚引用获取实例，设置虚引用的<strong>唯一目的就是他关联的对象被收集了以后得到一个系统通知</strong>。</p>
</li>
</ul>
<h2 id="6-2-强引用"><a href="#6-2-强引用" class="headerlink" title="6.2 强引用"></a>6.2 强引用</h2><p>这种引用在程序中最常见，我们直接通过new直接创建一个对象，然后直接把这个对象赋值给一个变量，那么就构成了强引用。</p>
<p>强引用是可触及的(还有指向的时候，我们手动置为null不算)，GC 永远不会回收他。</p>
<p>对于一个普通的对象，只要对象超过了作用域，或者我们手动把变量变为null，则对象会被GC。</p>
<p>相对的，我们把软 弱 虚 表示为：软可触及，弱可触及，虚可触及。他们都是在一定情景下可以被回收，只有强可达不可能被回收。</p>
<p>所以强引用是造成内存泄漏的主要原因.</p>
<h2 id="6-3-软引用-Soft-Reference"><a href="#6-3-软引用-Soft-Reference" class="headerlink" title="6.3 软引用 Soft Reference"></a>6.3 软引用 Soft Reference</h2><p>软引用用来描述一些虽然存活，但是不重要的对象，如果要发生内存泄漏，GC会先回收所有的软引用指向的对象，如果内存还是不够，则会抛出OOM异常。一句话概括：内存不足即回收。</p>
<p>软引用使用场景：高速缓存，如果还有内存，则会使用缓存，提高速度，如果内存没了，就会清除缓存，免得因为缓存而导致内存溢出。</p>
<p>虚拟机在某一时刻决定清理软可达的对象时，就会清理软引用。我们也可以把软引用放入一个队列，依次清理。</p>
<p>类似弱引用，区别就是JVM迫不得已才会回收软科大对象，弱引用是直接就回收了。</p>
<h2 id="6-4-弱引用-Weak-Reference"><a href="#6-4-弱引用-Weak-Reference" class="headerlink" title="6.4 弱引用 Weak Reference"></a>6.4 弱引用 Weak Reference</h2><p>只被弱引用关联的对象只能活到下一次GC，无论下一次GC是否有空间，弱引用关联的对象都会被回收。一句话概括：发现即回收。</p>
<p>但是，由于GC线程的优先级比较低，所以可能不能马上发现弱引用，所以弱引用可能也能存活很长时间。</p>
<p>这个东西同理和软引用一样，我们也可以弄一个队列，把弱引用放入队列中进行处理。</p>
<p>弱引用和软引用适合做缓存，如果内存不够了就释放内存，内存够就放缓存。</p>
<h2 id="6-5-虚引用-Phantom-Reference"><a href="#6-5-虚引用-Phantom-Reference" class="headerlink" title="6.5 虚引用 Phantom Reference"></a>6.5 虚引用 Phantom Reference</h2><p>这东西，完全不决定对象的生命周期，有跟没有一个样，甚至我们没法像前两种引用一样去get。</p>
<p>这东西唯一的作用，就是对象被回收的时候我们会收到一个系统通知。</p>
<p>同时这个引用在创建的时候必须传入一个回收队列。</p>
<p>因为，系统回收一个对象如果发现这个对象有一个虚引用，就会回收后把这个虚引用放入引用队列，来进行通知。</p>
<h2 id="6-6-代码"><a href="#6-6-代码" class="headerlink" title="6.6 代码"></a>6.6 代码</h2><p>上面说的十分抽象，这里给一段代码看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对于强 软 弱 引用 代码如下：</span></span><br><span class="line"><span class="comment"> * 软和弱引用好歹可以通过get得到他们指向的对象，我们gc以后通过get去获取对象看看情况，</span></span><br><span class="line"><span class="comment"> * 但是对于虚引用那就是另外一种情况了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 强引用，除非null才回收</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 软引用，内存不足及回收</span></span><br><span class="line">        SoftReference&lt;User&gt; u2 = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 弱引用，发现及回收</span></span><br><span class="line">        WeakReference&lt;User&gt; u3 = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// u1 还在，u2 看情况，如果内存满了就没了，u3 八成是没了</span></span><br><span class="line">        u1.get();</span><br><span class="line">        u2.get();</span><br><span class="line">        u3.get();</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面仅仅是强软弱引用的情况，对于虚引用，那得下面专门说了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//package pri;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> PhantomReferenceTest obj;</span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个线程用于监听ReferenceQueue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckReferenceQueue</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(queue != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 前面我们说到了第二次gc会把obj对象彻底清理掉，因为finlize已经执行过了</span></span><br><span class="line">                    <span class="comment">// 所以虚引用指向的对象被回收时，是怎么个流程？</span></span><br><span class="line">                    <span class="comment">// 我们创建虚引用的时候传入了一个队列，回收时，这个队列就会接收到这个虚引用，</span></span><br><span class="line">                    <span class="comment">// 但是注意，虚引用和软弱引用不一样，虚引用压根就没法get到他指向的那个对象</span></span><br><span class="line">                    <span class="comment">// 所以这里其实仅仅就是通知一下这个队列：ok，现在有一个虚引用指向的对象被我gc回收了，</span></span><br><span class="line">                    <span class="comment">// 虚引用就是充当一个信号的作用</span></span><br><span class="line"></span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="comment">// 从引用队列中得到虚引用，如果得到了，说明gc的时候obj被回收了，</span></span><br><span class="line">                        <span class="comment">// 因为只有真正被回收，才会把虚引用传给队列。</span></span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) queue.remove();</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;objt=&quot;</span> + objt);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 最后判断一下，虚引用不为null，说明回收成功,然后回到108行</span></span><br><span class="line">                    <span class="keyword">if</span>(objt != <span class="literal">null</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;objt != null,队列中可以得到虚引用，证明回收成功&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finlize start&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;重新给obj赋值为this，finlize中把obj救活了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先创建一个自己的强引用</span></span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">PhantomReferenceTest</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建引用队列，这个玩意待会儿会接收gc信息</span></span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个监听ReferenceQueue的线程，同时设置为守护线程，也就是这个线程不会随着main线程的结束而结束</span></span><br><span class="line">        <span class="type">CheckReferenceQueue</span> <span class="variable">checkReferenceQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckReferenceQueue</span>();</span><br><span class="line">        checkReferenceQueue.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        checkReferenceQueue.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给obj添加虚引用，创建虚引用的同时需要指定引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; ref = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, queue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 很好，我们先试试虚引用能不能像软弱引用一样get，发现不行，也就是说虚引用仅仅就充当一个信号的作用</span></span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;第一次GC&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 我们进行第一轮gc，我们给强引用置空，这个时候虚引用指向的这个对象就没有强引用，</span></span><br><span class="line">            <span class="comment">// 按理说会直接回收掉</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            System.gc();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 但是我们发现这个时候obj居然不为空，居然还是this，这是为啥？</span></span><br><span class="line">            <span class="comment">// 因为我们上面重写了finlize方法，这个方法里面复活了obj，让obj重新回到了可触及的状态</span></span><br><span class="line">            <span class="comment">// 所以第一轮gc并没有清理掉obj</span></span><br><span class="line">            <span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj == null&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj != null, finlize生效使obj复活&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;第二次GC&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 很好，我们开始进行第二轮gc，再一次清除强引用指向并调用gc开始清理</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            System.gc();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ok，这个时候先不要着急看这里，回到上面的第11行，我们从第十一行接着分析。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 行了，上面的队列刘晨我们走完了，最后这里收个尾，最后判断一下obj是不是null</span></span><br><span class="line">            <span class="comment">// 是的话，ok，回收成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;obj == null?  &quot;</span> + (obj == <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集器</title>
    <url>/2022/06/06/garbage-collectors/</url>
    <content><![CDATA[<p>上一章说了主要的垃圾回收的各种基础理论，比如各种的垃圾回收算法，GCRoots 啥的，这一章我们就深入目前主流的各种垃圾回收器，看看他们是如何进行垃圾回收的。</p>
<span id="more"></span>

<h1 id="1-垃圾回收器概述"><a href="#1-垃圾回收器概述" class="headerlink" title="1. 垃圾回收器概述"></a>1. 垃圾回收器概述</h1><p>垃圾回收器，众所周知就是用来进行垃圾回收的一个东西。下面是一些概念：</p>
<ul>
<li><p>垃圾回收器没有在JVM规范中做过多的规定，可以由不同的厂商的JVM来实现。</p>
</li>
<li><p>由于JDK告诉迭代，所以垃圾回收器已经有了很多版本。</p>
</li>
<li><p>从不同的角度看，可以把GC分为不同的类型。</p>
</li>
</ul>
<h1 id="2-垃圾回收器分类"><a href="#2-垃圾回收器分类" class="headerlink" title="2. 垃圾回收器分类"></a>2. 垃圾回收器分类</h1><ul>
<li><p>按照线程数分，可以分为 <strong>串行</strong>垃圾回收器和<strong>并行</strong>垃圾回收器，只有一个垃圾回收线程就是串行，一堆线程回收就是并行。当然，不管线程有几个，得会发生STW。那么具体指的就是只有一个CPU的时候，那就是用串行垃圾回收器，多个CPU那就是并行。</p>
<ul>
<li><p>只有一个单CPU，那就用串行垃圾回收器，如果并发的执行一堆垃圾回收线程效果反而不好。具体应用在 Client模式下的JVM中。</p>
</li>
<li><p>并发性能好的CPU，也可以使用并行的垃圾回收。</p>
</li>
</ul>
</li>
<li><p>按照工作模式来分，那就分为&#x3D;&#x3D;并发&#x3D;&#x3D;式垃圾回收和&#x3D;&#x3D;独占&#x3D;&#x3D;式垃圾回收。</p>
<ul>
<li><p>并发的执行用户线程和垃圾回收线程，让STW没那么明显</p>
</li>
<li><p>独占的垃圾回收器一旦运行，就暂停所有的用户线程。直接STW。</p>
</li>
</ul>
</li>
<li><p>按照碎片处理方式分，分为&#x3D;&#x3D;压缩式&#x3D;&#x3D;垃圾回收器和&#x3D;&#x3D;非压缩式&#x3D;&#x3D;垃圾回收器。</p>
<ul>
<li><p>垃圾回收完成后，整理内存碎片，前面说过，标记-压缩算法，指针碰撞</p>
</li>
<li><p>没有上面那步，空闲列表。</p>
</li>
</ul>
</li>
<li><p>按照工作的内存区分，分为<strong>年轻代</strong>垃圾回收和<strong>老年代</strong>垃圾回收。</p>
</li>
</ul>
<h1 id="3-垃圾回收器的评估性能指标"><a href="#3-垃圾回收器的评估性能指标" class="headerlink" title="3. 垃圾回收器的评估性能指标"></a>3. 垃圾回收器的评估性能指标</h1><p>大致分为以下指标：</p>
<ul>
<li><p>吞吐量：运行用户代码和程序总运行时间的比例。</p>
</li>
<li><p>垃圾收集开销：吞吐量的补数，收集时间和总运行时间的比例</p>
</li>
<li><p>暂停时间：垃圾收集时，暂停用户线程的时间</p>
</li>
<li><p>收集频率：相对于应用程序的执行，收集操作发生的频率。</p>
</li>
<li><p>内存占用：Java堆区所占内存大小</p>
</li>
<li><p>快速：一个对象从诞生到回收的时间。对象就用了就赶紧清理，让他活得时间短一点。</p>
</li>
</ul>
<p>前面三个重点关注，但是上面三个指标不可能全部满足，所以三者构成一个 “不可能三角”，随着硬件逐步发展，现在最多可以同时满足2个。</p>
<p>下面会详细说说上面三个重要指标：</p>
<h2 id="3-1-吞吐量"><a href="#3-1-吞吐量" class="headerlink" title="3.1 吞吐量"></a>3.1 吞吐量</h2><ul>
<li><p>就是CPU执行用户代码的时间 &#x2F; 程序执行的总时间。</p>
</li>
<li><p>高吞吐量的程序有更多的时间基准，快速响应就不要考虑了。</p>
</li>
<li><p>吞吐量优先那就有可能是(只是可能，谁知道实际情况)，减少GC频率，每次时间长一点，但是总GC时间短。</p>
</li>
</ul>
<h2 id="3-2-暂停时间"><a href="#3-2-暂停时间" class="headerlink" title="3.2 暂停时间"></a>3.2 暂停时间</h2><ul>
<li><p>暂停时间：一个时间段内让程序暂停，让GC进行。</p>
</li>
<li><p>注意这个东西是每次的，不是总的STW时间。</p>
</li>
<li><p>如果是暂停时间优先，那就是增加GC频率，然后每次GC时间短。</p>
</li>
</ul>
<p>上面两种指标，是互斥的，如果追求高吞吐量，那么就需要降低GC频率，导致每次GC的时间较长。如果暂停时间优先，则GC频率高，每次是时间短，但是加在一起可能时间长，吞吐量低。</p>
<p>目前的标准：在最大吞吐量优先的情况下，降低停顿时间。</p>
<h1 id="4-垃圾收集器的发展历史"><a href="#4-垃圾收集器的发展历史" class="headerlink" title="4. 垃圾收集器的发展历史"></a>4. 垃圾收集器的发展历史</h1><p><img src="/../images/gc/GCorProcess.png" alt="history"></p>
<p>上面这张图中，有一个分水岭，就是2018年的G1收集器发布，算上这个，在jdk11发布之前，总共是有7种垃圾回收器，这7种是最经典的垃圾回收器，必须要知道，分别是：</p>
<ul>
<li><p>串行回收器：Serial，Serial Old</p>
</li>
<li><p>并行回收器：ParNew，Parallel Scavenge，Parallel Old</p>
</li>
<li><p>并发回收器：CMS，G1</p>
</li>
</ul>
<h1 id="5-7款垃圾收集器和垃圾分代之间的关系"><a href="#5-7款垃圾收集器和垃圾分代之间的关系" class="headerlink" title="5. 7款垃圾收集器和垃圾分代之间的关系"></a>5. 7款垃圾收集器和垃圾分代之间的关系</h1><ul>
<li><p>新生代GC：Serial； ParNew； Parallel Scavenge</p>
</li>
<li><p>老年代GC：Serial Old；Parallel Old；CMS</p>
</li>
<li><p>整堆：G1</p>
</li>
</ul>
<p>然后每个GC之间为了给整堆进行GC，各自会有配合，如下图：</p>
<p><img src="/../images/gc/GCGernection.png" alt="gcors"></p>
<p>我们来解释一下这个图：</p>
<p>jdk8之前，两条红色虚线看成实线，也就是说，jdk8之前，Serial GC 可以和 CMS 和 Serial Old 搭配进行整堆回收，ParNew 可以和 CMS 和 Serial Old 进行搭配，以此类推。然后为啥 CMS和Serial Old 之间还有联系？这是一个后备方案，如果CMS回收失败，就会启用 Serial Old。</p>
<p>所以红线是什么意思？jdk8中，取消了两条红线，也就是红线对应的两种组合取消了，但是你要非要用，也行，就相当于 @Deprecated。jdk9 中，彻底 Remove了，压根就不让你使了。</p>
<p>绿色的线是啥？jdk14中，Deprecated 了 Parallel Scavenge 和 Serial Old 的组合，仅仅是弃用，还没有移除。</p>
<p>CMS有个青色的框，啥意思？jdk14中，删除了 CMS，注意是删除。</p>
<h2 id="5-1-为什么使用多种垃圾回收器"><a href="#5-1-为什么使用多种垃圾回收器" class="headerlink" title="5.1 为什么使用多种垃圾回收器"></a>5.1 为什么使用多种垃圾回收器</h2><p>因为应用场景不同，所以不同的垃圾回收器效果不一样。</p>
<h2 id="5-2-相应参数"><a href="#5-2-相应参数" class="headerlink" title="5.2 相应参数"></a>5.2 相应参数</h2><ul>
<li><p>查看默认的垃圾收集器：-XX:+PrintCommandLineFlags</p>
</li>
<li><p>命令行方式查看：jinfo -flag 参数 进程id ;这个参数可以看上面那条命令的结果，他给你打印好多JVM参数，比如什么 useParallelGC 这种的</p>
</li>
</ul>
<hr>
<p>上面提到了目前为止有7种经典的垃圾回收器，下面我们会挨个介绍:</p>
<h1 id="6-Serial回收器"><a href="#6-Serial回收器" class="headerlink" title="6. Serial回收器"></a>6. Serial回收器</h1><blockquote>
<p>经典的串行回收器</p>
</blockquote>
<p>serial 回收器 可以说是最基本的最老的垃圾回收器，jdk1.3之前回收年轻的唯一选择。因为他是串行的，所以他是Client模式下的垃圾回收器。</p>
<p>Serial 采用 <strong>复制算法</strong>，串行回收 和 STW机制来对内存进行回收。</p>
<p>除了 Serial回收年轻代，还有Serial Old 回收老年代，在上面那张图中我们可以看到，Serial 和 Serial Old 搭配进行回收。Serial Old 和Serial 也是串行然后STW，区别就是老年代的垃圾特性，我们之前说过，决定了老年代不适合采用复制算法。所以Serial Old 收集器采用 标记-压缩算法。</p>
<p>Serial Old 在client模式下是回收老年代的垃圾回收器，在server模式下 Serial Old 也能用，主要就是用来搭配 新生代收集器 Parallel Scavenge 进行整堆收集以及充当CMS的备用收集器，如果CMS回收失败，则采用Serial Old。在前面那张图中体现了。</p>
<p>具体的收集过程如下：</p>
<p><img src="/../images/gc/SerialGC.png" alt="serial_gc"></p>
<p>看图，可以明确的看出来，这个GC是串行的。同时发生STW。单线程的意思就是：</p>
<ul>
<li><p>只是用一个CPU或者说只使用一个垃圾收集线程进行GC</p>
</li>
<li><p>垃圾回收时，只能由垃圾回收线程，所有用户线程必须停止。</p>
</li>
</ul>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li><p>简单而高效，在单个CPU的情况下，这玩意专心进行GC，不和其他线程交互，没有额外开销。所以高效。</p>
</li>
<li><p>在桌面应用中，内存一般不高，所以一次GC消耗几百毫秒，也还行。</p>
</li>
<li><p>可以使用 -XX:+useSerialGC 来启用Serial GC，让年轻代和老年代都是用串行垃圾回收器。这个参数就等价于设置年轻代GC为Serial 老年代用 Serial Old。这个东西，采用哪种垃圾回收器就是 -XX:+useGCName；+代表启用，use 使用 然后是 GC名。</p>
</li>
</ul>
<h1 id="7-ParNew-回收器"><a href="#7-ParNew-回收器" class="headerlink" title="7. ParNew 回收器"></a>7. ParNew 回收器</h1><blockquote>
<p>并行回收器</p>
</blockquote>
<p>如果说Serial是单线程的年轻代垃圾收集器，所以 ParNew就是Serial的多线程版本，Par 就是 Parallel 的缩写，New是只能处理新生代。ParNew 除了使用并行回收外，基本和 Serial 没有区别，都是回收年轻代，使用复制算法，采用STW机制。</p>
<p>ParNew是JVM在server模式下的默认年轻代垃圾回收器。</p>
<p>具体流程如下：</p>
<p><img src="/../images/gc/ParNew.png" alt="parnew_gc"></p>
<ul>
<li><p>ParNew 收集新生代，回收频繁，并且使用并行方式，比较高效。</p>
</li>
<li><p>对于老年代，仍然使用串行方式，回收次数少(CPU并行需要切换线程，这里使用串行可以节省资源)。</p>
</li>
</ul>
<p>虽然说ParNew是并行回收，但是我们不能说ParNew效率比Serial高。</p>
<ul>
<li><p>在多核情况下，ParNew的确比Serial效率高，因为多个核可以一起GC，效率高</p>
</li>
<li><p>但是在单核下，ParNew需要这个CPU不停的进行线程调度，所以效率反倒比Serial差。</p>
</li>
</ul>
<p>除了 Serial，ParNew GC 可以和CMS搭配使用。</p>
<h2 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h2><ul>
<li><p>通过选项：-XX:+useParNewGC 来开启ParNew。代表年轻代使用ParNew，不影响老年代。</p>
</li>
<li><p>使用选项：-XX:ParallelGCThreads 限制GC线程数，默认开启和CPU线程数相同的数目。</p>
</li>
</ul>
<p>但是在jdk9以后如果我们指定 ParNew，那就不太好了，他就会给你警告说 ParNew 已经 Deprecated 了，不建议使用。</p>
<h1 id="8-Parallel-Scavenge"><a href="#8-Parallel-Scavenge" class="headerlink" title="8.Parallel Scavenge"></a>8.Parallel Scavenge</h1><blockquote>
<p>吞吐量优先</p>
</blockquote>
<p>ParNew用于收集年轻代以外，Parallel Scavenge 也是使用复制算法，STW，并行回收。所以为啥ParNew有了以后还有ParallelScavenge？</p>
<p>就已经告诉你了，Parallel Scavenge(以后就叫Parallel) 是吞吐量优先。Parallel 的目标是达到一个可控制的吞吐量，所以Parallel 也叫 吞吐量优先垃圾收集器。</p>
<p>自适应调节也是 Parallel 和 ParNew 的一个区别。(啥叫自适应调节？就是在运行的时候可以根据内存情况进行调整)</p>
<p>高吞吐量优先可以高效率的利用CPU时间，尽快完成程序的运算任务。适合&#x3D;&#x3D;后台运算的任务不需要太多交互 的任务&#x3D;&#x3D;，因此常用在服务器环境中使用。</p>
<p>Parallel 在 jdk1.6 中添加了 Parallel Old 用来回收老年代，来替换Serial Old。</p>
<p>Parallel Old 收集器采用&#x3D;&#x3D;标记压缩算法&#x3D;&#x3D;，并行回收，使用STW。</p>
<p>具体流程如下：</p>
<p><img src="/../images/gc/Parallel.png" alt="ParallelSca"></p>
<p>上图中，年轻代用 Parallel Scavenge 回收，老年代用 Parallel Old 回收，两者都是并行的。</p>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ul>
<li><p>开启ParallelScavenge：-XX:+useParallelGC 手动指定年轻代使用Parallel来进行回收。(JDK9中开启Parallel会自动开启 Parallel Old)</p>
</li>
<li><p>开启ParallelOld：-XX:+useParallelOldGC 手动指定老年代使用ParallelOld进行回收。(JDK8 中默认使用Parallel和ParallelOld)</p>
</li>
</ul>
<p>上面这两个参数是互相激活的，只要开启一个，就会开启另一个。</p>
<ul>
<li><p>指定Parallel 并行线程数：-XX:ParallelGCThreads</p>
<ul>
<li><p>一般来说，最好是 CPU数目&#x3D;&#x3D;线程数目</p>
</li>
<li><p>细节上的区别：当CPU &lt;&#x3D; 8；则线程数 &#x3D;&#x3D; CPU数</p>
</li>
<li><p>当CPU&gt;8；则线程数&#x3D;3 + ( (5 * cpu) &#x2F; 8)</p>
</li>
</ul>
</li>
<li><p>指定垃圾收集最大 STW时间：-XX:MaxGCPauseMillis</p>
<ul>
<li><p>不是绝对的，只会尽可能地靠近这个时间，他会调整一些JVM参数。</p>
</li>
<li><p>对于用户来说肯定是STW越低越好，但是对于服务器来说还是吞吐量更重要，所以这个参数慎用。</p>
</li>
</ul>
</li>
<li><p>指定垃圾收集时间和总时间的占比：-XX:GCTimeRatio,用于衡量吞吐量。</p>
<ul>
<li>取值范围0-100，默认是99，也就是GC时间占总时间的1%；</li>
</ul>
</li>
</ul>
<p>上面两个参数互斥，吞吐量和STW时间不可兼得。</p>
<ul>
<li><p>指定Parallel采用自适用机制：-XX:+useAdaptiveSizePolicy，默认是开启的。</p>
<ul>
<li><p>在这种模式下，年轻代和老年代的大小比例会自动调整已达到 堆大小 吞吐量 暂停时间 之间的平衡。</p>
</li>
<li><p>手动调整比较费劲的情况下，应该使用这个模式。</p>
</li>
</ul>
</li>
</ul>
<h1 id="9-CMS"><a href="#9-CMS" class="headerlink" title="9. CMS"></a>9. CMS</h1><blockquote>
<p>低延迟</p>
</blockquote>
<h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><p>jdk1.5 的时候，推出的垃圾收集器，全称是 Concurrent-Mark-Sweep ：并发的垃圾清除收集器。这个收集器是HotSpot虚拟机推出的第一个并发的垃圾收集器，宏观上他和用户线程一起工作，降低STW时间。</p>
<p>CMS的关注点是尽可能低的STW时间，STW时间越低，就越适合与用户交互的程序。低延迟可以提高用户体验。</p>
<blockquote>
<p>很多Java程序部署在服务器上，我们很关注服务器的响应速度，降低系统停顿时间，所以CMS挺适合服务器程序</p>
</blockquote>
<p>CMS采用标记-清除算法，并且也会STW,仅仅是STW时间短了而已。</p>
<p>然而，CMS作为老年代的垃圾收集器，他没法和 Parallel Scavenge 收集器协调工作，所以在jdk1.5以后，CMS作为老年代收集器的时候，年轻代只能选择 ParNew 或者 Serial 中的一个。</p>
<p>在G1出现之前，CMS还是应用非常广泛的，直到现在，一些地方还在使用CMS。</p>
<p>具体流程如下：</p>
<p><img src="/../images/gc/CMS.png" alt="cms"></p>
<p>核心的流程就是中间四步：</p>
<ul>
<li><p>初始标记 Initial-Mark：这个阶段程序中的所有工作线程都会停止进入STW状态，然后进行初始标记，仅仅标记出、<strong>GCRoots能够直接到达的对象</strong>，一旦标记完成就会马上恢复前面暂停的线程。因为和GCRoots直接关联的对象比较少，所以这个过程非常快。</p>
</li>
<li><p>并发标记 Concurrent-Mark：<strong>从GCRoots直接关联的对象开始遍历整个对象图</strong> 的过程，这个过程比较慢，但是不需要暂停用户线程，他可以和用户线程并发执行。</p>
</li>
<li><p>重新标记 Remark：修正的过程，前面并发标记的时候因为用户线程还在运行导致标记有一些偏差，这个阶段就是为了修正这些标记偏差，这个过程比初始标记的时间长一些，但远比并发标记时间短。</p>
<blockquote>
<p>注意这个修正修正的是啥？在并发阶段没法确定是不是垃圾的东西，这里重新确定垃圾。注意，是并发标记的时候已经怀疑是垃圾了，然后这里重新进行一个判断处理。</p>
</blockquote>
</li>
<li><p>并发清理 Concurrent-Sweep：清除死亡对象，释放内存空间，由于存活对象不需要移动，所以这个阶段也可以和用户线程并发进行。</p>
</li>
</ul>
<h2 id="9-2-总结CMS"><a href="#9-2-总结CMS" class="headerlink" title="9.2 总结CMS"></a>9.2 总结CMS</h2><p>尽管CMS并发标记，但是在初始标记和重新标记阶段还是会发生STW，但是时间很短。所以说任何的GC都不可能完全消除STW，只能尽可能地减少这个时间。</p>
<p>由于并发标记阶段和并发清理阶段都是并发的，不需要停顿工作，所以整体来看CMS是低停顿的。</p>
<p>由于在清理阶段用户线程没有停顿，这个时候用户线程还是会产生对象消耗内存，所以不能说老年代满了才收集垃圾，而是当老年代的空间达到一个阈值的时候，CMS就会开始工作，确保在清理过程中还能正常的往堆中放东西。如果清理阶段CMS预留的内存不够了，就会出现一次&#x3D;&#x3D;Concurrent Mode Failure&#x3D;&#x3D;失败，这个时候 Serial Old 作为备用GC就会开始工作，这个时候停顿时间就会变长了。</p>
<p>为啥CMS不用标记-压缩算法？</p>
<p>因为在清理阶段用户线程还在执行，这个时候你压缩内存，修改对象的内存地址，就会导致用户线程找不到对象。</p>
<h2 id="9-3-CMS的优缺点："><a href="#9-3-CMS的优缺点：" class="headerlink" title="9.3 CMS的优缺点："></a>9.3 CMS的优缺点：</h2><p>优点：延迟低 并发收集</p>
<p>缺点：</p>
<ul>
<li><p>会产生内存碎片，可能导致清理后没有足够的大块的内存，无法放置大对象，被迫出发 FullGC。</p>
</li>
<li><p>CMS收集器对CPU资源比较敏感，他在并发阶段虽然不会导致用户线程停止，但是他会消耗CPU资源，让系统的吞吐量降低。</p>
</li>
<li><p>CMS无法处理浮动垃圾，啥是浮动垃圾，我们在并发标记阶段怀疑是垃圾的东西，在重新标记阶段重新判断。但是有些东西在并发标记阶段压根没有被怀疑，但是在并发过程中他变成垃圾了，这个时候重新标记阶段就没还有办法进行处理。这部分，在并发过程中变成垃圾的垃圾，就称为 &#x3D;&#x3D;浮动垃圾&#x3D;&#x3D;。只能在下一次GC中清理。</p>
</li>
</ul>
<h2 id="9-4-CMS相关参数"><a href="#9-4-CMS相关参数" class="headerlink" title="9.4 CMS相关参数"></a>9.4 CMS相关参数</h2><ul>
<li><p>指定JVM使用CMS：-XX:+useConMarkSweepGC,打开这个以后会自动开启 -XX:+useParNewGC,也就是 ParNew + CMS + Serial Old 的堆回收组合。</p>
</li>
<li><p>指定堆使用率阈值，达到则GC：-XX:CMSInitiatingOccupanyFraction</p>
<ul>
<li><p>jdk5 中默认是 68%，堆使用率达到 68%则进行回收。jdk6以后默认是 92%。</p>
</li>
<li><p>如果内存增长比较慢，可以设置大阈值，这样可以降低回收次数，提高效率。如果内存增长快，则应该缩小阈值，避免在清理过程中内存不足导致Concurrent Mark Failure，触发 FullGC，降低效率。</p>
</li>
</ul>
</li>
<li><p>指定进行FullGC之后对内存进行整理，避免内存碎片产生：-XX:+useCMSCompactAtFullCollection.这样停顿时间更长了。</p>
</li>
<li><p>指定多少次 FullGC以后对内存空间进行整理：-XX:CMSFullGCsBeforeCompaction</p>
</li>
<li><p>指定 CMS 线程数目：-XX:ParallelCMSThreads</p>
<ul>
<li>默认的线程数：（ParallelGCThreads + 3） &#x2F; 4；这个 ParallelGCThreads 默认就是 cpu个数。</li>
</ul>
</li>
</ul>
<h2 id="9-5-小结"><a href="#9-5-小结" class="headerlink" title="9.5 小结"></a>9.5 小结</h2><p>Serial Parallel CMS 有啥不一样？</p>
<ul>
<li><p>如果要最小化地使用内存和并行开销，选择 Serial GC</p>
</li>
<li><p>最大化应用的吞吐量，选择 Parallel Scavenge</p>
</li>
<li><p>最小化中断时间或停顿时间，选择 CMS (CMS+ParNew)</p>
</li>
</ul>
<h2 id="9-6-CMS的后续"><a href="#9-6-CMS的后续" class="headerlink" title="9.6 CMS的后续"></a>9.6 CMS的后续</h2><ul>
<li><p>jdk9中，CMS被标记为 Deprecated，如果用参数启用CMS，会被警告，说明CMS还在。</p>
</li>
<li><p>jdk14中，彻底删除CMS，通过参数设置会告诉你CMS已经没了，采用默认垃圾回收器。</p>
</li>
</ul>
<h1 id="10-G1-垃圾收集器"><a href="#10-G1-垃圾收集器" class="headerlink" title="10. G1 垃圾收集器"></a>10. G1 垃圾收集器</h1><blockquote>
<p>区域化分代式的垃圾回收</p>
</blockquote>
<h2 id="10-1-起源"><a href="#10-1-起源" class="headerlink" title="10.1 起源"></a>10.1 起源</h2><p>前面已经有了很多的垃圾回收器了，为啥又发布了G1.</p>
<p>原因就是，现在的项目越来越大，没有GC程序就不能正常运行，而会导致STW的GC又跟不上实际需求，所以才会对GC进行不断的优化，G1 就在 jdk7 update4 以后出来了，是目前收集技术的前沿作品 : )</p>
<p>同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间，同时兼顾良好的吞吐量量。</p>
<p>官方给G1的定位就是：在延迟可控的情况下获得尽可能高的吞吐量。所以才担当起全功能收集器的重任。</p>
<h2 id="10-2-为啥叫-Garage-First"><a href="#10-2-为啥叫-Garage-First" class="headerlink" title="10.2 为啥叫 Garage First"></a>10.2 为啥叫 Garage First</h2><ul>
<li><p>G1是一个并行的垃圾回收器，他把堆内存分成不同的区region(物理上不连续),使用不同的region来表示 eden survivor1 survivor2 和 old</p>
</li>
<li><p>G1 GC 有计划的避免在Java整个堆中进行垃圾回收。G1 跟踪各个 Region 来记录每个区的价值(回收获得的空间大小和时间消耗情况)，在后台维护一个优先队列，每次根据允许的回收时间，优先回收价值最大的区。</p>
</li>
<li><p>所以为啥叫first，因为回收价值大的垃圾优先，就是 first。</p>
</li>
</ul>
<p>G1 是一款面向服务端应用的GC，及高概率在满足低延迟的同时维持高吞吐量。</p>
<p>jdk1.7以后，移除了 Experiment 的标志，jdk1.9以后作为默认的垃圾收集器，取代了 CMS和 Parallel + Parallel Old，Orcale 官方叫他 全功能的垃圾收集器。</p>
<p>jdk8中可以通过: -XX:+useG1GC 来开启 G1.</p>
<h2 id="10-3-G1-回收器的优势特点"><a href="#10-3-G1-回收器的优势特点" class="headerlink" title="10.3 G1 回收器的优势特点"></a>10.3 G1 回收器的优势特点</h2><h3 id="10-3-1-并行和并发"><a href="#10-3-1-并行和并发" class="headerlink" title="10.3.1 并行和并发"></a>10.3.1 并行和并发</h3><ul>
<li><p>并行：G1在回收期间，可以有多个GC线程同时进行收集，有效利用多核算力，提高效率。此时 用户线程 STW</p>
</li>
<li><p>并发：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时进行，因此一般情况下，不会在回收阶段完成阻塞应用程序。</p>
</li>
</ul>
<h3 id="10-3-2-分代收集"><a href="#10-3-2-分代收集" class="headerlink" title="10.3.2 分代收集"></a>10.3.2 分代收集</h3><ul>
<li><p>G1 依旧是分代回收，堆依然分为 年轻代和老年代，年轻代还是 eden 和 两个幸存者，但是G1不要求这些区连续，也不再规定这些去的大小和数量。</p>
</li>
<li><p>G1 将堆分为若干个区域Region，这些区域既可以存放老年代，也可以存放年轻代，都是逻辑上的。</p>
</li>
<li><p>G1 同时兼顾老年代和年轻代，和其他的不一样，其他的仅仅是收集年轻代或老年代。</p>
<p>以前的分代，快和块之间都是挨着的，这回不是了，是下图这样的：</p>
<p><img src="/../images/gc/G1Region.png"></p>
<p>每个块region 的角色可以变化，比如 Eden 区，某一个Eden区被回收了，那这个Eden就可能变成Survivor</p>
</li>
</ul>
<h3 id="10-3-3-空间整理"><a href="#10-3-3-空间整理" class="headerlink" title="10.3.3 空间整理"></a>10.3.3 空间整理</h3><ul>
<li><p>CMS 可以指定在 FullGC后进行碎片整理，</p>
</li>
<li><p>G1把空间划分为一个个的region，内存的回收一Region为基本单位，region之间是复制算法，整体可以看作 标记-压缩算法(Region摆放到一起)。两种算法都可以避免产生过多的碎片。有利于程序长时间运行，不会无法分配大对象。堆大情况下G1的优势更大。</p>
</li>
<li><p>可预测的停顿时间模型(软实时)</p>
<p>这是G1相对CMS的另一个优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者指定在一个M毫秒的时间片内，消耗在垃圾收集上的时间不超过N毫秒。</p>
<ul>
<li><p>由于分区的原因，G1可以选取部分区域进行回收，这样缩小了回收范围，对于全局停顿的发生也能有一个较好的控制。</p>
</li>
<li><p>G1跟踪各个Region中垃圾堆积的价值，维护一个优先列表，可以在有限时间内收集高价值的region，保证了在一定时间内G1可以获取尽可能高的收集效率。</p>
</li>
<li><p>相对于CMS，G1未必能做到CMS最优的停顿时间，但是G1的最差停顿时间要比G1好很多。</p>
</li>
<li><p>何为软实时？实时，那就是我们给定10ms，他就在10ms内完成收集。那软实时的意思就是他尽可能地在10ms内完成，可能有偏差。</p>
</li>
</ul>
</li>
</ul>
<h2 id="10-4-G1的缺点"><a href="#10-4-G1的缺点" class="headerlink" title="10.4 G1的缺点"></a>10.4 G1的缺点</h2><p>相对于CMS，G1运行时的内存占用，和程序运行时的额外执行负载都比CMS高。</p>
<p>小内存下，CMS更好，大内存自然是G1更好，平衡点是 6-8G内存。</p>
<h2 id="10-5-G1相关参数"><a href="#10-5-G1相关参数" class="headerlink" title="10.5 G1相关参数"></a>10.5 G1相关参数</h2><ul>
<li><p>指定采用G1为收集器：-XX:+useG1GC,jdk9以后这个就是默认的了。</p>
</li>
<li><p>指定每个Region的大小：-XX:G1HeapRegionSize 必须是 2的次方，范围是1-32，目的是为了让堆分出大约2048个region。默认是堆的1&#x2F;2000；</p>
</li>
<li><p>指定期望的最大GC停顿时间，G1不保证能达到：-XX:MaxGCPauseMillis,默认是200ms，如果你设置的比较低，那G1每回收集的region数目就会少，如果内存增长快的话那就有可能导致堆空间占满，最终出发FullGC，反倒时间变长了。</p>
</li>
<li><p>指定并行时的GC线程数：-XX:ParallelGCThread,最多设置为8</p>
</li>
<li><p>指定并发标记线程数：-XX:ConcGCThreads,设置并行垃圾回收线程的数目，默认是 cpu的1&#x2F;4</p>
</li>
<li><p>指定出发垃圾回收的堆阈值：-XX:IniliatingHeapOccupancyPercent,超过这个值就会触发GC，默认是45.</p>
</li>
</ul>
<h2 id="10-6-适用场景"><a href="#10-6-适用场景" class="headerlink" title="10.6 适用场景"></a>10.6 适用场景</h2><ul>
<li><p>服务器环境，有大内存和多核CPU，</p>
</li>
<li><p>最主要的应用是需要低延迟，有大堆 的应用程序、</p>
</li>
<li><p>用来替换掉jdk1.5 的CMS，在下面情况中，G1的效果比CMS好：</p>
<ul>
<li><p>超过50% 的java堆被活动数据占用</p>
</li>
<li><p>对象分配频率或者年代提升频率变化很大。</p>
</li>
<li><p>GC停顿时间过长。</p>
</li>
</ul>
</li>
</ul>
<h2 id="10-7-分区Region：化整为零"><a href="#10-7-分区Region：化整为零" class="headerlink" title="10.7 分区Region：化整为零"></a>10.7 分区Region：化整为零</h2><p>G1把内存分为了大约 2048个大小相同的region，region大小取决于堆空间，范围是 1m - 32m，是2的次方数。所有的region大小相同，且整个JVM运行期间不会改变。</p>
<p>虽然还有年轻代老年代的区分，但是这些区在物理上不再要求连续，物理上不隔离了，每个分区其实都是一部分的region集合，通过对region进行动态分配，从而实现各个区的逻辑连续。</p>
<p>一个region在他存活期间只能扮演一个角色，年轻代或者老年代。如果G1把这个region回收了，比如一个region本来是eden，然后一回收，这个region里面的东西直接进入另一个survivor 的region，那当前这个eden的region整个就空了。然后就会维护一个空闲列表，表明这个region空的，然后下一次内存分配，可能就把他取出来当老年代了。</p>
<p>G1中，除了young old ，还有一个区：Humongous,H区。这个区用来存放大对象(必须是1.5 region以上的，叫大对象)。因为壁板情况下，大对象都是默认直接分配老年代的，但是如果是短命的大对象，那就不太好了。所以划分出来H区。&#x3D;&#x3D;如果一个H区装不下，那G1就会寻找连续的H区来存储&#x3D;&#x3D;，为了能找到连续的H区，有的时候不得不出发FullGC。G1把H区当作老年代的一部分看待。</p>
<h1 id="11-G1的回收流程"><a href="#11-G1的回收流程" class="headerlink" title="11. G1的回收流程"></a>11. G1的回收流程</h1><p>主要包括下面3个环节：</p>
<ul>
<li><p>年轻代回收 Young GC</p>
</li>
<li><p>老年代并发标记 Concurrent Marking</p>
</li>
<li><p>混合回收 Mix GC</p>
</li>
</ul>
<p>没完，如果情况特殊，单线程，独占式，高强度的FullGC还是会存在的，和CMS一样，提供一个后备保障。</p>
<h2 id="11-1-环节概述"><a href="#11-1-环节概述" class="headerlink" title="11.1 环节概述"></a>11.1 环节概述</h2><p>上面三个回收环节大致说一下：</p>
<h3 id="11-1-1-年轻代GC概述"><a href="#11-1-1-年轻代GC概述" class="headerlink" title="11.1.1 年轻代GC概述"></a>11.1.1 年轻代GC概述</h3><p>年轻代分配内存，当Eden区快满了的时候会触发一个 &#x3D;&#x3D;并发&#x3D;&#x3D;的&#x3D;&#x3D;独占&#x3D;&#x3D;的垃圾回收，在回收期间，G1暂停所有工作线程，启动多线程的垃圾回收器进行回收。把对象移动到 survivor 或者 old，或者俩都涉及。</p>
<h3 id="11-1-2-老年代并发标记概述"><a href="#11-1-2-老年代并发标记概述" class="headerlink" title="11.1.2 老年代并发标记概述"></a>11.1.2 老年代并发标记概述</h3><p>当老年代的占用率达到默认值(45%) 或者是我们指定的值时，出发并发标记。</p>
<h3 id="11-1-3-混合回收概述"><a href="#11-1-3-混合回收概述" class="headerlink" title="11.1.3 混合回收概述"></a>11.1.3 混合回收概述</h3><p>标记完成后，马上进行混合回收，G1移动老年代的存活对象到新的区(Region)，这些新区构成新的老年代。和别的收集器不同，G1不需要回收整个老年代，而是老年代中的一部分region。在回收老年的同时，年轻代的region也会被回收。所以叫混合回收。</p>
<h2 id="11-2-记忆集-Remembered-Set"><a href="#11-2-记忆集-Remembered-Set" class="headerlink" title="11.2 记忆集 Remembered Set"></a>11.2 记忆集 Remembered Set</h2><p>G1 在判断垃圾的时候就比较复杂，不像其他的垃圾回收器，虽然也有同类问题，但是因为G1的内存模型，导致G1更加麻烦。</p>
<p>首先就是一个对象可能被不同区域引用，比如一个老年代的对象可能引用了其他的年轻代对象，也就是一个对象在一个region上，另一个region也可能引用这个对象。所以说我们判断一个对象是否是垃圾，难道需要遍历所有的region去判断么？同时难道我们收集年轻代的时候，我们也要遍历整个老年代么？那么问题就来了，我们说过G1的应用场景是大内存多核CPU，在大内存情况下遍历所有region显然不合适，会降低MinorGC效率。</p>
<p>对于上面的问题，解决方案如下：</p>
<ul>
<li><p>无论是 G1还是其他的分代收集器，JVM都是采用 remembered set （以后简称为 RSet）来扫描全局。</p>
</li>
<li><p>每个region 都有一个 remember set。</p>
</li>
<li><p>每个Reference 类型数据写操作时，都会产生一个 Write Barrier暂停中断操作。</p>
</li>
<li><p>然后检查【将要写入的引用指向的对象】是否和Reference不在一个region，</p>
</li>
<li><p>如果Reference和指向对象不在一个region，通过CardTable把相关引用信息记录到引用指向对象的region对应的remembered set 中。</p>
</li>
<li><p>当垃圾收集时，在GCRoots的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会遗漏。</p>
</li>
</ul>
<p>以上说的，简直不是人话，来翻译一下：</p>
<ul>
<li><p>每个region都有个 rset，所谓rset，就是一个列表，或者什么其他的数据结构；这个表只干一件事，就是记录当前region中的哪些对象被其他region引用了。注意是其他region引用当前region对象。</p>
</li>
<li><p>Write Barrier 写屏障，就是你写入一个对象的时候，暂停一下，系统检查一下你写入的这个对象和你修改的引用是否在同一个region下。</p>
</li>
<li><p>如果不在同一个region，就通过CardTable在rset中记录。简单说，CardTable就记录了对象和其他region的引用，然后CardTable整体写到rset中。</p>
</li>
<li><p>在进行GC时，我们不是需要遍历GCRoots么，我们这个时候把当前你要收集的Region，的rset，也加入GCRoots中，遍历GCRoots也顺便遍历rset中记录的其他region，这样就不需要扫描全堆了。</p>
</li>
</ul>
<h2 id="11-3-G1回收具体流程一：年轻代"><a href="#11-3-G1回收具体流程一：年轻代" class="headerlink" title="11.3 G1回收具体流程一：年轻代"></a>11.3 G1回收具体流程一：年轻代</h2><h3 id="11-3-1-第一步：扫描根"><a href="#11-3-1-第一步：扫描根" class="headerlink" title="11.3.1 第一步：扫描根"></a>11.3.1 第一步：扫描根</h3><p>根是指的static 变量指向的对象，正在执行的方法调用链上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。这里切记肯定是要处理记忆集，尤其是年轻代，反倒是混合回收可能不需要记忆集，因为混合回收的时候年轻代老年代都要回收。</p>
<h3 id="11-3-2-第二步：更新RSet"><a href="#11-3-2-第二步：更新RSet" class="headerlink" title="11.3.2 第二步：更新RSet"></a>11.3.2 第二步：更新RSet</h3><p>处理Dirty Card Queue中的card，更新RSet。此阶段完成后Rset可以准确的反应老年代堆所在的内存分段中对象的引用。简单说，老年代Region的引用指向了其他region的对象。</p>
<p>不是人话，简单说，RSet一开始并没有写好，而是在这一步从 Dirty Card Queue 中获取card，加入 RSet。</p>
<p>JVM会在 Object o &#x3D; object; 执行前后进行一些特殊的操作，在 Queue 中保存一个card，然后在这一步集中把card取出来，然后更新RSet。</p>
<p>为啥这里不再 Object o &#x3D; object; 的时候就更新RSet？原因就是，更新RSet需要线程同步，开小会很大，所以在赋值的时候暂时不处理RSet。</p>
<h3 id="11-3-3-第三步：处理RSet"><a href="#11-3-3-第三步：处理RSet" class="headerlink" title="11.3.3 第三步：处理RSet"></a>11.3.3 第三步：处理RSet</h3><p>识别RSet中保存的老年代对象 中指向的年轻代对象。这些被老年代指向的年轻代对象就是存活对象。</p>
<h3 id="11-3-4-第四步：复制对象"><a href="#11-3-4-第四步：复制对象" class="headerlink" title="11.3.4 第四步：复制对象"></a>11.3.4 第四步：复制对象</h3><p>此阶段对象树被遍历，Eden区内存中存活对象全部被拷贝到 survivor区中空的内存分段。如果存活对象没有达到年龄阈值无法提升，则年龄计数器+1，达到则提升到老年代。如果survivor区空间不够，则直接提升到老年代。</p>
<h3 id="11-3-5-第五步：处理引用"><a href="#11-3-5-第五步：处理引用" class="headerlink" title="11.3.5 第五步：处理引用"></a>11.3.5 第五步：处理引用</h3><p>处理 Soft Weak Phantom Final JNIWeak等引用，最终eden区内存清空，GC线程停止，而目标内存中的对象都是连续的，在复制阶段就进行了排列，避免产生内存碎片。</p>
<h2 id="11-4-G1回收具体流程二：并发标记过程"><a href="#11-4-G1回收具体流程二：并发标记过程" class="headerlink" title="11.4 G1回收具体流程二：并发标记过程"></a>11.4 G1回收具体流程二：并发标记过程</h2><h3 id="11-4-1-初始标记阶段"><a href="#11-4-1-初始标记阶段" class="headerlink" title="11.4.1 初始标记阶段"></a>11.4.1 初始标记阶段</h3><p>标记从GCRoots直接可达的对象，注意是直接可达，这个过程触发STW。并且触发一次 Young GC。</p>
<p>这个过程和 CMS一样。</p>
<h3 id="11-4-2-根区域扫描-Root-region-scanning"><a href="#11-4-2-根区域扫描-Root-region-scanning" class="headerlink" title="11.4.2 根区域扫描 Root region scanning"></a>11.4.2 根区域扫描 Root region scanning</h3><p>G1 GC 扫描survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC 之前完成。</p>
<p>不说人话，survivor区中的引用指向的老年代对象。</p>
<h3 id="11-4-3-并发标记-concurrent-marking"><a href="#11-4-3-并发标记-concurrent-marking" class="headerlink" title="11.4.3 并发标记 concurrent marking"></a>11.4.3 并发标记 concurrent marking</h3><p>在整个堆中进行并发标记(和应用程序线程并发执行)，此过程可能被Young GC 中断。如果发现一个region里面全是垃圾，那就不用标记了，直接回收。同时，并发标记阶段会计算每个区域的对象活性。</p>
<h3 id="11-4-4-再次标记-Remark"><a href="#11-4-4-再次标记-Remark" class="headerlink" title="11.4.4 再次标记 Remark"></a>11.4.4 再次标记 Remark</h3><p>类似CMS的修正。由于应用程序没有停止，所以需要修正上次并发标记的结果。G1采用snapshot-at-the-beginning(SATB)算法进行修正，比CMS更快。</p>
<h3 id="11-4-5-独占清理-Clean-Up"><a href="#11-4-5-独占清理-Clean-Up" class="headerlink" title="11.4.5 独占清理 Clean Up"></a>11.4.5 独占清理 Clean Up</h3><p>计算各个区域的内存对象和GC回收比例，并进行排序，识别可以回收的区域，为下个阶段做铺垫。整个过程STW的。</p>
<h3 id="11-4-6-并行清理阶段"><a href="#11-4-6-并行清理阶段" class="headerlink" title="11.4.6 并行清理阶段"></a>11.4.6 并行清理阶段</h3><p>识别并清理完全空闲的区域</p>
<h2 id="11-5-G1回收具体流程三：混合回收"><a href="#11-5-G1回收具体流程三：混合回收" class="headerlink" title="11.5 G1回收具体流程三：混合回收"></a>11.5 G1回收具体流程三：混合回收</h2><p>当越来越多的对象晋升到老年代 old region 时，为了避免内存被消尽，虚拟机会触发一个混合垃圾收集器，也就是 MixedGC，这个算法并不是一个Old GC，除了除了回收整个 Young Region，还会回收一部分的 Old GC。这里需要注意，是一部分老年代，而不是全部的老年代。可以选择哪些 Old Region 进行回收，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC 并不是 FullGC。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>Java期末考试</title>
    <url>/2022/06/07/java-exam/</url>
    <content><![CDATA[<p>Java期末考试瞎指导。</p>
<span id="more"></span>

<h1 id="1-Java-概述"><a href="#1-Java-概述" class="headerlink" title="1. Java 概述"></a>1. Java 概述</h1><p>好像没啥会考的，主要就是主方法，记住就行了。</p>
<h1 id="2-基本数据类型和数组"><a href="#2-基本数据类型和数组" class="headerlink" title="2. 基本数据类型和数组"></a>2. 基本数据类型和数组</h1><p>八种基本数据类型 byte  char  short  int  long  float  double  boolean，大致有俩小知识点：</p>
<ul>
<li>精度丢失问题：高精度往低精度转化会丢东西</li>
<li>类型转化：这个又分强制类型转化和自动类型转化<ul>
<li>强制类型转化很简单：<code>long l = 1L; int i = (int)l;</code></li>
<li>自动类型转化：就是两个精度不一样的数据类型放在一起运算，会自动把低精度值转化为高精度值</li>
</ul>
</li>
</ul>
<p>单独的数组可能会考个小题，问你下面哪种创建数组的方式不对，这个记住三种创建数组的方式就行了：</p>
<ul>
<li>动态赋值 <code>int[] a = new int[数组长度];</code></li>
<li>静态赋值 <code>int[] a = new int[]&#123;...数组元素&#125;;</code></li>
<li>简化静态 <code>int[] a = &#123;...数组元素&#125;;</code></li>
</ul>
<p>然后数组的循环赋值，循环取值，<code>array.length</code> 得到数组长度应该都不用说了。</p>
<h1 id="3-运算符、表达式、语句"><a href="#3-运算符、表达式、语句" class="headerlink" title="3. 运算符、表达式、语句"></a>3. 运算符、表达式、语句</h1><p>运算符就是大致就是 + - * &#x2F; % 这种的，然后逻辑运算符就是与或非 &amp;&amp; || ! 这仨，没啥说的。</p>
<p>还有一些不咋常用的运算符比如三目，移位，位运算，不是很常用，了解就行了。</p>
<p>至于运算符的各种性质比如 结合性 运算符优先级等等，这种东西说实话没啥用，考的可能性有，撑死了一道小题，尤其优先级这个，我觉得智商100以上的人都会给算式加括号，实际情况不会去研究优先级这种东西。所以这个稍微看看就行了，不是重点。</p>
<p>语句，以及流程控制，这个东西和C++可以说一模一样：</p>
<ul>
<li>判断：<code>if()&#123;...&#125;</code>、<code>if()&#123;...&#125;else&#123;...&#125;</code>、<code>if()&#123;...&#125;else if()&#123;...&#125;else.&#123;..&#125;</code></li>
<li>循环：<code>for(..;..;..)&#123;...&#125;</code>、<code>while()&#123;...&#125;</code>、<code>do&#123;...&#125;while()</code></li>
<li>break、continue：用于终止循环和跳过剩余步骤继续下一轮循环，这个python和C++也都有</li>
</ul>
<p>剩下的什么变量命名规范，还有剩下的一些小知识点，我觉得都是码代码的基础规范了，不说了。</p>
<h1 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4. 类和对象"></a>4. 类和对象</h1><p>这章那就太重要了，可以这么说，100分的卷80分都和这章有联系，要么直接考这章，要么考后面的继承和接口，属于是间接的考这章的东西。</p>
<h2 id="4-1-如何写类和对象"><a href="#4-1-如何写类和对象" class="headerlink" title="4.1 如何写类和对象"></a>4.1 如何写类和对象</h2><p>和C++差不多，大致思路一样，就是语法变了而已。</p>
<p>这里面包含了第四章的1-6，比较简单，可以说是后面所有东西的基础。</p>
<h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2 方法"></a>4.2 方法</h2><p>这里分了两种方法：实例方法和静态方法。</p>
<ul>
<li>实例方法：只有创建对象以后，通过对象才能访问</li>
<li>静态方法：用static修饰，可以直接通过类名访问</li>
</ul>
<h2 id="4-3-方法重载"><a href="#4-3-方法重载" class="headerlink" title="4.3 方法重载"></a>4.3 方法重载</h2><p>简单说就是类里面的几个方法，方法名相同但是参数列表不同，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span>&#123; <span class="keyword">return</span> a + b + c + e; &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>&#123; <span class="keyword">return</span> sum(a, b, c, <span class="number">0</span>); &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123; <span class="keyword">return</span> sum(a, b, <span class="number">0</span>, <span class="number">0</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单的概念，记住就行了，大部分情况下不会没事干重载一个方法，考试的时候方法重载多半要和构造方法联动，到时候就是一个类好几个构造方法的重载，然后构造方法里面还有各种的this，问你创建完这个对象以后输出是啥。</p>
<h2 id="4-4-构造方法"><a href="#4-4-构造方法" class="headerlink" title="4.4 构造方法"></a>4.4 构造方法</h2><p>创建对象时给成员赋值的方法：</p>
<ul>
<li>方法名和类名相同，且没有返回值</li>
<li>构造方法也能重载</li>
<li>构造方法大致分为两类：无参构造和带参构造。区别就是有无入参</li>
<li>一个类至少有一个构造方法，如果不写，编译器会给你自动补一个无参构造</li>
<li>注意上面这条，只有不写构造的时候才会补，但凡写了构造，都不会给你补无参了</li>
</ul>
<h2 id="4-5-this关键字"><a href="#4-5-this关键字" class="headerlink" title="4.5 this关键字"></a>4.5 this关键字</h2><p>这个就比较重要了，可能会在这里出 除了 编程题以外的任何题型，比如选择题，再比如程序结果分析，给你一段代码里面套一堆this，问你最终输出啥。</p>
<p>同时这个this会和第五章的super联动，如果到时候出的题恶心的话，可能两个类相互继承，然后子类又是this又是super的，不好分析反正。</p>
<p>this有两种意思：</p>
<ul>
<li><code>this(...看情况有没有参数)</code>：指的是调用当前类的某一个构造方法，且<font color='red'>如果要写这个，必须写在构造器的第一行</font>，根据this() 的传参确定是哪一个构造方法的重载。</li>
<li><code>this.xxxx</code>：指的是当前类的某一个成员，为了避免方法的参数名和成员名重名。</li>
</ul>
<h2 id="4-6-访问控制"><a href="#4-6-访问控制" class="headerlink" title="4.6 访问控制"></a>4.6 访问控制</h2><p>其实就是三个访问修饰符：</p>
<ul>
<li>private：私有，类外不可访问</li>
<li>protected：受保护，同包下类外可以直接访问好像，这个不怎么用</li>
<li>public：公有，类外随便访问</li>
</ul>
<p>这里需要把握好一件事：<font color='red'>所有的访问控制都是相对于其他类对本类的访问，类内部随便访问类自身成员和方法，访问控制是用来限制类外对类的修改。</font>。</p>
<h2 id="4-7-包和Import"><a href="#4-7-包和Import" class="headerlink" title="4.7 包和Import"></a>4.7 包和Import</h2><p>这俩东西我天天用，但是问我这是啥我还真不好解释，包自己看吧，import我说一句：</p>
<p>import后面跟着的是你类的全限定命名，什么意思，就是说你有一个类，在 cn.heuet包下，有个类叫User，那你导入的时候就得写 <code>import cn.heuet.User</code>。这个cn.heuet.User 就是User这个类的全限定命名，就是把包名带上就行了。</p>
<h2 id="4-8-剩下的"><a href="#4-8-剩下的" class="headerlink" title="4.8 剩下的"></a>4.8 剩下的</h2><p>什么对象组合，就是类里面的成员是另一个类，什么对象数组，就是和基本数据类型差不多 <code>User[] users = new User[10];</code> 就是这个。</p>
<p>包装类提一句，就是把基础数据类型封装成了一个类，仅此而已，这个类里面包含了一些这个类型的一些属性。自己看书吧，这个不是很重要，包装类主要用在泛型上，但是你们学的似乎泛型不是重点，所以连带着包装类没那么重要。</p>
<h2 id="4-9-考题"><a href="#4-9-考题" class="headerlink" title="4.9 考题"></a>4.9 考题</h2><p>我觉得这一章的考题，大部分，应该都不会很难，难题主要集中在下一章。但是有另类，也就是 4.3-4.5。这几部分出题的话有可能会比较恶心。</p>
<p>可能会出程序分析题，就是给你一段代码，问你执行结果是啥，各种构造方法重载+this关键字，比如可能会出下面这种题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getA</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.a; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.a = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        System.out.println(<span class="string">&quot;a2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(a &gt; b ? a : b);</span><br><span class="line">        System.out.println(<span class="string">&quot;a3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(<span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">System.out.println(a.getA());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问：程序输出啥？</span></span><br><span class="line"><span class="comment">// a1</span></span><br><span class="line"><span class="comment">// a2</span></span><br><span class="line"><span class="comment">// a3</span></span><br><span class="line"><span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>反正我觉得这章的主要考点，额，都可能会提到点，各种小知识点，比如还有static，100%会考，但是我觉得难点就是这个构造重载+this。剩下的不是很难了。</p>
<h1 id="5-继承、接口、泛型"><a href="#5-继承、接口、泛型" class="headerlink" title="5. 继承、接口、泛型"></a>5. 继承、接口、泛型</h1><h2 id="5-1-继承"><a href="#5-1-继承" class="headerlink" title="5.1 继承"></a>5.1 继承</h2><p>这章的超级重点，真的是超级重点，往后什么接口，什么泛型，哪怕是上转型对象，也不如继承重要。为啥，继承的某些特性确实比较恶心，特别容易出程序分析题，甚至可以这么说，到时候程序分析题假如有5个，很有可能3个题，都是分析继承。</p>
<p>大致是什么题型呢？就是给你好几个类，最可能是两个类继承，如果老师不当人的话也有可能出现三个类以上互相继承，继承一大堆私有公有，然后同时需要考虑子父类的构造方法执行顺序。然后三个类磨磨唧唧给你继承完了，随便给你创建一个对象，问你打印啥东西，然后问你哪个成员的值是多少。这种题可以说就是整张卷子的难度天花板，极难分析而且极易出错。</p>
<p>题目知识点：</p>
<ul>
<li>构造方法重载</li>
<li>this关键字</li>
<li>super关键字</li>
<li>继承</li>
<li>方法重写</li>
<li>子类对象和父类对象成员冲突</li>
</ul>
<p>差不多一道这种程序分析题，少说上面这些东西融合个3 4个知识点，比如A类继承了B类，然后调用了B类的某个super，然后覆盖了某个B类的成员，再通过super.xxx去访问这个成员，然后调用两个B类的公开方法去操作B类的私有成员，巨麻烦巨绕。</p>
<p>我这里建议啊：碰见这种题，有条件直接敲一遍跑一遍，别自己分析，费力不讨好的。</p>
<p>这章的知识点挺多的我就不说了，看书吧，看不懂来问就行。看的重点就集中在继承这一块，就是this、super、重写、成员覆盖 等等。</p>
<h2 id="5-2-接口"><a href="#5-2-接口" class="headerlink" title="5.2 接口"></a>5.2 接口</h2><p>后面的接口，反倒不是很难，你们这本书基于jdk1.6，1.6的时候接口比较死板，就是一个类实现一个接口，然后必须实现这个接口里面的所有方法，就这么简单。</p>
<p>然后需要注意的就是：Java中类是单继承，但是可以多实现接口，这个记住了，可能考小题。</p>
<h2 id="5-3-上转型对象"><a href="#5-3-上转型对象" class="headerlink" title="5.3 上转型对象"></a>5.3 上转型对象</h2><p>这个不太好解释了，就是一个类，继承或者实现了另外一个东西，然后创建对象的时候就是 父类&#x2F;接口引用指向子类&#x2F;实现类对象。额，看代码吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这就是上转型</span></span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br></pre></td></tr></table></figure>

<p>前面A a，就是创建了一个父类的引用，后面真正创建了子类对象，然后A a &#x3D; new B(); 的意义就是 父类引用指向子类对象。</p>
<p>这个分为两个：一个是接口的上转型，或者叫接口回调；另一个是子类的上转型，就是父类引用指向子类对象。</p>
<p>前一个可以说不重要，但是后面这个，子类上转型为父类，就又可以和继承联动出一些让人想吐的题了。比如上面说的，3 4 个类来回继承，各种super this，好不容易继承完了，给你创建对象的时候给你来个上转型，哎，难度又高了，更不会了。</p>
<h2 id="5-4-剩下的东西"><a href="#5-4-剩下的东西" class="headerlink" title="5.4 剩下的东西"></a>5.4 剩下的东西</h2><p>比如各种奇葩的类，匿名类，内部类，异常类，泛型类，以及泛型，这些东西可以说不重要，多半不会考的，考了也是小题，不会是重点。</p>
<p>但是我还是提一句啊，异常这个东西，其实是特别重要的，奈何她讲的不行，考试也不是重点。咱们学的里面，接口回调+异常+泛型，这三个东西都是那种实际上相当重要但是她不给好好讲的。</p>
<h2 id="5-5-考题"><a href="#5-5-考题" class="headerlink" title="5.5 考题"></a>5.5 考题</h2><p>继承+重载+this+super+成员覆盖+方法重写+子类上转型，就这几个东西，会出一些难度极高的题。</p>
<p>反正我当年碰见这种程序分析题，看不懂，直接敲了一遍。比如可能会有这种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getA</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.a; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(<span class="type">int</span> a)</span>&#123; <span class="built_in">this</span>.a = a; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.a = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        System.out.println(<span class="string">&quot;a2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getB</span><span class="params">()</span> &#123; <span class="keyword">return</span> b; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(<span class="type">int</span> b)</span> &#123; <span class="built_in">this</span>.b = b; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b = <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;b1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(b);</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">        System.out.println(<span class="string">&quot;b2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(<span class="type">int</span> b)</span>&#123; <span class="built_in">this</span>.b = b; <span class="built_in">super</span>.setB(b / <span class="number">10</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getB</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.b; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSuperB</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="built_in">super</span>.getB(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">(<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>(<span class="number">2022</span>);</span><br><span class="line">        System.out.println(c.getB());</span><br><span class="line">        System.out.println(c.getA());</span><br><span class="line">        c.setB(<span class="number">100000</span>);</span><br><span class="line">        System.out.println(c.getB());</span><br><span class="line">        System.out.println(c.getA());</span><br><span class="line">        System.out.println(c.getSuperB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后问你输出是啥</span></span><br><span class="line">a1</span><br><span class="line">a2</span><br><span class="line">b2</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2022</span></span><br><span class="line"><span class="number">100000</span></span><br><span class="line"><span class="number">2022</span></span><br><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>这题我瞎写的啊，真正考试那题八成比我这个复杂点，我这个考虑了半天也没把上转型考虑进去，考试的时候这种题，咋也得用上转型恶心人。</p>
<h1 id="6-7-字符串系列和集合系列"><a href="#6-7-字符串系列和集合系列" class="headerlink" title="6. 7. 字符串系列和集合系列"></a>6. 7. 字符串系列和集合系列</h1><p>这俩东西，是面试的高频问题，对的，面试的高频问题，一遍面试一上来问你字符串的东西，然后面试会问你集合类的源码，比如ArrayList内部是否线程安全。话说回来，考试好像不是很重要。</p>
<p>字符串有个小知识点：就是字符串判断相等的问题，这个考试很有可能会考。</p>
<p>我这里就大致一说吧：字符串如果是 <code>String s1 = &quot;hello world&quot;;</code> 这种直接赋值，我们叫他字面量赋值，这个时候他就是指向了一块字符串内存，这个时候另一个字符串<code>String s2 = &quot;hello world&quot;;</code> s2 就也会指向这块内存。就是这种字面量赋值的方式，只要两个字符串内容相等，那么两个字符串 <code>s1 == s2 且 s1.equals(s2) == true</code>。</p>
<p>如果不是字面量赋值，比如这样 <code>String s1 = new String(&quot;hello world&quot;);</code> 那这就是一个对象，不会直接指向这个helloworld 的内存，这个时候另一个字符串 <code>String s2 = new String(&quot;hello world&quot;);</code> 即便内容相等，但是两个对象也不相等，这个时候 <code>s1 != s2 但 s1.equals(s2) == true</code> 。</p>
<p>看不懂的话看看书吧，这个地方要深究的话可以一路给你讲到JVM虚拟机讲到底层，那就费劲了。</p>
<p>剩下的各种字符串衍生类比如StringBuffer、StringToken啥的，还有什么Scanner这些的，似乎不重要，考的话也是考小题，然后正则表达式，我记得当年我们考过填空？还是选择，忘了。正则倒是有可能会考，但不是重点。</p>
<p>然后就是各种集合，这个集合一般会伴随泛型，但是既然泛型没咋讲，那我估计集合也不太会考，考的话也是考小题。对于考试来说数组就够用了，什么LinkedList什么TreeMap，学算法才可能用呢。</p>
<h1 id="8-线程"><a href="#8-线程" class="headerlink" title="8. 线程"></a>8. 线程</h1><p>如何创建线程啥的，考的可能性不大，至少不会让你们自己写线程，线程这个东西，我找了一个30多小时的课专门学的，挺难的，我觉得没啥必要重点看。</p>
<p>但是，如果我没猜错，这应该是你们第一次接触多线程，第一次听说线程通讯和线程状态，所以说概念题倒是很有可能考，我们当年考了一道简答题，就是直接问 线程有哪些状态，这些状态如何切换。</p>
<p>所以线程多看看概念我觉得就差不多了，如何创建线程，如何开始线程，甚至还有线程通讯，各种sleep各种notify，没啥必要花时间看我觉得。</p>
<h1 id="9-总结一下"><a href="#9-总结一下" class="headerlink" title="9. 总结一下"></a>9. 总结一下</h1><p>呐，复习吧，就紧着第四章和第五章复习，第五章呢，就紧着继承那块复习，我大胆预测一下啊，就继承那块，少说占个20分以上，而且出的题都是大题。剩下的小知识点就会出一些小题，比如可能会考你 面向对象的三个特征（封装继承多态）这类的小概念。</p>
<p>编程题反倒不会太难，因为继承那块的东西让你们写说实在的多少有点难为你们了，所以最后考的，应该就是让你们设计个类，然后写写方法，但是也不会太简单，C++的时候和Python考试编程题充其量就是让你写个水仙花数，打印个质数，Java就绝不会这么简单了。Java的编程题可能会多少和实践有点联系，比如让你用类实现个登录这种的。</p>
<p>嗯，说难不难说简单不简单的。</p>
]]></content>
  </entry>
  <entry>
    <title>JVM-堆</title>
    <url>/2022/05/28/jvm-heap/</url>
    <content><![CDATA[<p>很好，上一章讲了栈，这里开始看看堆是怎么一个情况。</p>
<blockquote>
<p>首先要说的一点是，整个这一章，都是关于堆的，在网课里面堆讲了30集，着实离谱，而且东西奇多，所以笔记也会多到离谱</p>
</blockquote>
<span id="more"></span>

<h1 id="1-堆的概述"><a href="#1-堆的概述" class="headerlink" title="1. 堆的概述"></a>1. 堆的概述</h1><ul>
<li><p>一个JVM实例只存在一个堆内存，堆也是 Java内存管理的核心区域</p>
<blockquote>
<p>一个进程对应一个JVM实例，JVM实例只有一个Runtime，Runtime里面只有堆和方法区是线程公用，所以说的直白了，一个进程只有一个堆</p>
</blockquote>
</li>
<li><p>JVM启动时堆的大小已经确定</p>
</li>
<li><p>堆的大小可以调节</p>
</li>
<li><p>Java虚拟机规范中规定，堆可以处于物理不连续的内存上，但是逻辑上应视为连续。</p>
<blockquote>
<p>如何证明堆是进程唯一的？需要用到一个工具，在 java.bin 目录下，jvisualvm，这个东西可以看到目前的java进程信息，(需要安装一个插件，VisualGC，工具里面就能安装).然后进入 visualGC</p>
</blockquote>
</li>
<li><p>即使整个线程共用一个堆，对内部还是有线程私有的缓冲区，最典型的就是 ThreadLocal，Buffer，TLAB Allocation，很好，目前我都不知道啥意思。</p>
</li>
<li><p>几乎所有的对象实例都分配在堆上，注意是几乎，不是所有，随着 JVM 的更新，JVM会进行逃逸检测，栈上也可以村对象了。</p>
</li>
<li><p>数组和对象可能永远不会存在栈上，栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
<blockquote>
<p>官网中JVM规范说的是所有，所以引出了下一条</p>
</blockquote>
</li>
<li><p>方法结束后，堆中的对象不会马上被删除，仅仅在垃圾收集的时候才会被删除。</p>
<blockquote>
<p>这里解释一下什么意思，一个方法，方法里面有引用，指向堆中的实例，当方法执行完成后，栈帧出栈，这时候引用就没了，就不在指向堆了，这个时候听不会马上GC，因为影响效率，他会在堆满了的时候去进行垃圾收集。</p>
</blockquote>
<blockquote>
<p>这里老师的原话是：出栈后引用为空，很好现在回来看，显然是栈帧出栈，局部变量表停止指向</p>
</blockquote>
</li>
<li><p>堆是GC作用的重点区域。</p>
</li>
</ul>
<h1 id="2-堆空间内存细分"><a href="#2-堆空间内存细分" class="headerlink" title="2. 堆空间内存细分"></a>2. 堆空间内存细分</h1><p>现代垃圾收集器大部分都是基于分带收集论涉及，对空间细分为：</p>
<ul>
<li><p>java7 包括之前的JVM 堆内存逻辑上分为 3部分：新生区 + 养老区 + 永久区</p>
<ul>
<li><p>Young Generation Space -&gt; 新生区 Young&#x2F;New</p>
<blockquote>
<p>又被划分为 Eden 区 和 Survivor 区</p>
</blockquote>
</li>
<li><p>Tenure Generation space -&gt; 养老区 Old&#x2F;Tenure</p>
</li>
<li><p>Permanent Space -&gt; 永久区 Perm</p>
</li>
</ul>
</li>
<li><p>java8 以后堆内存逻辑上分为3部分：新生区 + 养老区 + 元空间</p>
<ul>
<li><p>Young Generation Space 新生区 Young&#x2F;New</p>
<blockquote>
<p>同理分为 Eden Survivor</p>
</blockquote>
</li>
<li><p>Tenure Generation Space 养老区 Old&#x2F;Tenure</p>
</li>
<li><p>Meta Space 元空间 Meta</p>
</li>
</ul>
</li>
</ul>
<p>需要注意的是，永久代和元空间其实并不属于 堆，而是属于方法区，所以在这里不细说永久代。 如何证明堆包括元空间和养老代？还是昨天那个工具：Jvisualvm，里面的 visualGC， 里面 三块，enden survivor tenure 加起来 就是你设置的 堆的大小。</p>
<p>在Java 中分别叫 PSYoungGen&#x3D;新生区 ParOldGen&#x3D;养老区 MetaGen&#x2F;PSPermGen&#x3D;元空间&#x2F;永久区</p>
<h1 id="3-设置堆空间大小"><a href="#3-设置堆空间大小" class="headerlink" title="3. 设置堆空间大小"></a>3. 设置堆空间大小</h1><ul>
<li><p>堆的大小在JVM启动的时候就已经设定好了，可以通过 -Xmx 和 -Xms 来设置</p>
<ul>
<li><p>-Xms 用来表示堆区的初始内存，等价于： -XX:InitialHeapSize</p>
</li>
<li><p>-Xmx 用来表示堆区的最大内存，等价于：-XX:MaxHeapSize</p>
<blockquote>
<p>-X 是 JVM 参数，ms &#x3D; memory start</p>
</blockquote>
</li>
</ul>
</li>
<li><p>一旦堆区的内存大小超过 -Xmx，就会跑出 OutOfMemoryError异常。</p>
</li>
<li><p>通常会将-Xms 和 -Xmx配置相同的值，目的就是为了能够在Java垃圾回收机制清理完堆区后 不需要重新分割计算堆区的大小，从而提供性能。</p>
</li>
<li><p>默认情况下，初始内存大小：物理电脑内存大小 &#x2F; 64,最大内存：物理电脑内存大小 &#x2F; 4</p>
</li>
</ul>
<h1 id="4-堆的年轻代和老年代"><a href="#4-堆的年轻代和老年代" class="headerlink" title="4. 堆的年轻代和老年代"></a>4. 堆的年轻代和老年代</h1><p>别说话，看图： </p>
<p><img src="/../images/runtime/HeapOldGenAndYoungGen.png" alt="heap"></p>
<p>存储在JVM中的Java对象可以分为两类：</p>
<ul>
<li><p>生命周期比较短的瞬时对象，创建消亡都非常迅速</p>
</li>
<li><p>生命周期比较长，极端情况下和JVM的声明周期一样长</p>
</li>
</ul>
<p>创建出来的对象先放在 年轻代的Eden 区，进行一轮垃圾回收之后，如果是垃圾了，就直接回收了， 如果不是垃圾，说明对象幸存，则放到 survivor0 或者 survivor1 中。</p>
<blockquote>
<p>survivor 也叫 from &#x2F; to 区</p>
</blockquote>
<h2 id="内存占比"><a href="#内存占比" class="headerlink" title="内存占比"></a>内存占比</h2><p>默认情况下，年轻代和老年代占比 1:2，也就是年轻代占堆的1&#x2F;3，老年代占堆的 2&#x2F;3.能不能手动调整？可以，启动时添加JVM参数：<code>-XX:NewRatio=n</code> 设置年轻代和老年代占比 1:n。当然默认情况下是 <code>-XX:NewRatio=2</code>。但是这个数一般不建议改，除非你确定项目中有很多老对象。</p>
<p>HotSpot虚拟机中，伊甸园区和幸存者区占比为 8:1:1。同理可以通过启动参数 <code>-XX:survivorRatio=n</code> 来调整。但是需要说一下，其实启动后占比是6:1:1，而不是8:1:1，你要是真想让他8:1:1符合规范，那你设置一下好了。</p>
<p>几乎所有对象首先都是在Eden区创建，除非这个对象太大了直接放到OldGen，而且大部分对象的销毁都是放在Eden中，有研究表明 80%的对象都是朝生暮死，生命周期很短。如果我们嫌不够的话，可以使用参数 <code>-Xmn</code> 来调整新生代大小.</p>
<h1 id="5-创建对象的大体流程"><a href="#5-创建对象的大体流程" class="headerlink" title="5. 创建对象的大体流程"></a>5. 创建对象的大体流程</h1><p>前文说道，创建对象一般发生在新生代，那么新生代具体发生了什么，让我们来详细说一说，注意，这里并没有提到类加载器，仅仅是在对重给对象分配内存流程。后面还会详细说一个对象创建具体的流程。</p>
<h2 id="5-1-流程"><a href="#5-1-流程" class="headerlink" title="5.1 流程"></a>5.1 流程</h2><ol>
<li><p>在Eden区分配空间，大部分情况都是吧对象分配在eden区，上文也说过，除非这个对象特别大</p>
</li>
<li><p>当Eden区满了的时候，出发年轻代的垃圾回收机制，叫 YGC(YoungGC) 或者叫 MinorGC，Eden中已经没有了引用的对象将会被回收，剩下的对象，将会进入 survivor0 或者 survivor1，这里我们先假设 survivor0 和 survivor1 都是空的，再假设 Eden中没有被回收的对象进入了 survivor0.这个时候 survivor0 就叫to区，同时进入 survivor0 的对象有一个年龄计数器，用来记录幸存次数，从 0 变成 1。</p>
</li>
<li><p>继续创建对象，放在 Eden中，当Eden再一次满了，再次触发 YGC，这回Eden中的幸存对象将会进入空的那个 survivor，这里空的是 survivor1，年龄计数器变为1，同时 survivor0 中的对象也进行YGC，s0中的幸存者也会进入s1，那么这个时候，s1就叫to区，s0就叫from 区，s区的垃圾回收是 Eden 回收，他也顺带回收一下，如果 s区满了，再说。</p>
</li>
<li><p>一直进行这个 Eden + from &#x3D;&gt; to 的过程，同时对象的年龄计数器累加。</p>
</li>
<li><p>当一个对象的年龄计数器值达到临界的时候，默认是15，那么就会认为这个对象的生命周期很长，就会把它放入 老年代。这个过程叫提升 ：Promotion</p>
</li>
</ol>
<h2 id="5-2-总结"><a href="#5-2-总结" class="headerlink" title="5.2 总结"></a>5.2 总结</h2><ul>
<li><p>针对 s区，复制之后有交换，谁空谁是to</p>
</li>
<li><p>关于垃圾回收，频繁在 新生代回收，很少在老年代回收，几乎不再永生代(Meta) 回收。</p>
</li>
<li><p>再出发 YGC 的时候，Eden区肯定是被清空了</p>
</li>
</ul>
<h2 id="5-3-特殊情况"><a href="#5-3-特殊情况" class="headerlink" title="5.3 特殊情况"></a>5.3 特殊情况</h2><p>看图：</p>
<p><img src="/../images/runtime/MemoryHandleSpecialCase.png" alt="heap_memory"></p>
<p>解释一下： 正常流程肯定能看懂，说一点特殊情况：</p>
<ul>
<li><p>Eden 放不下了，可能是 Eden 满了，触发 YGC，然后Eden 还是放不下，这个时候Eden肯定是 空了，说明 对象大小超过了 Eden大小，则直接放入 老年代。</p>
</li>
<li><p>上面这种情况，如果 老年代也放不下，触发 FGC，还放不下，那完了，抛出 OOM错误。</p>
</li>
<li><p>触发YGC的时候，如果 s区放不下，就直接进入老年代。</p>
</li>
</ul>
<h1 id="6-堆垃圾回收"><a href="#6-堆垃圾回收" class="headerlink" title="6. 堆垃圾回收"></a>6. 堆垃圾回收</h1><p>大体来看，Heap 中的 GC 分为 3种：</p>
<ul>
<li><p>Young GC &#x2F; MinorGC</p>
</li>
<li><p>Full GC</p>
</li>
<li><p>Old GC &#x2F; Major GC</p>
</li>
</ul>
<p>根据 HotSpot 虚拟机，按照收集区域又分为两种：部分收集和整堆收集</p>
<ul>
<li><p>部分收集：不是完整收集整个Java 堆的收集，其中又分为：</p>
<ul>
<li><p>新生代收集 MinorGC&#x2F;YoungGC: 只收集年轻代的垃圾收集</p>
</li>
<li><p>老年代收集 MajorGC&#x2F;OldGC： 只收集老年代</p>
<ul>
<li><p>目前只有CMS GC会有单独收集老年代的行为</p>
</li>
<li><p>很多时候 MajorGC 会和 FullGC 混合使用，需要具体分辨是老年代回收还是整堆回收</p>
</li>
</ul>
</li>
<li><p>混合回收器 Mixed GC：收集整个新生代和部分老年代的垃圾</p>
<ul>
<li>只有G1 GC 有这种行为</li>
</ul>
</li>
</ul>
</li>
<li><p>整堆收集：收集整个 Java 堆 和 方法区 的垃圾，注意，还包括方法区。</p>
</li>
</ul>
<p>下面说一下各个内存部分的垃圾回收触发机制：</p>
<h2 id="6-1-年轻代触发机制"><a href="#6-1-年轻代触发机制" class="headerlink" title="6.1 年轻代触发机制"></a>6.1 年轻代触发机制</h2><ul>
<li><p>年轻代空间不足，就会触发minor gc,这里说的空间不足指的是eden空间不足，survivor 满了不会触发 minor gc，只会发生提升。每次回收都会清空年轻代内存。</p>
</li>
<li><p>Java 对象大多数申明周期很短，所以minor gc 发生的特别频繁。</p>
</li>
<li><p>minor gc 会触发STW，也就是暂停用户线程，等垃圾回收结束，才会恢复用户线程</p>
</li>
</ul>
<h2 id="6-2-老年代回收："><a href="#6-2-老年代回收：" class="headerlink" title="6.2 老年代回收："></a>6.2 老年代回收：</h2><ul>
<li><p>发生在老年代的垃圾回收，当对象从老年代消失了，我们就认为 major gc 或者 full gc 发生了，</p>
</li>
<li><p>发生一次 major gc，一般来说，伴随着至少一次的minor gc，不是绝对的，以后再说。</p>
<ul>
<li>也就是当老年代空间不足时，西安出发一次 minor gc，如果空间还不足，触发 major gc</li>
</ul>
</li>
<li><p>major gc 一般比 minor gc 慢10倍以上，stw 时间更长。</p>
</li>
<li><p>如果major gc后空间还是不够，抛出 OOM 异常。</p>
</li>
</ul>
<h2 id="6-3-FullGC-触发机制："><a href="#6-3-FullGC-触发机制：" class="headerlink" title="6.3 FullGC 触发机制："></a>6.3 FullGC 触发机制：</h2><ul>
<li><p>调用 System.gc() 时</p>
</li>
<li><p>老年代空间不足</p>
</li>
<li><p>方法区空间不足</p>
</li>
<li><p>通过 minor gc 后进入老年代的平均大小大于老年代的可用内存</p>
</li>
<li><p>eden from 的对象往 to 区复制，to区空间不够，提升到老年代，老年代空间也不够，触发 full gc</p>
</li>
<li><p>开发中尽量避免 full gc</p>
</li>
</ul>
<h1 id="7-TLAB"><a href="#7-TLAB" class="headerlink" title="7. TLAB"></a>7. TLAB</h1><p>前文说过TLAB，说是 堆里面有每个线程的私有缓冲区，有 TLAB，ThreadLocal，Buffer，Allocation，其实后面的三个词全都在说 TLAB。</p>
<h2 id="7-1-TLAB是啥"><a href="#7-1-TLAB是啥" class="headerlink" title="7.1 TLAB是啥"></a>7.1 TLAB是啥</h2><p>ThreadLocal Buffer Allocation： 线程私有缓冲区，用于结局线程安全问题。</p>
<h2 id="7-2-为什么要设置TLAB"><a href="#7-2-为什么要设置TLAB" class="headerlink" title="7.2 为什么要设置TLAB"></a>7.2 为什么要设置TLAB</h2><p>堆是整个进程共享的一块区域，如果一大堆线程同事访问堆，会造成县城不安全，如果给数据加锁，那效率就太慢了，所以为了提高效率，加入了线程缓冲区。</p>
<p>JVM给每个线程在 Eden 划分出来一块 TLAB，这种方式解决了线程安全问题，提高了内存分配吞吐量，我们就管这种方式叫“快速分配策略”.</p>
<p>虽然说不是所有对象都可以分配在 TLAB上，但是TLAB确实是JVM分配对象的首选。TLAB非常小，仅仅占到了 Eden的 1%。</p>
<p>如果对象在TLAB分配失败，JVM就会考虑给对象加锁，直接把对象放在Eden中。</p>
<h2 id="7-3-一些参数"><a href="#7-3-一些参数" class="headerlink" title="7.3 一些参数"></a>7.3 一些参数</h2><ul>
<li><p>-XX:useTLAB 是否开启TLAB，默认开启</p>
</li>
<li><p>-XX:TLABWasteTargetPercent 设置TLAB占Eden的百分比。</p>
</li>
</ul>
<h2 id="7-4-对象创建过程"><a href="#7-4-对象创建过程" class="headerlink" title="7.4 对象创建过程"></a>7.4 对象创建过程</h2><p>有了TLAB以后，对象创建流程如下：</p>
<p><img src="/../images/runtime/TLAB.png" alt="tlab"></p>
<h2 id="7-5-剩下的"><a href="#7-5-剩下的" class="headerlink" title="7.5 剩下的"></a>7.5 剩下的</h2><p>p81 没好好看，以后可以补一补。</p>
<h1 id="8-逃逸分析"><a href="#8-逃逸分析" class="headerlink" title="8. 逃逸分析"></a>8. 逃逸分析</h1><p>随着 JIT(编译器) 的发展，逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术 导致技术上有了一点区别，那就是 堆上分配对象不再那么绝对了。</p>
<p>大部分情况下，一个对象在堆上分配空间，但是在某些特殊情况下，这个对象经过了逃逸分析，发现这个方法并没有逃离方法，那么这个对象就有可能在栈上分配空间。</p>
<p>但是提一句，HotSpot虚拟机可是没有逃逸分析里面的部分功能的，比如栈上分配这个，HotSpot就没有。</p>
<h2 id="8-1-逃逸分析概述"><a href="#8-1-逃逸分析概述" class="headerlink" title="8.1 逃逸分析概述"></a>8.1 逃逸分析概述</h2><p>逃逸分析干嘛的？就是用来优化内存分配的，我们前面说对象都要分配到堆上，但是堆上涉及到GC，而栈却不涉及GC，所以可不可以把对象存到栈上，然后方法执行完成直接弹栈，省的GC了。所以这个就是逃逸分析要干的事，分配一个对象，就要看这个对象有没有发生逃逸，如果发生逃逸，也就是这个对象跑出了当前方法作用域，那么发生逃逸，该咋办咋办，如果没有，则可以进行优化。就可以把这个对象放到栈上。</p>
<ul>
<li><p>通过逃逸分析，Java Hotspot 编译器能够分析一个对象的引用从而决定这个对象是否分配到栈上。</p>
</li>
<li><p>逃逸分析的基本行为就是分析对象的作用域：</p>
<ul>
<li><p>一个对象被定义后，如果只在方法中调用，那么没有发生逃逸。</p>
</li>
<li><p>对象被定义后，方法外也引用了它，则发生了逃逸。比如方法中创建的对象最后被return了。</p>
</li>
</ul>
</li>
<li><p>没有发生逃逸，则对象可以分配到栈上，毕竟别的地方不用，方法执行完，栈帧出栈，对象也跟着出栈。</p>
</li>
<li><p>发生逃逸，那就老老实实往堆上分配。</p>
</li>
</ul>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这种情况下，user 对象仅仅在方法内部被调用，则没有逃逸，往栈上分配就行了  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();  </span><br><span class="line">    user = <span class="literal">null</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 这种情况，StringBuffer 最终被return，发生了逃逸。  </span></span><br><span class="line"><span class="keyword">public</span> StringBuffer <span class="title function_">getString</span><span class="params">(String a, String b)</span>&#123;  </span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();  </span><br><span class="line">    buffer.append(a);  </span><br><span class="line">    buffer.append(b);  </span><br><span class="line">    <span class="keyword">return</span> buffer;  </span><br><span class="line">&#125;  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 上面的 StringBuffer 改成这种，就不会发生逃逸  </span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getString</span><span class="params">(String a, String b)</span>&#123;  </span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();  </span><br><span class="line">    stringBuffer.append(a);  </span><br><span class="line">    stringBuffer.append(b);  </span><br><span class="line">    <span class="keyword">return</span> stringBuffer.toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数如下：</strong></p>
<ul>
<li><p>-XX:-DoEscapeAnalysis 关闭逃逸分析</p>
</li>
<li><p>-XX:+DoEscapeAnalysis 开启逃逸分析</p>
</li>
</ul>
<h2 id="8-2-逃逸分析：代码优化"><a href="#8-2-逃逸分析：代码优化" class="headerlink" title="8.2 逃逸分析：代码优化"></a>8.2 逃逸分析：代码优化</h2><p>总的来说，可以通过逃逸分析干好多事，上面那个，仅仅是一个 栈上分配。</p>
<p>逃逸检测的优化：</p>
<ul>
<li><p>栈上分配</p>
</li>
<li><p>同步省略</p>
</li>
<li><p>分离对象&#x2F;标量替换</p>
</li>
</ul>
<h3 id="8-2-1-栈上分配"><a href="#8-2-1-栈上分配" class="headerlink" title="8.2.1 栈上分配"></a>8.2.1 栈上分配</h3><p>就是前面说的，站上分配对象，如果实体仅仅在方法内部使用没有进入外部，则对象会被分配到栈上。</p>
<h3 id="8-2-2-同步省略"><a href="#8-2-2-同步省略" class="headerlink" title="8.2.2 同步省略"></a>8.2.2 同步省略</h3><p>如果一个对象仅在一个线程中使用，或者说，一个对象只能从一个线程中被访问，那么对于这个对象的操作就不考虑同步。</p>
<ul>
<li><p>线程同步的代价是很高的。</p>
</li>
<li><p>在动态编译同步代码块的时候，如果JIT 检测到一个对象仅仅在一个线程中被访问，而没有发布到其他线程，则运行时 JVM 就会取消对这个对象进行上锁，大大的提高效率，这就叫 锁消除。</p>
</li>
</ul>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();  </span><br><span class="line">    <span class="keyword">synchronized</span>(user)&#123;  </span><br><span class="line">        System.out.println(user);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 上面这种情况，user 对象仅仅在一个线程中被访问，并没有多个线程共享，所以几遍你给他加了锁，  </span></span><br><span class="line"><span class="comment">// JVM也不会执行，但是废话，这种情况，本来我们就不应该加锁。</span></span><br></pre></td></tr></table></figure>

<h3 id="8-2-3分离对象或标量替换"><a href="#8-2-3分离对象或标量替换" class="headerlink" title="8.2.3分离对象或标量替换"></a>8.2.3分离对象或标量替换</h3><p>有的对象可能不需要作为一个连续的内存结构存入到内存中，而且也可以被访问到。那么这部分对象的部分(甚至全部) 就可以存到 CPU的寄存器中。</p>
<p>用Java 说，就是这个对象不用存在 堆中，那就可以放到 栈 中。这里还需要解释几个概念：</p>
<p><strong>标量</strong></p>
<p>无法被分解成更小的数据，比如基本数据类型。</p>
<p><strong>对应聚合量</strong></p>
<p>还可以被分解的对象就是聚合量，比如我们自己写的类的实例。</p>
<p><strong>标量替换</strong></p>
<p>如果经过逃逸分析，发现你目前的对象没有在方法外面使用，他就会把你的聚合量，分解为几个标量，这个过程就叫标量替换。</p>
<p>说白了，就是吧对象打散了，分配到栈上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();  </span><br><span class="line">    System.out.println(<span class="string">&quot;Point.x=&quot;</span> + p.x + <span class="string">&quot; Point.y=&quot;</span> + p.y);  </span><br><span class="line">&#125;  </span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 最终这个东西会被优化成  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;  </span><br><span class="line">    System.out.println(<span class="string">&quot;Point.x=&quot;</span> + x + <span class="string">&quot; Point.y=&quot;</span> + y);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-XX:+EliminateAllocation 开启标量替换，默认就是开启的。</p>
<h2 id="8-3-总结"><a href="#8-3-总结" class="headerlink" title="8.3 总结"></a>8.3 总结</h2><p>大体说几点：</p>
<ul>
<li><p>逃逸分析并不成熟</p>
</li>
<li><p>逃逸分析本身也消耗性能，如果分析了半天，结果发现都逃逸了，那完犊子了</p>
</li>
<li><p>Oracle HotSpot 并没有栈上分配，所以肯定对象都在堆上</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署</title>
    <url>/2022/05/22/hexo%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>整个博客使用Hexo搭建，需要电脑上有 node + git 环境，如果没有，请移步下面的教程：</p>
<p><a href="https://www.bilibili.com/video/BV1q4411i7gL">hugo博客搭建</a></p>
<span id="more"></span>

<h1 id="1-Github-Page"><a href="#1-Github-Page" class="headerlink" title="1. Github Page"></a>1. Github Page</h1><p>干嘛的？就是github会给你一个域名，比如 xxx.github.io，这个域名你可以用来部署一些静态页面，步骤也很简单，只要仓库里面是静态页面的文件就可以了。有了这个我们就可以搭建个人博客。</p>
<p><strong><font color='red'>步骤如下：</font></strong></p>
<p>在github创建仓库，仓库名必须是 xxxx.github.io，而且这个xxx，最好是你的用户名，必须遵从这个规范。创建完以后，只要你这个仓库里面有静态页面的东西，那 page 就会生效。可以选择用READMD初始化一下仓库，然后在仓库的 settings 里面，找到 Pages，会发现里面给你提供了一个可访问的网址，说明page已经生效。</p>
<p>如果settings-page里面没有那个网址，说明空仓库，没关系，待会就有了。</p>
<h1 id="2-Hexo"><a href="#2-Hexo" class="headerlink" title="2. Hexo"></a>2. Hexo</h1><p>我们这里选择Hexo来搭建仓库，这里提供一个视频，可以跟着视频搭：</p>
<p><a href="https://www.bilibili.com/video/BV1Yb411a7ty">Hexo搭建教程</a></p>
<h2 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h2><p>所以这个hexo是个什么原理？其实很简单。我们在博客项目下编写md文档，然后hexo会帮我们自动把md文档转化为html，然后连同hexo这个网站一起，打包，发到你配置的git仓库实现自动部署。</p>
<p>所以这也是我之前的一个错误理解，我以为hexo是一个后端服务，需要把他部署在服务器上，github page 帮我们跑这个服务器。其实不该是这么用的，而是hexo安装在我们本地，我们在博客里面写好文章，然后通过命令让hexo帮我们打包发送到git，然后git帮我们部署打包好的静态页面。</p>
<p>当然啦，如果你和我一样弱智的话，也可以把hexo当后端服务跑，hexo提供了一个本机预览的功能，有点类似Vue 的 npm run serve，你大可以找个服务器然后 <code>nohup hexo s &amp;</code>。</p>
<h2 id="2-2-安装流程"><a href="#2-2-安装流程" class="headerlink" title="2.2 安装流程"></a>2.2 安装流程</h2><blockquote>
<p>这里必须要有 node.js 环境，没有的话去装 hugo，同时必须要有git</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 hexo</span></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化 hexo 项目，你自己找一个目录，然后在里面执行这条命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注：这里强烈建议配置一下 github 加速，因为这一步要从github拉东西，太慢的话可能会报错</span></span><br><span class="line">hexo init blog</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等待初始化结束，本地启动hexo</span></span><br><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<p>然后，正常情况下，会提示这么一句：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<p>如果没有这句，那么不出意外地话应该是出意外了，把错误信息百度一下看看 :)</p>
<p>OK，到这里算是安装完了，但是我们还需要配置一下这个玩意。</p>
<h2 id="2-3-配置基本信息"><a href="#2-3-配置基本信息" class="headerlink" title="2.3 配置基本信息"></a>2.3 配置基本信息</h2><p>博客根目录下有个 _config.yml 文件，打开他，改几个地方：</p>
<h3 id="2-3-1-配置博客基本信息"><a href="#2-3-1-配置博客基本信息" class="headerlink" title="2.3.1 配置博客基本信息"></a>2.3.1 配置博客基本信息</h3><p>配置文件中会找到这么几行：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">博客网站的题目</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;博客小标题&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;描述信息&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">用户名</span></span><br><span class="line"><span class="comment"># 配置语言-简中</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br><span class="line"><span class="comment"># 时区</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-配置仓库"><a href="#2-3-2-配置仓库" class="headerlink" title="2.3.2 配置仓库"></a>2.3.2 配置仓库</h3><p>往后找，找到这么几行：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="comment"># 这里写你的git仓库地址</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">http://xxxxx@github.com/user_name/user_name.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-小坑"><a href="#2-3-3-小坑" class="headerlink" title="2.3.3 小坑"></a>2.3.3 小坑</h3><p>如果这里你配置的是github的仓库地址，那可能需要麻烦点，这里直接写 <a href="https://github.com/xxx/xxx.github.io.git">https://github.com/xxx/xxx.github.io.git</a> 的话，push 的时候会让你输入用户名密码，然后，很可能告诉你现在已经不支持密码验证了，要你配置token。</p>
<p>我这里就不展开说了，百度一下如何获取github的token，然后把这个地址写成 <code>https://your_token@github.com//xxx/xxx.github.io.git</code> 即可。</p>
<h2 id="2-4-安装主题"><a href="#2-4-安装主题" class="headerlink" title="2.4 安装主题"></a>2.4 安装主题</h2><p>我这里选择使用 NexT主题，同样的，在博客项目中执行如下命令，切记必须是博客根目录，就是有 node_modules 那个目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">克隆主题源码到 博客的themes 目录下</span></span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next.git themes/next</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装一个包，不安装的话可能会乱码</span></span><br><span class="line">npm install hexo-renderer-swig</span><br></pre></td></tr></table></figure>

<p>然后配置根目录下的 _config.yml 文件，找到 theme，修改为: <code>theme: next</code> 即可，然后执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo g</span><br></pre></td></tr></table></figure>

<p>访问 localhost:4000 看看效果。希望没有乱码。</p>
<h2 id="2-5-Tags-amp-Categories-amp-About"><a href="#2-5-Tags-amp-Categories-amp-About" class="headerlink" title="2.5 Tags &amp; Categories &amp; About"></a>2.5 Tags &amp; Categories &amp; About</h2><p>我们的博客里面的文章得有分类和标签吧？还得有个关于页面吧？怎么配置呢？</p>
<p>在博客根目录下执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line">hexo new page about</span><br><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>然后，进入source目录，会发现里面有了三个目录，分别是 categories  tags  about。我们挨个改：</p>
<p>首先是进入 categories 目录，编辑 index.md，固定写法，其实就是在date下面，线上面，加一个 <code>type: &quot;categories&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: Categories</span><br><span class="line">date: 2022-05-21 11:43:02</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure>

<p>同理Tags，编辑里面的 index.md ，在date 下面，线上面，加一个 <code>type: &quot;tags&quot;</code> 即可。</p>
<p>同理about，编辑index.md，里面写上你想写的东西就行了。</p>
<p>然后，这三个页面以后都不要管了。</p>
<h2 id="2-6-主题配置"><a href="#2-6-主题配置" class="headerlink" title="2.6 主题配置"></a>2.6 主题配置</h2><p>这可就麻烦了，比如 配置头像，配置github，配置主题的主题，配置搜索功能 等等。这里给个博客自己看吧：</p>
<p><a href="https://blog.csdn.net/weixin_42665200/article/details/104633560">NexT配置</a></p>
<h1 id="3-部署"><a href="#3-部署" class="headerlink" title="3. 部署"></a>3. 部署</h1><p>这个倒是出奇的简单，直接 hexo d 即可。这一步他就会把项目打包，然后传给github，然后github就会给你部署你的静态页面。</p>
<p>当然啦，只要是支持git page 的git网站应该都行，比如gitee，但是gitee申请page挺麻烦的，还得实名认证，不想琢磨。</p>
]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机栈</title>
    <url>/2022/05/27/jvm-stack/</url>
    <content><![CDATA[<p>虚拟机栈，JVM用于处理方法执行的地方，东西还挺多，而且还听重要.</p>
<span id="more"></span>

<h1 id="1-虚拟机栈概述"><a href="#1-虚拟机栈概述" class="headerlink" title="1. 虚拟机栈概述"></a>1. 虚拟机栈概述</h1><blockquote>
<p>Java Virtual Machine Stack</p>
</blockquote>
<p>首先明确个概念，JVM是基于栈的存储模型(当然还有基于寄存器的)，一般来说java 中 栈里面存放运行时数据，堆 进行存储，比如创建对象，就会放到堆里面，当然这不代表栈不会存数据，一些局部变量也是存在栈里面的。</p>
<h2 id="1-1-虚拟机栈是什么"><a href="#1-1-虚拟机栈是什么" class="headerlink" title="1.1 虚拟机栈是什么"></a>1.1 虚拟机栈是什么</h2><p>每个线程创建时都会创建一个虚拟机栈，里面存储着栈帧(Stack Frame) 对应方法调用，栈帧就是方法调用，方法开始调用栈帧入栈，方法调用结束栈帧出栈。</p>
<p>生命周期和JVM一样。</p>
<h2 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2 作用"></a>1.2 作用</h2><p>主管程序的运行，保存方法的局部变量，部分结果，并参与方法的调用和返回</p>
<blockquote>
<p>局部变量包括 8 中基本数据类型和 引用数据类型的引用，仅限引用地址，不包括实际的对象，对象在堆中。</p>
</blockquote>
<p>大致说一下，先不说那么细，看图： </p>
<p><img src="/images/runtime/stackFrame.png" alt="stack_frame"></p>
<p>这里定义两个方法，A 和 B，然后两个方法进行入栈操作，绿色的就是 B 方法，那么栈顶的方法就是当前方法，然后B执行完，A就是当前方法。</p>
<p>那么目前，我们可以粗略的将方法，理解为栈帧，当然栈帧里面还细分一堆东西，我们现在先不说了。</p>
<h2 id="1-4-栈的优点"><a href="#1-4-栈的优点" class="headerlink" title="1.4 栈的优点"></a>1.4 栈的优点</h2><ul>
<li><p>有效的存储方式，访问速度仅次于程序计数器</p>
</li>
<li><p>JVM 对栈的操作只有两个</p>
<ul>
<li><p>方法执行，入栈</p>
</li>
<li><p>执行完，出栈</p>
</li>
</ul>
</li>
<li><p>不存在垃圾回收</p>
<blockquote>
<p>栈不存在 GC 但是存在 OOM (out of memory 内存溢出),PC寄存器俩都没有</p>
</blockquote>
</li>
</ul>
<h2 id="1-5-栈可能出现的问题"><a href="#1-5-栈可能出现的问题" class="headerlink" title="1.5 栈可能出现的问题"></a>1.5 栈可能出现的问题</h2><p>Java 中，栈的大小可以是动态的或者固定不变的。如果栈的大小固定不变，那么入栈操作可能会因为栈满了而报错， 抛出 StackOverFlowError</p>
<blockquote>
<p>最常见的就是无限递归</p>
</blockquote>
<p>如果栈的大小动态，那么可能进行入栈操作是跟内存要空间，结果内存没了，导致异常 抛出 OutOfMemoryError</p>
<h1 id="2-栈帧概述"><a href="#2-栈帧概述" class="headerlink" title="2. 栈帧概述"></a>2. 栈帧概述</h1><p>何为栈帧，我们上面说，把一个方法的调用理解成栈帧，一个方法在JVM中执行，就是虚拟机栈中压入了这个方法对应的栈帧，方法执行完成后，这个栈帧就会弹栈。同时为了保证方法执行的正确性以及其他的一些什么乱七八糟的东西，栈帧内部还有很多的其他组成部分，我们下面会详细说。</p>
<h2 id="2-1-栈帧的注意事项"><a href="#2-1-栈帧的注意事项" class="headerlink" title="2.1 栈帧的注意事项"></a>2.1 栈帧的注意事项</h2><ul>
<li><p>不同线程之间的栈帧不能相互引用</p>
</li>
<li><p>如果方法调用了其他返回，在方法返回时，当前栈帧会传给前一栈帧执行结果，当前栈帧出栈，让上一个栈帧变为当前。</p>
</li>
<li><p>java中有两个方式返回方法，return 和 throw(没有处理)，两种办法都会弹出栈帧。</p>
</li>
</ul>
<h2 id="2-2-栈帧的具体结构"><a href="#2-2-栈帧的具体结构" class="headerlink" title="2.2 栈帧的具体结构"></a>2.2 栈帧的具体结构</h2><p>分为5部分：</p>
<ul>
<li><p>局部变量表</p>
</li>
<li><p>操作数栈&#x2F;表达式栈</p>
</li>
<li><p>动态链接&#x2F;指向运行时常量池的方法引用</p>
</li>
<li><p>方法返回地址</p>
</li>
<li><p>附加信息</p>
</li>
</ul>
<p>下面我们就会进入这5个部分，详细说说栈帧里面都是些什么鬼。</p>
<h1 id="3-局部变量表"><a href="#3-局部变量表" class="headerlink" title="3. 局部变量表"></a>3. 局部变量表</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ul>
<li><p>也叫本地变量表：</p>
</li>
<li><p>定义一个数字数组，用于存储方法参数，和定义在方法内的局部变量，这些数据类型包括 8种基本数据类型，引用，和返回值类型。</p>
</li>
<li><p>一个线程配套一个虚拟机栈，所以不存在线程安全问题。</p>
</li>
<li><p>这个表的长度一开始就已经固定，且不会发生改变，因为在编译的时候编译器就已经解析出来你这个方法需要多少个临时变量了，表长存在一个 maximum local variables 属性里面。 可以反编译一个class文件找找，code 里面的 locals 也记录了。</p>
</li>
<li><p>只在当前方法中有效，别人想用就得传参了，方法调用结束变量表随之销毁。</p>
</li>
<li><p>方法嵌套次数由虚拟机栈决定，一般来说，栈越大，嵌套越多，如果一个方法的本地数据过多， 会导致栈帧过大，进而占用虚拟机栈的空间变多，导致方法嵌套次数变少。</p>
</li>
</ul>
<p>我们解析一个 class文件，就能在方法里面找到 LocalVariableTable， slot 代表了第几个本地变量，然后 length不解释，signature 就是数据类型， 同时，code 里面的 locals 也记录了 变量表的最大长度。</p>
<h2 id="3-2-解析Class中的方法"><a href="#3-2-解析Class中的方法" class="headerlink" title="3.2 解析Class中的方法"></a>3.2 解析Class中的方法</h2><p>我们解析一个 class文件以后，不说 javap 解析了，就说 jclasslib 解析以后得到的东西。首先我们解析完成后，随便进入一个方法，这里我就以main方法为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: cp_info #30 &lt;main&gt;  </span><br><span class="line">descriptor: cp_info #31 &lt;([Ljava/lang/String:V)&gt;  </span><br><span class="line">Access flags: 0x0009 [public static]</span><br></pre></td></tr></table></figure>

<p>name 就是方法名，告诉你是 main 方法，descriptor 描述，包括 参数类型：LJava…String,L 代表引用，V 代表void 无返回值。Access flags 访问表示，告诉你是 public static。</p>
<p>然后，我们进入 code，byteCode 就是字节码指令, ExceptionTable 就是异常表，没有异常，空。misc 里面就是一些描述，比如 本地变量表的最大长度，还有指令长度，字节码指令0 - 最后那个号。</p>
<p>然后code 里面还有一个 LineNumberTable,里面记录Java 代码和 字节码指令的行号映射关系，lineNumber 表示 Java 行数，startPC 代表字节码指令行数，两个上述一一对应。</p>
<p>LineNumberTable如下：</p>
<p><img src="/images/runtime/line_number_table.png" alt="line_number_table"></p>
<p>然后重点看看本地变量表，局部变量表如下：</p>
<p><img src="/images/runtime/local_var_table.png" alt="local_var_table"></p>
<p>你方法里面有几个局部变量，他就有几行+1，几个字段+1(一般情况是，为啥？实例方法局部变量表中的第一位是 this)：</p>
<ul>
<li><p>name名字： 想必是局部变量的名称</p>
</li>
<li><p>descriptor 描述符： 就是类型，同理L是引用，</p>
</li>
<li><p>startPC起始PC： 是你这个局部变量的作用域的起始位置，是一个 字节码行号， 根据 lineNumber 表找到对应java 的行数，其实就是你java声明了这个局部变量的下一行。</p>
</li>
<li><p>index 序号： 就是索引</p>
</li>
<li><p>length长度： 不是说你这个变量多长，而是作用域长度，结合上面的 startPC， 比如 misc 里面记录的字节码长度是16，就代表你总共有16条指令， 然后已定义了一个变量，从 字节码的 第8行开始，然后到第15(0开始)失效， 那么你的这个 length 就是 8，从第8行开始，在往后的8行内生效。</p>
</li>
</ul>
<h2 id="3-3-槽-Slot"><a href="#3-3-槽-Slot" class="headerlink" title="3.3 槽 Slot"></a>3.3 槽 Slot</h2><p>本地变量表中，会将数据存放到 槽中。</p>
<ul>
<li><p>JVM 会给每一个 slot 分配一个索引，根据这个索引可以访问到局部变量表中的局部变量值。</p>
</li>
<li><p>当一个实例方法被调用时，他的方法参数和局部变量会按顺序复制到每一个 slot 上。</p>
</li>
<li><p>32 bit 的数据占用一个 slot，64bit 的占用两个，64的只有 long 和 double，包括引用都是 32bit的。</p>
</li>
<li><p>如果要访问一个 64bit的数据，只需要访问这个数据的第一个slot的索引即可。</p>
</li>
<li><p>如果当前栈帧被构造方法或者实例方法创建，则 对象 this 会被存到 index 位 0 的栈帧上，其余的按顺序。</p>
</li>
</ul>
<h2 id="3-4-静态变量和局部变量的对比"><a href="#3-4-静态变量和局部变量的对比" class="headerlink" title="3.4 静态变量和局部变量的对比"></a>3.4 静态变量和局部变量的对比</h2><ul>
<li><p>局部变量表初始化完以后，才会按顺序定义局部变量的空间</p>
</li>
<li><p>静态变量有两次机会赋值，第一次是链接阶段的准备阶段，讲静态变量初始化位零值，第二次是 初始化阶段，赋值为我们定义的值。</p>
</li>
<li><p>局部变量没有初始化，他必须我们自己定义初始值，否则不能用。</p>
</li>
</ul>
<h2 id="3-5-补充说明"><a href="#3-5-补充说明" class="headerlink" title="3.5 补充说明"></a>3.5 补充说明</h2><ul>
<li><p>这部分和GC有很大联系的就是局部变量表，方法执行时，通过这东西完成参数传递。</p>
</li>
<li><p>局部变量表中的变量也是GC中重要的根节点，只要是被局部变量表中直接或间接引用的对象都不会被回收。</p>
</li>
</ul>
<h1 id="4-操作数栈"><a href="#4-操作数栈" class="headerlink" title="4. 操作数栈"></a>4. 操作数栈</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>操作数栈，字面意思，就是用于方法内代码执行做运算的。细节如下：</p>
<ul>
<li><p>每一个栈帧除了局部变量表外，还有操作数栈，后进先出。</p>
</li>
<li><p>根据指令的不同，进行 push 和 pop 的操作，也只能进行这两个操作</p>
<ul>
<li><p>某些字节码指令让操作数入栈，然后其他的指令让操作数出栈求和，再重新入栈。</p>
</li>
<li><p>比如 赋值 求和 交换等操作。</p>
</li>
</ul>
</li>
<li><p>主要用于保存计算的中间结果，同时作为计算过程中变量临时的存储空间</p>
</li>
<li><p>操作数栈就是JVM执行引擎的一个工作区，随着方法执行被创建，刚创建时是空的(空 !&#x3D; 没创建)</p>
</li>
<li><p>每个操作数栈都有一个明确的深度来进行存储，也是在编译的时候就已经定义好的， 在code 里面的 max_stack 里面定义，或者 javap 里面 方法的stack 参数</p>
</li>
<li><p>栈里面的每一个元素都可以是任意java类型，32bit的数据占1个栈深度，64bit占2个站深度。</p>
</li>
<li><p>如果被调用的方法有返回值，那么返回值也会入栈，同时PC寄存器更新下一条指令。</p>
</li>
<li><p>栈里面的元素和字节码指令的数据类型必须严格匹配，编译器在编译期间会进行验证。</p>
</li>
<li><p>我们所说的 Java解释引擎是基于栈的，这里的栈 就是 操作数栈。</p>
</li>
</ul>
<h2 id="4-2-具体流程分析"><a href="#4-2-具体流程分析" class="headerlink" title="4.2 具体流程分析"></a>4.2 具体流程分析</h2><p>我们找一段代码来具体分析分析操作数栈到底是干啥的，直接看图：</p>
<p><img src="/images/runtime/operateStack.png" alt="ops_stack"></p>
<p>我们逐条看指令，</p>
<ol>
<li><p>首先进行了 bipush 操作，push 15，将 15 存入操作数栈</p>
</li>
<li><p>执行 istore_1 也就是弹栈得到15后存入局部变量表的1位置(复习一下，0位置存this)</p>
</li>
<li><p>bipush 8，将8存入操作数栈</p>
</li>
<li><p>执行 istore_2 弹栈得8 存入 局部变量表的 2位置</p>
</li>
<li><p>iload_1 这里读取 表中1位置的数据，放入 操作数栈 进行入栈操作</p>
</li>
<li><p>iload_2 读取 表中2位置的数据，入栈</p>
</li>
<li><p>iadd 将两个操作数弹栈，相加，得到结果重新入栈</p>
</li>
<li><p>istore_3 将得到的数据 存储到 局部变量表 3 位置</p>
</li>
<li><p>返回</p>
</li>
</ol>
<p>在这个过程中，这个栈只需要 2 深度，所以可以看到，code 里面的 stack &#x3D;&#x3D; 2.</p>
<p>顺带说一句，这里我们可以看到什么 bipush，sipush，意思就是：b(yte) -&gt; i(nt) 和 s(hort) -&gt; i(nt)</p>
<p>有一种特殊的情况，方法 A return int，然后 方法B 里面调用 A 并用i接收返回值。</p>
<p>首先在方法A里面最后会进行 ireturn，也就是把返回值结果返回，然后在B方法里面，在 调用A方法接受参数的位置，会进行 aload_0他会得到返回值并入栈。</p>
<h1 id="5-动态链接"><a href="#5-动态链接" class="headerlink" title="5. 动态链接"></a>5. 动态链接</h1><blockquote>
<p>或者叫 指向运行时常量池的方法引用</p>
</blockquote>
<p>先说一下符号链接</p>
<ul>
<li>java源文件被编译到class文件里面的时候，所有的变量和方法引用都作为符号引用保存在class常量池中</li>
</ul>
<p>这话简直不是人话，我来给翻译一下：</p>
<p>我们先解析一个class文件，这个原本的Java文件里面有个a方法和b方法，b方法里面调用了a，所以字节码里面方法B有这么一句：</p>
<p><code>1: invokevirtual #6 // Method methodA:()V</code></p>
<p>这就意思是调用了 方法#6，当然注释告诉我其实就是 methodA，然后我们去常量池 里面找 #6 是个啥，然后找半天，不停地指向别的符号，最后指向了 methodA 和 ()V，methodA 就是方法名，()V 就是无参，返回 void 磨磨唧唧不停地指向别的东西。</p>
<p>同时，体现出，所有的东西，都存在常量池中，比如我们输出的 String，也存在 常量池中。</p>
<p>所以：</p>
<p>运行时，将常量池加载到方法区内形成运行时常量池，然后每个栈帧都包含一个 指向运行时常量池中 该栈帧所属方法的引用，那么这个引用，就是动态链接，可以支持该方法实现动态链接。</p>
<p>下面解释一下啥是常量池：</p>
<blockquote>
<p>说的还是不是人话，我这里再解释一下：我们解析一个Class文件会发现里面有个constant pool常量池，这里面包含什么？字符串字面值，各种需要用到的类等等等等。然后下面的代码比如 String st &#x3D; “123”，这个123就会存到常量池中，并不会直接在代码中体现。</p>
<p>JVM读取class的时候，就会去读这个常量池，也就是可以提前知道这个类里面要用到哪些其他的类，以及有用到哪些常量值，然后JVM就会把这个常量池读到运行时数据区，比如常量池中有 System.out 这个类，JVM就会提前把这个类加载到方法区中。总而言之，JVM会读取常量池从而形成运行时常量池。</p>
<p>然后，class文件中，代码会指向常量池中的某些元素，比如 invokevirtual #6，就是指向了#6常量，但是JVM读了以后你不能还指向#6了，因为已经有了运行时常量池，常量池中的元素已经有了具体的内存体现了，那你还指向#6干啥，这时就会让代码直接指向运行时常量池。这一步，也就对应了类加载中的 链接-解析 阶段。</p>
</blockquote>
<p>既然知道了啥是常量池，那么我们再看看这个动态链接，其实就很好理解了，字节码文件中，方法名，方法返回值，方法入参类型，这些都是存在常量池中的东西。那么栈帧应该知道自己这个方法对应到运行时常量池中的是哪个，动态链接就是干这个的。</p>
<h2 id="为何需要常量池"><a href="#为何需要常量池" class="headerlink" title="为何需要常量池"></a>为何需要常量池</h2><p>我们加载一个类，比如我们就写一个类里面有一个主方法，就一个输出，他加载到内存里面就需要加载 比如 父类Object，各种数据类型，System对象，PrintWriter对象，等等。</p>
<p>如果这些东西全都存在 class里面，就很浪费，所以弄一个常量池，把常用的东西放进去，需要的时候直接引用过来就行了。</p>
<h1 id="6-方法调用"><a href="#6-方法调用" class="headerlink" title="6. 方法调用"></a>6. 方法调用</h1><blockquote>
<p>从 JVM 角度看java 方法如何被调用</p>
</blockquote>
<p>上面刚说过，在类加载的时候，会把符号引用转化为直接引用，而这个转化过程是在编译期间完成的还是在运行期间完成的，这个还是有区别的。</p>
<h2 id="6-1-静态链接"><a href="#6-1-静态链接" class="headerlink" title="6.1 静态链接"></a>6.1 静态链接</h2><p>一个字节码文件被加载到 JVM 内部时，如果被调用的目标方法在编译期间可知，且运行期间保持不变，那么这个时候 符号 -&gt; 直接 的转化，就叫静态链接。</p>
<blockquote>
<p>简单说，编译期间转化，就叫静态链接</p>
</blockquote>
<h2 id="6-2-动态链接"><a href="#6-2-动态链接" class="headerlink" title="6.2 动态链接"></a>6.2 动态链接</h2><p>对应的，如果在编译期间无法确定，比如接口回调，需要在运行时转换，则成为动态链接。</p>
<blockquote>
<p>同理，运行期间绑定，动态链接</p>
</blockquote>
<h2 id="6-3-绑定"><a href="#6-3-绑定" class="headerlink" title="6.3 绑定"></a>6.3 绑定</h2><p>什么叫绑定？一个字段，方法，类的符号引用替换成直接引用的过程，只发生一次。同时这里还区分早期绑定和晚期绑定：</p>
<ul>
<li><p>早期绑定：对应静态链接，目标方法在编译期间可知且运行时不变，可以明确被调用的方法是哪一个，使用静态链接的方式进行符号到直接的转化，叫早期绑定</p>
</li>
<li><p>晚期绑定：不确定目标方法，使用动态链接进行转换，就叫晚期绑定</p>
</li>
</ul>
<h2 id="6-4-虚方法和非虚方法"><a href="#6-4-虚方法和非虚方法" class="headerlink" title="6.4 虚方法和非虚方法"></a>6.4 虚方法和非虚方法</h2><p>非虚方法对应 静态链接和早期绑定，在编译期间就确定方法的具体版本。如下都属于非虚方法：</p>
<ul>
<li><p>静态方法</p>
</li>
<li><p>私有方法</p>
</li>
<li><p>final 修饰的方法</p>
</li>
<li><p>实例构造器</p>
</li>
<li><p>父类方法</p>
</li>
</ul>
<p>其他的都属于虚方法。</p>
<h2 id="6-5-虚拟机中调用方法的指令"><a href="#6-5-虚拟机中调用方法的指令" class="headerlink" title="6.5 虚拟机中调用方法的指令"></a>6.5 虚拟机中调用方法的指令</h2><h3 id="6-5-1-调用指令"><a href="#6-5-1-调用指令" class="headerlink" title="6.5.1 调用指令"></a>6.5.1 调用指令</h3><ul>
<li><p>invokeStatic 调用非虚方法</p>
</li>
<li><p>invokeSpecial 调用 <init> 构造方法，私有方法，父类方法</p>
</li>
</ul>
<p>前面两个都属于调用非虚方法</p>
<ul>
<li><p>invokeVirtual 调用虚方法</p>
<blockquote>
<p>但是不代表 invokeVirtual 调用的都是虚方法，特别的，调用final方法，也是 invokeVirtual</p>
</blockquote>
</li>
<li><p>invokeInterface 调用接口方法</p>
</li>
</ul>
<p>还有一个特殊的，调用Lambda 的指令</p>
<ul>
<li>invokeDynamic</li>
</ul>
<p>java7 开始才引入了 invokeDynamic 这个东西，为了体现 java 的 动态类型语言特性。但是 java7 没法直接生成 invokeDynamic 指令，知道 java8 出现了 lambda 表达式，java8 才能直接生成 invokeDynamic 指令。</p>
<h3 id="6-5-2-动态类型语言-和-静态类型语言"><a href="#6-5-2-动态类型语言-和-静态类型语言" class="headerlink" title="6.5.2 动态类型语言 和 静态类型语言"></a>6.5.2 动态类型语言 和 静态类型语言</h3><p>简单说，静态类型语言在编译期间会对数据类型进行检查，动态类型语言会在运行时进行类型检查，变量本身没有类型，变量值才有类型。</p>
<h1 id="7-方法返回值地址"><a href="#7-方法返回值地址" class="headerlink" title="7. 方法返回值地址"></a>7. 方法返回值地址</h1><p>所谓 方法返回值地址，这里我给举个例子：</p>
<p>我们调用 方法 A，方法 A 里面我们有调用了 方法 B，在虚拟机栈的角度，A 入栈，然后B入栈，现在，方法 B 执行完成，那么就需要回到 方法 A 中 调用 B 的那个地方，继续往下执行，方法 B 的返回值，需要给到 方法 A 调用 B 的那一行代码，这就需要方法返回值地址</p>
<p>方法返回值地址里面存储了 PC寄存器中的值，也就是记录了调用方法的位置的下一行代码，然后方法执行完成，将返回值放入操作数栈，然后根据方法返回值地址，回到方法调用的位置，继续执行。</p>
<h2 id="7-1-方法退出的两种情况"><a href="#7-1-方法退出的两种情况" class="headerlink" title="7.1 方法退出的两种情况"></a>7.1 方法退出的两种情况</h2><ul>
<li><p>正常退出，调用者 PC寄存器的值作为返回地址，调用该方法指令的下一条指令地址。</p>
</li>
<li><p>出现未处理异常，非正常退出，返回地址需要异常表来确定，栈帧不保存这部分信息</p>
</li>
</ul>
<p>所以，方法返回值地址仅针对方法正常推退出的情况。</p>
<h2 id="7-2-返回指令："><a href="#7-2-返回指令：" class="headerlink" title="7.2 返回指令："></a>7.2 返回指令：</h2><p>函数返回指令如下：</p>
<ul>
<li><p>ireturn -&gt; intReturn 返回 byte short int boolean char</p>
</li>
<li><p>lreturn -&gt; longReturn 返回 long</p>
</li>
<li><p>freturn -&gt; floatReturn 返回 float</p>
</li>
<li><p>dreturn -&gt; doubleReturn 返回 double</p>
</li>
<li><p>areturn -&gt; 不知道 返回 引用</p>
</li>
<li><p>return -&gt; void 方法无返回值</p>
</li>
</ul>
<h2 id="7-3-异常表"><a href="#7-3-异常表" class="headerlink" title="7.3 异常表"></a>7.3 异常表</h2><p>如果方法存在异常，则会有一个异常表进行处理，在方法里面，需要 javap</p>
<p>结构如下：</p>
<table>
<thead>
<tr>
<th>from</th>
<th>to</th>
<th>target</th>
<th>type</th>
</tr>
</thead>
<tbody><tr>
<td>6</td>
<td>8</td>
<td>11</td>
<td>java&#x2F;io&#x2F;IOException</td>
</tr>
</tbody></table>
<p>意思如下：</p>
<p>从 6 到 8 行 如果出现异常IOException，交给 11 处理，其实也就是 try catch 代码块里面的东西。</p>
<h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p>很好，栈总算是说完了。下面就是牛逼的堆了。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-方法区</title>
    <url>/2022/05/30/jvm-methodarea/</url>
    <content><![CDATA[<p>JVM方法区，主要用于储存各种类的元信息，也就是我们常说的Class类摸版，这里详细说一下方法区的内存分布和垃圾回收问题。同时这里也不会只讲方法区，因为讲完方法区以后我们就可以深入的去研究一个对象是如何被创建的，所以后面还会和堆空间结合起来说。</p>
<span id="more"></span>

<h1 id="1-方法区"><a href="#1-方法区" class="headerlink" title="1. 方法区"></a>1. 方法区</h1><h2 id="1-1-明确几个概念"><a href="#1-1-明确几个概念" class="headerlink" title="1.1 明确几个概念"></a>1.1 明确几个概念</h2><ul>
<li><p>方法区虽然之前说过算是 堆的一部分，但是一般情况下是要分开的。</p>
</li>
<li><p>方法去看作是JVM独立的一部分。</p>
</li>
<li><p>HotSpot 虚拟机的方法区还有一个别名：Non-Heap 非堆。</p>
</li>
<li><p>方法区会自己收缩扩大</p>
</li>
</ul>
<h2 id="1-2-方法区的基本理解"><a href="#1-2-方法区的基本理解" class="headerlink" title="1.2 方法区的基本理解"></a>1.2 方法区的基本理解</h2><ul>
<li><p>方法区和堆类似，都是线程共享的。</p>
</li>
<li><p>方法区在JVM启动时被创建，和heap一样他的物理内存可以不连续。</p>
</li>
<li><p>方法区的大小和heap一样，可固定 可 伸缩</p>
</li>
<li><p>方法区的大小决定了系统能加载多少个类，如果类过于多，也会抛出 OutOfMemoryError</p>
<ul>
<li>比如加载过多 jar 包，或者 tomcat部署过多服务，比如 30 - 50 个。</li>
</ul>
</li>
<li><p>关闭JVM会释放这部分内存。</p>
</li>
</ul>
<h2 id="1-3-HotSpot-虚拟机-方法区演进"><a href="#1-3-HotSpot-虚拟机-方法区演进" class="headerlink" title="1.3 HotSpot 虚拟机 方法区演进"></a>1.3 HotSpot 虚拟机 方法区演进</h2><ul>
<li><p>JDK7 中，将方法区称为永久代，JDK8以后用元空间取代了永久代</p>
<blockquote>
<p>JVM虚拟机规范中说：将类的原信息存储到本地堆中，这块区域称为元空间</p>
</blockquote>
</li>
<li><p>确切来说永久代和方法区并不等价，仅针对 HotSpot 虚拟机而言，他并没有规定如何实现方法区。</p>
</li>
<li><p>可以这么理解，方法区就是一个接口，永久代和元空间用于存储类的原信息，是方法区的实现。</p>
</li>
</ul>
<h2 id="1-4-hotSpot-设置-方法区大小"><a href="#1-4-hotSpot-设置-方法区大小" class="headerlink" title="1.4 hotSpot 设置 方法区大小"></a>1.4 hotSpot 设置 方法区大小</h2><ul>
<li><p>JDK7 之前：</p>
<ul>
<li><p>-XX:PermSize&#x3D;100m 设置初始大小 默认 20.75m</p>
</li>
<li><p>-XX:MaxPermSize&#x3D;200m 设置最大值 默认 32位机器 64m，64位机器 86m</p>
</li>
</ul>
</li>
<li><p>JDK8 以后：</p>
<ul>
<li><p>-XX:MetaspaceSize&#x3D;100m 设置初始大小 默认 21m</p>
</li>
<li><p>-XX:MaxMetaspaceSize&#x3D;200m 设置最大值 默认没有最大，最大就是你的真实内存</p>
</li>
</ul>
</li>
</ul>
<p>二者的区别：</p>
<ul>
<li><p>元空间和永久代不同，元空间会耗尽你所有的内存，直到你的内存崩了，他会给你抛出 OOM异常。</p>
</li>
<li><p>-XX:MetaspaceSize 设置初始大小。对于一个64位的机器来说，默认是21m空间，那么这个21m就是一个高水位线，一旦元空间的东西超过了21m，就会触发FullGC来清理不用的类(类加载器死亡了)，然后这个高水位线会重置。如果清理的不多，同时在最大空间以内，他就会稍微提高这个高水位线，如果清理的过多，就会降低这个高水位线。</p>
</li>
<li><p>根据上面所说的，如果初始值比较低，那么就会频繁触发 FullGC，为了提高性能，建议吧这个初始值调高。</p>
</li>
</ul>
<h1 id="2-方法区内部结构"><a href="#2-方法区内部结构" class="headerlink" title="2. 方法区内部结构"></a>2. 方法区内部结构</h1><h2 id="2-1-方法区主要存储对象"><a href="#2-1-方法区主要存储对象" class="headerlink" title="2.1 方法区主要存储对象"></a>2.1 方法区主要存储对象</h2><ul>
<li><p>类型信息</p>
<ul>
<li><p>全限定命名</p>
</li>
<li><p>直接父类的全限定命名</p>
</li>
<li><p>类的访问修饰符</p>
</li>
<li><p>实现的直接接口的有序列表</p>
</li>
</ul>
</li>
<li><p>域信息(Field 其实就是字段，或者属性):</p>
<ul>
<li><p>JVM必须在方法去中保存所有字段的相关信息和声明顺序</p>
</li>
<li><p>域的相关信息包括：名称 类型 访问修饰符</p>
</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li><p>JVM必须在方法去中保存下面的信息，同时也会保存声明顺序：</p>
</li>
<li><p>方法名称</p>
</li>
<li><p>方法返回值类型</p>
</li>
<li><p>参数的数量与类型(按顺序)</p>
</li>
<li><p>访问修饰符</p>
</li>
<li><p>方法的字节码 操作数栈 局部变量表及大小(abstract native 方法除外)</p>
</li>
<li><p>异常表(abstract native 除外)</p>
<ul>
<li>包括 每个异常处理的开始位置，结束位置，代码处理在PC寄存器中的偏移地址，被捕获的异常类的常量池索引</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-全局常量"><a href="#2-2-全局常量" class="headerlink" title="2.2 全局常量"></a>2.2 全局常量</h2><p>就是 static final，用 final 修饰的 static 成员。</p>
<p>这个东西在编译的时候就已经为他分配了值。直接反编译，就可以看到.</p>
<h1 id="3-常量池-和-运行时常量池"><a href="#3-常量池-和-运行时常量池" class="headerlink" title="3. 常量池 和 运行时常量池"></a>3. 常量池 和 运行时常量池</h1><p>一个有效的字节码文件里面包含了类的信息 字段 方法 接口等，以外，还包括一个东西，就是常量池：Constant Pool。常量池里面包括：字面量 类型，字段，方法的引用。</p>
<p>看图： </p>
<p><img src="/images/runtime/ConstantPool.png" alt="method_area"></p>
<p>这图领会精神，因为我也看不懂.</p>
<h2 id="3-1-为什么引入-常量池"><a href="#3-1-为什么引入-常量池" class="headerlink" title="3.1 为什么引入 常量池"></a>3.1 为什么引入 常量池</h2><p>Java 一个类编译后生成字节码文件。而Java字节码通常需要数据支持，而这些数据大到无法存到 字节码文件中，所以引入常量池，在动态链接阶段 会用到运行时常量池。</p>
<p>比如我们写一个最简单的HelloWorld 程序，这个程序就用到了 Object,System,PrintStream等一系列的类。这些类很显然不能全都装在字节码里面，所以就以常量池的形式存储。</p>
<p>比如我们随便反编译一个类，得到 Constant Pool，都是一大堆 #… 这种东西，然后我们跟着他的 # 一路往下追，才能找到他到底是个啥。</p>
<h2 id="3-2-常量池里面都存啥？"><a href="#3-2-常量池里面都存啥？" class="headerlink" title="3.2 常量池里面都存啥？"></a>3.2 常量池里面都存啥？</h2><ul>
<li><p>数量值</p>
</li>
<li><p>字符串值</p>
</li>
<li><p>类引用</p>
</li>
<li><p>字段引用</p>
</li>
<li><p>方法引用</p>
</li>
</ul>
<p>举个例子：</p>
<p><code>Object object = new Object();</code></p>
<p>他在 字节码中会被表示成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0:new #2</span><br><span class="line">1:dup </span><br><span class="line">2:invokespecial #3</span><br></pre></td></tr></table></figure>

<p>这里的#2 和#3就是常量池中的东西，new 后面这个#2，指向的就是常量池中用于表示Object这个类的字符串常量，注意是字符串常量，#3 就指向了常量池的Object的<init>O 方法，然后在类加载的链接阶段就会将这些字符串常量转化为运行时常量池，然后#2也会指向真实的内存地址。</p>
<p>总的来说：常量池就可以理解成一张表，JVM根据这张表，去找到要执行的类名 方法 参数 字面量等。</p>
<h2 id="3-3-运行时常量池"><a href="#3-3-运行时常量池" class="headerlink" title="3.3 运行时常量池"></a>3.3 运行时常量池</h2><p>这里明确一下，运行时常量池和字节码中的常量池表不一样。</p>
<ul>
<li><p>运行时常量池 是 方法区的一部分</p>
</li>
<li><p>常量池表是字节码文件的一部分，用于存储编译期生成的各种字面量和引用，这部分内容将在类加载后放到方法区的运行时常量池中。</p>
</li>
<li><p>加载类和接口到虚拟机后就会生成对应的运行时常量池</p>
</li>
<li><p>JVM为每一个已经加载的类型(类或者接口)都维护一个运行时常量池，池中的数据向数组像一样，可以通过索引访问。</p>
</li>
<li><p>运行时常量池中包含多种不同的常量，包括编译期间就已经明确的字面量，也包括运行时解析后才能得到的方法或字段引用，此时已经不再是常量池那种符号地址了，而是真实地址</p>
</li>
<li><p>运行时常量池对比常量池的一个特点：具备动态性</p>
</li>
<li><p>运行时常量池类似其他语言的符号表，但是内容更丰富。</p>
</li>
<li><p>在构造类型的运行时常量池的时候，如果方法区的空间不够了，就会抛出 OutOfMemoryError</p>
</li>
</ul>
<h1 id="4-JVM方法区的演进"><a href="#4-JVM方法区的演进" class="headerlink" title="4. JVM方法区的演进"></a>4. JVM方法区的演进</h1><ul>
<li><p>首先 HotSpot 虚拟机才有永久代</p>
</li>
<li><p>HotSpot虚拟机的演进：</p>
<ul>
<li><p>JDK6以前，有永久代，静态变量存放在永久代上</p>
</li>
<li><p>JDK7还有永久代，但是 字符串常量池，静态变量从永久代移除，放到了堆上</p>
</li>
<li><p>JDK8以后，取消永久代，而是元空间，类型信息 字段 方法 常量保存在元空间，但是 静态变量和字符串常量池还在堆上。</p>
</li>
</ul>
</li>
<li><p>以前有永久代的时候，所有内存都放在JVM的内存上，到了元空间，变成了本地内存。</p>
</li>
</ul>
<h2 id="4-1元空间为何要取代永久代"><a href="#4-1元空间为何要取代永久代" class="headerlink" title="4.1元空间为何要取代永久代"></a>4.1元空间为何要取代永久代</h2><ul>
<li><p>JDK8以后，永久代没了，原先存在永久代中的数据被存到了一个和堆不连续的本地内存上， 这块地方就是元空间。</p>
</li>
<li><p>因为类的元数据放在本地内存，所以元空间的上线就是真实内存max</p>
</li>
</ul>
<h2 id="4-2-好处"><a href="#4-2-好处" class="headerlink" title="4.2 好处"></a>4.2 好处</h2><ul>
<li><p>方法区的大小很难确定，如果功能过多，加载的雷多，很可能出现OOM错误。</p>
</li>
<li><p>对永久代调优很困难，就是 FullGC，去判断哪些是垃圾特别麻烦，所以 尽量少去GC，就需要更大的方法区空间。</p>
</li>
</ul>
<h2 id="4-3-StringTable-调整"><a href="#4-3-StringTable-调整" class="headerlink" title="4.3 StringTable 调整"></a>4.3 StringTable 调整</h2><p>首先说一下啥是StringTable，StringTable 就是字符串常量池，JVM中有一个专门储存字符串的地方，因为字符串大量使用，所以干脆给你做成一个单独的常量池。这个东西在后面我们说到字符串的时候还会详细说，这里先了解一下。</p>
<p>JDK7以前，StringTable在永久代，而JDK7以后，把StringTable扔到了堆中，为哈？</p>
<p>如果放在方法区，那就会涉及FullGC，而FullGC只有在永久代满了的时候才会触发， GC不频繁，而StringTable 经常用，看法中大量的String被创建，所以放在永久代里面 效率底下，所以放在堆中。</p>
<h2 id="4-4-静态成员放在哪里"><a href="#4-4-静态成员放在哪里" class="headerlink" title="4.4 静态成员放在哪里"></a>4.4 静态成员放在哪里</h2><p>就是说我们有一个静态成员，比如 <code>private static UserUtils uu = new UserUtils();</code> ，那么这个UserUtils 到底在哪？</p>
<p>明确一下，只要是new出来的东西，就肯定是放在堆中的，没有例外。不同的是这个 static uu 放到哪了。</p>
<p>JDK7 以后，这个引用也会放在堆中，而JDK6以前，这个引用同样放在方法区。</p>
<h1 id="5-元空间GC"><a href="#5-元空间GC" class="headerlink" title="5. 元空间GC"></a>5. 元空间GC</h1><blockquote>
<p>方法区的具体实现部分可以不涉及GC ——Java虚拟机规范</p>
</blockquote>
<p>首先明确，方法去中有GC，但是方法区的GC很难让人满意。</p>
<p>方法区的垃圾回收主要回收常量池和类型信息。</p>
<h2 id="如何垃圾回收"><a href="#如何垃圾回收" class="headerlink" title="如何垃圾回收"></a>如何垃圾回收</h2><ul>
<li><p>常量相对简单，然而他没讲</p>
</li>
<li><p>如何判断类型不再使用：</p>
<ul>
<li><p>该类的所有对象都被回收，且不存在子类对象</p>
</li>
<li><p>加载该类的类加载器被回收，这个除非是精心设计的可以可替换类加载的场景，比如 JSP OSGI 等，否则很难达成。</p>
</li>
<li><p>类的Class 在任何地方都没有被引用，任何地方都不能通过反射区访问这个类。</p>
</li>
</ul>
</li>
<li><p>Java 虚拟机只有满足了上述三个条件才会允许回收这个类，但也仅仅是允许， 并不是说就想对象一样，一定可以被回收。</p>
</li>
<li><p>在大量使用反射 动态代理 CGlib等字节码框架，动态生成</p>
</li>
</ul>
<p>这里只是大致说一句GC，GC后面会专门说的。</p>
<h1 id="6-创建对象流程"><a href="#6-创建对象流程" class="headerlink" title="6. 创建对象流程"></a>6. 创建对象流程</h1><p>学了方法区，我们就得详细说说一个对象是如何被创建的了，这里就会把方法区和堆空间结合起来说了。所以这部分内容比较综合。</p>
<h2 id="6-1-创建方式"><a href="#6-1-创建方式" class="headerlink" title="6.1 创建方式"></a>6.1 创建方式</h2><p>首先，创建对象的方式：</p>
<ul>
<li><p>new 对象</p>
<blockquote>
<p>包括单例设计模式里面的 getInstance 那种在内部调用 new 的</p>
</blockquote>
</li>
<li><p>Class.newInstance() 反射创建对象</p>
<blockquote>
<p>条件比较苛刻，首先必须有无参构造，其次构造函数必须是 public</p>
</blockquote>
</li>
<li><p>Constructor的 newInstance(args) 调用构造函数</p>
<blockquote>
<p>可以调用任意构造函数，不用担心权限</p>
</blockquote>
</li>
<li><p>Clone，需要类 实现 Cloneable 接口，实现 clone 方法</p>
</li>
<li><p>反序列化，通过 ObjectSteam</p>
</li>
<li><p>第三方库 Objenesis</p>
</li>
</ul>
<h2 id="6-2-字节码角度看对象创建"><a href="#6-2-字节码角度看对象创建" class="headerlink" title="6.2 字节码角度看对象创建"></a>6.2 字节码角度看对象创建</h2><p>我们写一个代码，main 方法里面仅仅创建一个 Object 对象，然后反编译，看看 得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: new           #2   // class java/lang/Object  </span><br><span class="line">3: dup  </span><br><span class="line">4: invokespecial #1   // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V  </span><br><span class="line">7: astore_1  </span><br><span class="line">8: return</span><br></pre></td></tr></table></figure>

<p>首先我们看第一条指令 new，它里面涉及到的东西：</p>
<ul>
<li><p>加载 Object，将 Object 放到方法区，当然这个过程可能早就做了</p>
</li>
<li><p>在堆中给Object 分配空间，此时内存占用大小已经可以通过数据类型确定下来了，然后 给成员变量进行初始化，给他一个初值。</p>
</li>
</ul>
<p>第二步 dump 复制操作：</p>
<ul>
<li>因为这个对象在 main 方法中执行，所以引用在操作数栈里面， 然后他吧引用复制了一份，一份用来赋值，一个用来调用方法。</li>
</ul>
<blockquote>
<p>为啥是在操作数栈？因为此时对象还没有创建完，创建完之后 指令 7 才会存储到 局部变量表中。</p>
</blockquote>
<p>第三步 invokespecial 调用 <init> 方法，也就是构造函数。</p>
<p>第四步 astore 将对象存储到 局表。</p>
<h2 id="6-3-具体的创建流程"><a href="#6-3-具体的创建流程" class="headerlink" title="6.3 具体的创建流程"></a>6.3 具体的创建流程</h2><p>一个对象创建出来，new 出来，大致需要经历六个步骤：</p>
<h3 id="6-3-1-判断对象对应的类是否加载-链接-初始化"><a href="#6-3-1-判断对象对应的类是否加载-链接-初始化" class="headerlink" title="6.3.1 判断对象对应的类是否加载 链接 初始化"></a>6.3.1 判断对象对应的类是否加载 链接 初始化</h3><p>很显然这三步是反射的时候学过的，然后一开始类加载也学过一些， 可以看chapter02回忆一下。下面具体说：</p>
<p>虚拟机遇到一条new指令，首先根据这个指令的参数去metaspace 也就是方法区里面定位这个类的符号引用，并且检查这个符号引用对应的类是否完成了 加载 链接 初始化。 也就是查找类型元信息。如果找不到，则会在双亲委派模式下调用 ClassLoader 来加载Class文件， 如果找不到，则抛出 ClassNotFoundException。</p>
<p>如果找到了，则加载类，方法区中生成 Class对象。</p>
<h3 id="6-3-2-为对象分配内存"><a href="#6-3-2-为对象分配内存" class="headerlink" title="6.3.2 为对象分配内存"></a>6.3.2 为对象分配内存</h3><p>计算对象占用空间大小，这个根据类的成员类型很容易可以计算出来，如果是引用数据类型，那就分配 引用空间即可，也就是 4 字节，然后为对象分配空间。</p>
<p>如何分配空间又是个问题，这里区分内存规整和不规整：</p>
<ul>
<li><p>内存规整，则采用指针碰撞来为对象分配内存。</p>
<p>这tm是啥？简单说，就是如果内存规整，一条内存，用过的连续在一端，没用过的在另一端， 区分的特别明显，那么这条内存在用过的和没用过的中间有个指针用来划分区域。 在这种情况下分配内存，指针只需要向空的那一端移动和对象一样的大小即可。</p>
<p>如果垃圾收集器采用的是 Serial ParNew 这种基于标记压缩算法的，虚拟机使用这种内存分配方式。</p>
<p>一般使用带有 Compact(整理)过程的收集器时，使用指针碰撞。</p>
</li>
<li><p>内存不规整，虚拟机就需要维护一个列表，也就是空闲列表。</p>
<p>那么啥叫空闲列表？内存不规整，使用过的和没用过的相互交错，就需要一个列表用来 标记那些内存是没用过的，那些使用过的。</p>
<p>分配内存的时候，查询列表，找到一块能放得下的地方，吧对象放进去， 然后更新空闲列表。</p>
</li>
<li><p>总的来说，采用那种方法是由Java堆是否规整决定的，堆规整与否又是由所采用的垃圾收集器 是否有压缩算法决定。</p>
</li>
</ul>
<h3 id="6-3-3-处理并发安全问题"><a href="#6-3-3-处理并发安全问题" class="headerlink" title="6.3.3 处理并发安全问题"></a>6.3.3 处理并发安全问题</h3><ul>
<li><p>采用CAS 失败重试，区域枷锁 保证更新的原子性</p>
</li>
<li><p>给每个线程预留一块 TLBA ，通过 -XX:+&#x2F;-useTLBA 来控制， jdk8默认开启。</p>
</li>
</ul>
<h3 id="6-3-4-初始化分配到的空间"><a href="#6-3-4-初始化分配到的空间" class="headerlink" title="6.3.4 初始化分配到的空间"></a>6.3.4 初始化分配到的空间</h3><p>简单地说就是给每个成员一个默认值，保证一个对象不赋值就可以直接使用。</p>
<h3 id="6-3-5-设置对象的对象头"><a href="#6-3-5-设置对象的对象头" class="headerlink" title="6.3.5 设置对象的对象头"></a>6.3.5 设置对象的对象头</h3><p>将对象的所属类(也就是累的元信息) 和 对象的 HashCode 和 对象的 GC信息，锁信息存储到对象头中，这个过程的具体设置方式取决于JVM。</p>
<h3 id="6-3-6-调用-init-方法"><a href="#6-3-6-调用-init-方法" class="headerlink" title="6.3.6 调用 init 方法"></a>6.3.6 调用 init 方法</h3><p>init 方法并不是构造方法，而是给对象进行完整的赋值，比如 成员的赋值，实例代码块里面对于成员的赋值，构造函数里面给成员的赋值，都在init 方法里面，不是单纯的构造函数。</p>
<h2 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h2><p>看这条代码</p>
<p>Object o &#x3D; new Object();</p>
<p>其实 new 就是一个指令，告诉JVM 要去加载 Object，然后Object() 就是调用构造器，完整的创建一个对象出来，应该是吧上面的6部全都执行完才算是创建完了，就一个new，可以说仅仅是有了个对象的大体模型，但是细节还不完善。</p>
<h1 id="7-对象的内存分布"><a href="#7-对象的内存分布" class="headerlink" title="7. 对象的内存分布"></a>7. 对象的内存分布</h1><p>对象的内存分布主要分为：</p>
<ul>
<li><p>对象头 header</p>
</li>
<li><p>实例数据 instance data</p>
</li>
<li><p>对齐填充</p>
</li>
</ul>
<p>下面会挨个说。</p>
<h2 id="7-1-对象头"><a href="#7-1-对象头" class="headerlink" title="7.1 对象头"></a>7.1 对象头</h2><p>对象头里面包含两部分：</p>
<ul>
<li><p>运行时元数据 Mark Word（32bit），里面记录了以下内容：</p>
<ul>
<li><p>哈希值</p>
</li>
<li><p>GC分代年龄，就是堆里面的年龄计数器记录的那个东西</p>
</li>
<li><p>锁状态标志</p>
</li>
<li><p>线程持有的锁</p>
</li>
<li><p>偏向线程id</p>
</li>
<li><p>偏向时间戳</p>
</li>
</ul>
</li>
<li><p>类型指针 Klass Word（32bit）</p>
<p>指向了方法区里面的Class，也就是类型元信息。确定对象所属类型</p>
<p>方法 Object.getClass() 就是体现了这个，就是我们以前说的，对象可以找到 它对应的Class。</p>
</li>
<li><p>特殊情况： 如果存的是数组，那么还会保存数组长度信息（32bit）。</p>
</li>
</ul>
<p>这块内容在Java并发编程的时候也会说的，到时候可以再加深一下印象。</p>
<h2 id="7-2-实例数据"><a href="#7-2-实例数据" class="headerlink" title="7.2 实例数据"></a>7.2 实例数据</h2><p>他是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段 (包括继承的和本身的)</p>
<p>存放规则：</p>
<ul>
<li><p>相同宽度的字段总是被分配在一起。</p>
</li>
<li><p>父类中定义的变量会出现在子类之前</p>
</li>
<li><p>如果 CompactFields 参数为 true，子类的窄变量可以插入到父类的变量之间。</p>
</li>
</ul>
<h2 id="7-3-图解过程"><a href="#7-3-图解过程" class="headerlink" title="7.3 图解过程"></a>7.3 图解过程</h2><p>我们现在有一个Customer对象，这个对象里面还包含了一个Account对象，那么这个Customer对象的内存分布如何？</p>
<p>具体情况如下：</p>
<p><img src="/images/runtime/NewObjectProcess.png"></p>
<p>看图就行了，我觉得这个图还是挺清楚的。</p>
<h1 id="8-对象的访问定位"><a href="#8-对象的访问定位" class="headerlink" title="8. 对象的访问定位"></a>8. 对象的访问定位</h1><p>简单地说，JVM是如何通过栈帧中的引用访问到对象实例的？</p>
<p>懂得来说，都是一个流程：</p>
<p>栈帧中的引用指向堆区，堆区再通过元数据指针指向方法区。</p>
<p>具体的流程有两个：</p>
<h2 id="8-1-句柄访问"><a href="#8-1-句柄访问" class="headerlink" title="8.1 句柄访问"></a>8.1 句柄访问</h2><p>就是说堆中我们再专门弄出一个空间，专门用来放类型指针，栈的引用先指向了句柄，然后句柄再指向实例数据和类型数据。</p>
<p><img src="/images/runtime/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png"></p>
<h2 id="8-2-直接指针"><a href="#8-2-直接指针" class="headerlink" title="8.2 直接指针"></a>8.2 直接指针</h2><p>这个就很好理解了，就是堆中的对象里面还有个对象头指向了类型数据，HotSpot虚拟机就是使用这种办法。</p>
<p><img src="/images/runtime/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png"></p>
<p>这个就是栈帧里面的引用直接指向堆中的对象实体，实体里面有一个指针指向方法区的类型元信息。</p>
<p>Hotspot 虚拟机就用的是直接访问，看24那张图，可以看出来是直接访问。</p>
<h1 id="9-直接内存"><a href="#9-直接内存" class="headerlink" title="9. 直接内存"></a>9. 直接内存</h1><p>jdk8中的元空间不再是 jvm的虚拟内存，而是直接内存，所以这里我们看看什么是直接内存。</p>
<h2 id="9-1-直接内存概念"><a href="#9-1-直接内存概念" class="headerlink" title="9.1 直接内存概念"></a>9.1 直接内存概念</h2><ul>
<li><p>直接内存不是虚拟机运行时内存的一部分，也不是java虚拟机规范中定义的内存区域</p>
</li>
<li><p>直接内存是堆外，直接向系统申请的内存</p>
</li>
<li><p>来源于 NIO，通过存在堆中的 DirectByteBuffer操作native内存。</p>
</li>
<li><p>通常，访问直接内存的效率要高于java堆，读写速度快。</p>
<ul>
<li><p>由于处于性能考虑，读写频繁的场合可能用到直接内存。</p>
</li>
<li><p>java 的NIO 库允许Java程序直接使用内存，用于数据缓冲区。</p>
</li>
</ul>
</li>
</ul>
<h2 id="9-2-NIO-和-IO-的比较"><a href="#9-2-NIO-和-IO-的比较" class="headerlink" title="9.2 NIO 和 IO 的比较"></a>9.2 NIO 和 IO 的比较</h2><ul>
<li><p>IO：文件输入输出</p>
<p>基础工具：byte[] &#x2F; char[] 用于传输</p>
<p>基础的类：Stream</p>
</li>
<li><p>NIO(New IO &#x2F; Non-Blocking IO)</p>
<p>基础工具：Buffer</p>
<p>基础的类：Channel</p>
</li>
</ul>
<p>不使用 NIO ，JVM进行IO的流程如下：</p>
<p><img src="/images/runtime/non-direct-memory.png"></p>
<p>使用NIO，JVM进行IO流程</p>
<p><img src="/images/runtime/NIOProcess.png"></p>
<p>额，咱也不懂这玩意有啥用，反正先写在这里。</p>
<h1 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h1><p>啊，总算是整理完了，这一章东西可谓是奇多，不光是讲方法区，同时还讲了堆和方法区之间是如何配合的，这两部分如何协同才能创建出一个对象来。需要慢慢消化。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-页面跳转</title>
    <url>/2022/05/22/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<blockquote>
<p>create by 陈HL_pthef on 2022&#x2F;05&#x2F;22</p>
</blockquote>
<p>自从宣布开始做课设到现在，各种问题层出不穷，尤其页面跳转这个问题仍旧困扰着很多人。那在这里就详细说说 这个微信小程序到底如何实现页面跳转。</p>
<p><strong><font color="red">注意：</font></strong></p>
<p><strong>下面的内容不要深究原因，不要深究原因，不要深究原因</strong>，跟着做就可以了。</p>
<span id="more"></span>

<h2 id="1-页面"><a href="#1-页面" class="headerlink" title="1. 页面"></a>1. 页面</h2><p>想要页面跳转肯定先得有页面，所以如何创建页面呢？我这里用一个新的微信小程序模板：<br><img src="http://49.232.218.190/p1.png" alt="weixin_app"></p>
<p>首先，我们右键pages，那个红色的图标，右键他，然后选择新建文件夹，起一个合适的名字，我这里就叫 tempPage 。创建完以后如下所示：</p>
<p><img src="http://49.232.218.190/p2.png" alt="new_dir"></p>
<p>然后，我们右键你新建的这个文件夹，选择新建Page，要求你起个Page名称，我这里强烈建议：<strong><font color='red'>Page名称和文件夹名称保持一致</font></strong>。新建以后，就会出现4个文件，如下图：</p>
<p><img src="http://49.232.218.190/p3.png" alt="new_page"></p>
<p>呐，看好了，Page名和文件夹名一致。</p>
<p>而且，新建的这个文件夹，和文件夹里面这个和文件夹同名的Page，他们的名称必须<br><strong><font color='red'>全是英文！！！</font></strong>，这一点特别重要，否则待会跳转直接喜提 not found 异常。</p>
<p>然后我们在这个新页面上写点东西，打开 xxx.wxml 这个文件（xxx就是你Page的名），随你写点啥，我这里就写：</p>
<p><img src="http://49.232.218.190/p4.png" alt="temp_page_content"></p>
<p>很好，到这里，新页面准备完成，下一步我们需要实现从index.wxml 页面跳转到你的这个新页面。</p>
<h2 id="2-跳转"><a href="#2-跳转" class="headerlink" title="2. 跳转"></a>2. 跳转</h2><p>首先要想跳转，你得有个触发跳转的东西对吧，这里统一使用按钮也就是button，当然可以是别的，比如图片，view，啥的，都可以，但这里我就用button举例子了。所以我们的目标就是，在页面上放一个按钮，我们一点他，页面就会跳转到新页面。</p>
<p>第一步就是创建按钮，在 index.wxml 文件里面写一个button。</p>
<p><img src="http://49.232.218.190/p5.png" alt="button"></p>
<p>我这里的 index.wxml 啥也没有，你们的肯定有东西，根据你们的情况，把这个button放到合适的地方。同时可以看到左边 button 也显示出来了。</p>
<p>然后我们给这个button 绑定一个事件，在button标签里面写如下内容：</p>
<p><img src="http://49.232.218.190/p6.png" alt="button_bind"></p>
<p>其实就里面加了一个bindtap，bindtap后面跟着的那个东西，名字还真不能随便起，有如下规则：</p>
<ul>
<li>只能出现英文字母，数字和下划线（减号下面那个符号，我劝你别用）</li>
<li>数字不能开头</li>
</ul>
<p>我这里就叫jump了，你那叫啥都行，比如 toPage，toMyPage，甚至abc，都可以，但是决不能是 123, 1bc 甚至各种emoji，肯定报错。</p>
<p>然后，我们去这个页面对应的js文件下，因为我这个button是在index页面下写的，所以当前页面的js文件也就是index.js，在这个文件里加这么一段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我这里叫jump，你那还真不一定叫jump</span></span><br><span class="line"><span class="comment">// 你上面bindtap后面起的啥名，这里就写啥</span></span><br><span class="line"><span class="title function_">jump</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同理，我这里的url 写的是 ../tempPage/tempPage</span></span><br><span class="line">    <span class="comment">// 你那里不一定，这里应该写 ../你新页面的文件夹名/Page名</span></span><br><span class="line">    <span class="comment">// 而且特别注意，这里前里两个点一定不能丢。</span></span><br><span class="line">    <span class="comment">// 而且最后面的Page，没有后缀，不是 tempPage.js </span></span><br><span class="line">    <span class="comment">// 也不是 tempPage.wxml，就是tempPage</span></span><br><span class="line">    wx.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;../tempPage/tempPage&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>现在js文件的整体效果如下：</p>
<p><img src="http://49.232.218.190/p7.png" alt="js"></p>
<p>也就是这段代码，至少写在Page里面，你别写到Page外面了。</p>
<p>写完以后，保存，然后点击那个按钮，如果不出意外的话应该是可以跳转了。</p>
<h2 id="3-意外"><a href="#3-意外" class="headerlink" title="3. 意外"></a>3. 意外</h2><p>如果没跳转，看看是不是如下原因：</p>
<ul>
<li>跳转后页面一片大白：卡了，重启一下程序，或者看看你的新页面是不是就没写东西，那肯定白</li>
<li>页面白还有一种情况，那就是你把跳转页面的js文件里的东西都删了，切记切记：<strong><font color="red">新Page的js文件里的东西已经是最简形式，千万不要删任何东西</font></strong>。否则恭喜你喜提大白屏.</li>
<li>点击按钮没有反应：<ul>
<li>查看 bindtap 后面那个名字和代码里面那个名字是否一致，我的都叫jump</li>
<li>卡了，重启</li>
</ul>
</li>
<li>跳转后告诉你 not found：这个原因就多了，归根到底就是微信没找到页面<ul>
<li>检查跳转路径：必须是 <code>../跳转页面所在文件夹名/跳转页面名</code>，且页面名没有任何后缀</li>
<li>检查页面路径，两个页面是否都在文件夹里面包着，然后这个文件夹都在红色的pages下。只有满足这个要求，上面的跳转路径才能生效。</li>
<li>别是用了中文吧？？！！</li>
</ul>
</li>
</ul>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>我这里是用了 index页面往别的页面跳转做示范，但是实际做课设的时候真不一定就是从index页面跳，可能是你自己的A页面往你自己的B页面跳，咋办？？照猫画虎呗。</p>
<p>现在你要从A页面跳到B页面：</p>
<ul>
<li>首先确认两件事：<ul>
<li>AB两页面是否都在文件夹里面，文件夹是否都在 pages 下，也就是说两文件夹同层</li>
<li>Ab两页面的文件夹和页面名是否有中文，确认没有</li>
</ul>
</li>
<li>在A页面中写一个button，并照猫画虎写个bindtap，后面的名字按规范起</li>
<li>在A页面的js文件中，插入上述那段代码，名字必须和你的bindtap一致，url改成<code>../B页面的所在文件夹名称/B页面名称(切记没有后缀)</code></li>
<li>完成</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>网站部署</title>
    <url>/2022/10/19/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>最近写了个小网站，用于给别人的大创项目结项，同时自己也练练技术，本着大学最后一次做应用项目的原因，打算把这个项目做的正式一点，所以开发，部署，dns，备案 一串工作全做了，挺费劲。这里总结一下这次部署网站的流程。</p>
<span id="more"></span>

<blockquote>
<p>create by P-F on 2022&#x2F;10&#x2F;19</p>
</blockquote>
<h1 id="1-开发阶段"><a href="#1-开发阶段" class="headerlink" title="1. 开发阶段"></a>1. 开发阶段</h1><p>开发阶段没什么好说的，前端用的是 Vue+element+axios，后端是 go+beego+mysql+redis+jwt，很正常的技术栈。需要说的是平时调试，平时调试的时候 Vue 项目就是 <code>npm run serve</code> 开8080端口简单启动一下，然后 beego 项目那就是 <code>bee run</code> 开 9090 端口，这个时候就有个问题，两个不同端口之间通讯会跨域，同时我每次打开浏览器还得输入 <code>:8080</code>，很麻烦，所以怎么办呢？</p>
<p>我用本机的 Nginx 做了一下反向代理，直接访问 &#x2F; 转发到 <code>localhost:8080</code>，访问 &#x2F;v1&#x2F;* 就会转发到 <code>localhost:9090</code>，这样前端就直接访问 localhost&#x2F;v1&#x2F;xxx 就可以走 beego 服务，也不用担心跨域。看一下本机 Nginx 的配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ ^/v1/.*$</span> &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:9090;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里顺带复习一下 Nginx 的 location 配置：<code>location ~</code> 后面接的是正则，会根据正则来判断是否进入这个 location。</p>
<p>剩下的倒是十分的顺利，因为开发阶段嘛，就在本机，也没有网络的影响，总体感觉十分良好，但是到了真正上线的时候那问题就大了。</p>
<h1 id="2-前端部署"><a href="#2-前端部署" class="headerlink" title="2. 前端部署"></a>2. 前端部署</h1><p>前端的部署，属实非常的坎坷。</p>
<h2 id="2-1-项目拉取"><a href="#2-1-项目拉取" class="headerlink" title="2.1 项目拉取"></a>2.1 项目拉取</h2><p>把前段项目部署到服务器，首先就是如何把项目放到服务器上，之前我的做法是通过 scp 命令直接从本机复制到服务器，但是实在麻烦，所以这回变了。我在服务器上通过 git 把项目源码拉下来，然后修改一些启动参数，再 <code>npm install; npm run build</code> 即可得到 Vue 项目的 dist 包。</p>
<h2 id="2-2-项目部署"><a href="#2-2-项目部署" class="headerlink" title="2.2 项目部署"></a>2.2 项目部署</h2><p>Vue 本质上是一个单页面应用，也就是整个网站本质上就是那个 index.html，但是通过各种 js 啥玩意的可以让这个 index.html 根据不同的 url 显示不同的东西。我第一次部署 Vue 还真就是在服务器上运行 <code>npm run serve</code> 然后就没事了，结果就是关闭终端以后项目也就没了。所以正确姿势就是：将 Vue 打包成 dist，然后配置后端服务器，比如 Nginx，Tomcat，或者自己用 nodejs 自己写一个也行，要实现将找不到对应静态资源的请求全部转发到 vue 生成的 index.html 中。下面就是使用 Nginx 部署 Vue 项目的配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/local/www/manyin-tech-frontend/dist;</span><br><span class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">@router</span>;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> <span class="variable">@router</span> &#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^.*$</span> /index.html <span class="literal">last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体含义就是：首先，访问了 &#x2F; 以后，先去找有没有对应的静态资源，比如前端请求图片你也给他转发到 index.html 这显然不合适，所以首先 <code>try_files @uri @uri/</code> 来判断请求的静态资源是否存在，如果不存在，则转发到 @router 这个location，@router location 再将请求转发给 index.html。</p>
<p>同时配置一下后端的反向代理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这段在 server 块外面</span></span><br><span class="line">upstream manyin_service &#123;</span><br><span class="line">        server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9090</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ ^<span class="regexp">/v1/</span>.+$ &#123;</span><br><span class="line">        proxy_pass <span class="attr">http</span>:<span class="comment">//manyin_service;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，到这里算是初步的部署完了，可以通过 IP 地址访问了。</p>
<h2 id="2-3-静态资源优化"><a href="#2-3-静态资源优化" class="headerlink" title="2.3 静态资源优化"></a>2.3 静态资源优化</h2><p>结果一访问发现问题了，页面加载速度特别的慢，可能得一分钟才能把首页加载完，这是为啥？一看浏览器控制台，好家伙，首页三张图片就 20m 多，怪不得慢。那咋办？压缩一下图片。</p>
<p>结果网上找了一圈，要么让我下软件，要么就是在线压缩跟我要钱，好在最后找到一个非常好用的网站，功能还挺多，还能压缩图片：</p>
<p><a href="https://oktools.net/">oktools</a></p>
<p>通过这个网站，把图片的大小降低到了一张 200-300k 的大小，还算是ok。但是图片压缩了以后访问还是略慢，这个时候想到了 Nginx 的 gzip 功能，Nginx 可以将一些静态资源进行 gzip 压缩发送给浏览器，然后浏览器会自动解压，我寻思这样可能可以再加快一点访问速度，于是开始配置 Nginx 的压缩。实测图片不需要压缩，因为根本压不了多少，但是 Vue 打包后一些巨大的 js 文件倒是压缩效果非常不错，可能一个 3 400k 的 js 文件压缩以后就不到100k，css 也可以压缩。下面直接贴配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_types</span> application/javascript text/css;</span><br><span class="line"><span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_disable</span> <span class="string">&quot;MSIE [1-6]\.&quot;</span></span><br><span class="line">gzip_min_length <span class="number">1024</span>;</span><br><span class="line"><span class="attribute">gzip_proxied</span> <span class="literal">off</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>gzip gzip_types gzip_vary 这几个配置比较重要，剩下的似乎不那么要紧，啥意思也忘了，用到的时候再查。</p>
</blockquote>
<p>这块配置放到了 nginx 目录的 conf&#x2F;conf.d 目录下的 gzip.conf 中，这个目录里面就是一些我自己的配置文件，比如上面部署 Vue 的配置我就写在了这个目录的 manyin.conf 文件中，然后在 nginx.conf 文件中 include 就行了。</p>
<p>配置完这些以后就算是差不多了，访问速度反正是说得过去。</p>
<h1 id="3-后端部署"><a href="#3-后端部署" class="headerlink" title="3. 后端部署"></a>3. 后端部署</h1><p>后端倒是部署的方便，为啥？没那么多要求，就是改个启动配置，比如 mysql 的连接，redis 的连接这些的。</p>
<p>整个项目用 go 开发，首先服务器下个 go，直接 <code>yum install -y go</code> 就行了，懒得用源码包安装。然后同理用 git 把后端代码拉取下来，安装项目的依赖包，首先得配置一下代理，否则下载 go 的第三方宝可能会比较慢：<code>go env -w GOPROXY=https://goproxy.cn,direct</code>（忘了是不是这个了，反正是当时配置了代理）。然后就是下载依赖包，好像直接 <code>go mod tidy</code> 就行了。最后一步是 <code>go mod vendor</code> 将依赖包拉到项目目录中，这样项目就可以脱离 gopath 了。</p>
<p>然后 <code>go run main.go</code> 测试一下ok不，ok的话打包：<code>go build</code> 然后设置后台执行：<code>nohup ./go-service &gt; logs.log &amp;</code> 就可以了。</p>
<p>到这里，前后端就算是部署完了，总结一下：后端开放 9090 端口，Nginx 将 &#x2F;v1&#x2F;* 请求转发到 9090 口实现反向代理，同时避免了跨域。Vue 项目部署在 Nginx 上，开启 gzip 帮忙加速。然后就可以愉快的通过 IP 地址访问项目了。</p>
<h1 id="4-域名、DNS、备案"><a href="#4-域名、DNS、备案" class="headerlink" title="4. 域名、DNS、备案"></a>4. 域名、DNS、备案</h1><p>后面的倒是比较的简单吧算是，主要是麻烦，特别的麻烦，但是因为我整个流程是在腾讯云办的，所以跟着腾讯云的文档全程没有问题。</p>
<h2 id="4-1-域名"><a href="#4-1-域名" class="headerlink" title="4.1 域名"></a>4.1 域名</h2><p>首先第一步就是买域名，买完了以后还需要买个 DNS 套餐。我这里用的是腾讯买的域名，买完以后进入腾讯的 DNSPod，给域名添加一个 A 记录（IPv4记录），指向我们从腾讯云买的服务器。然后不出意外一会儿就能通过域名访问了。</p>
<p>但是过一阵子可能再访问会告诉你未通过报备，不让你访问，这就需要进行下一步，报备。</p>
<h2 id="4-2-报备"><a href="#4-2-报备" class="headerlink" title="4.2 报备"></a>4.2 报备</h2><p>这一步其实也简单，跟着腾讯的文档做就可以了。首先第一步是腾讯备案，腾讯会先给把关，通过微信小程序进行备案，然后提供相关材料即可，具体啥材料文档有说的。</p>
<p>对了，备案的时候可能需要把 DNS 的解析关掉。</p>
<p>其实作为我们用户只需要做第一步就行了，就是填上你的报备信息，然后腾讯审核完了就会送给省里去申，这个倒是很慢，我10月3号提交的，10月19号才审核完。</p>
<p>审完了以后会给你一个备案号，把这个备案号贴到网站的底部：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://beian.miit.gov.cn/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>冀ICP备xxx号-1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>就可以了。说是不贴的话要罚款。</p>
<h2 id="4-3-公安备案"><a href="#4-3-公安备案" class="headerlink" title="4.3 公安备案"></a>4.3 公安备案</h2><p>管局备案完了就要去公安备案，也是跟着腾讯的文档就行了，我也是今天刚提交的，不知道结果咋样。顺带一提，腾讯的文档写的是真不错。</p>
<h2 id="4-4-SSL-证书"><a href="#4-4-SSL-证书" class="headerlink" title="4.4 SSL 证书"></a>4.4 SSL 证书</h2><p>腾讯给提供一年的免费 SSL 证书，进入腾讯的 SSL 那个控制台就能看见，申请一个，然后怎么把证书部署到 Nginx，同样有详细的文档，这里就不说了。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>总结一下奥，域名、DNS、备案、SSL 着一系列操作只需要跟着腾讯的文档就完全没有问题，就死死把握一个流程：购买域名和DNS -&gt; 添加解析记录 -&gt; 提交备案 -&gt; 安装 SSL -&gt; 公安备案 。然后哪个流程不会去腾讯文档查就行了。</p>
]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>页面防抖</title>
    <url>/2022/10/17/%E9%A1%B5%E9%9D%A2%E9%98%B2%E6%8A%96-md/</url>
    <content><![CDATA[<p>页面防抖是接口幂等性的其中一环，接口幂等性说的是一个接口执行依次和执行多次发生的结果一样，后端保证接口幂等性主要是就是发送请求令牌啥的，前端的话就得考虑如何避免帕金森患者多次点击一个按钮发送多次请求。</p>
<span id="more"></span>

<blockquote>
<p>create by P-F on 2022&#x2F;10&#x2F;17</p>
</blockquote>
<h1 id="1-防抖"><a href="#1-防抖" class="headerlink" title="1. 防抖"></a>1. 防抖</h1><p>前端的某个请求按钮在短时间内多次点击但是只会执行依次就是防抖，比如我以前做过一个线上考试系统，点击创建班级没有做防抖，结果被帕金森患者创建了十多个一样的班级。</p>
<h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><p>具体实现就是，给一个按钮设置一个定时器，比如这个按钮在点击以后会在200ms以后才执行，在200ms被再次点击的话就会重置计时器，保证这个按钮是在最后一次点击的200ms以后被执行。至于说用户 200ms 以后有点急了咋办，可以在这期间给这个按钮上锁，直接disabled就行了。</p>
<p>看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建防抖函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> debounce = <span class="keyword">function</span>(<span class="params">callback, delay_</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> delay = delay_ || <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">            callback.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;debounce&#125; <span class="keyword">from</span> <span class="string">&quot;...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 debounce，传入想要实现防抖的方法，即可实现防抖</span></span><br><span class="line"><span class="attr">addUser</span>: <span class="title function_">debounce</span>(<span class="keyword">function</span>(<span class="params">user</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(user)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure>

<h1 id="3-原理"><a href="#3-原理" class="headerlink" title="3. 原理"></a>3. 原理</h1><p>这玩意有点意思，深究一下为啥调用一个 debounce 就能实现防抖了。</p>
<h2 id="3-1-闭包"><a href="#3-1-闭包" class="headerlink" title="3.1 闭包"></a>3.1 闭包</h2><p>首先，我觉得这个东西用到了一个很有意思的思想：闭包。debounce 作为外层函数创建了一个变量：timer，然后内层函数访问 timer，修改 timer，最后 debounce 返回了内层函数，那么到了最后 debounce 这个外层函数并没有被销毁，而是隐隐的给内层函数提供 timer 这个变量，很有意思。</p>
<h2 id="3-2-结果"><a href="#3-2-结果" class="headerlink" title="3.2 结果"></a>3.2 结果</h2><p>我们调用 <code>addUser: debounce(function(args)&#123;...&#125;, 300)</code> 之后，addUser 最后变成了啥样了？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="attr">addUser</span>: <span class="title function_">debounce</span>(<span class="keyword">function</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`add user, name=<span class="subst">$&#123;name&#125;</span>, age=<span class="subst">$&#123;age&#125;</span>`</span>)</span><br><span class="line">        &#125;, <span class="number">300</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是我们想要让 addUser 实现防抖，那就传入我们要防抖的逻辑传入 debounce，然后打印一下 addUser 看看是啥样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面渲染以后 addUser：</span></span><br><span class="line"><span class="attr">addUser</span>: <span class="keyword">function</span> <span class="title function_">_</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        callback.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会发现，debounce 会生成一个没有形参的函数，然后里面会调用我们传入的 callback。但是有个问题，就是我们调用 addUser 的时候肯定会传入 name 和 age，但是 addUser 又是一个无参方法，咋办，怎么正确的传参？</p>
<p>这个时候就会说道 arguments 对象。</p>
<h2 id="3-3-arguments"><a href="#3-3-arguments" class="headerlink" title="3.3 arguments"></a>3.3 arguments</h2><p>JS 的 function 内部会自动有一个对象：arguments，内部就存储了所有传入的参数，哪怕这个 function 没有形参：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`args len: <span class="subst">$&#123;<span class="variable language_">arguments</span>.length&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">arguments</span>[<span class="number">0</span>] + <span class="variable language_">arguments</span>[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>除此之外，我们可以通过 arguments 对象来修改实参：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用严格模式，修改不会生效，不加这行的话修改才能生效。</span></span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="variable language_">arguments</span>[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">    <span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">arguments</span>[<span class="number">0</span>] + <span class="variable language_">arguments</span>[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>这里返回的不是 30，而是 300，即便我们传入的是 10 20，但是函数内通过 arguments 对象修改了实参为 100 200。当然这是在费严格模式下，如果在严格模式下，是不能修改实参的。（费严格模式把那行 use strict 注释掉）。</p>
<p>所以在这个防抖函数里面，即时返回的防抖函数没有形参，我们也依旧可以通过 arguments 得到我们调用时传入的实参，然后传给 callback。</p>
<h2 id="3-4-apply-方法"><a href="#3-4-apply-方法" class="headerlink" title="3.4 apply 方法"></a>3.4 apply 方法</h2><p>我们还会发现，调用 callback 的时候并没有直接 <code>callback(arguments)</code>，而是 <code>callback.apply(this, arguments)</code>，这是为啥？这里就需要说说 apply 方法。</p>
<p>apply 方法用于重新指定 function 的 this 指向，当然这是我自己的理解，官方说的是让 function 在别的对象上执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello, i&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>, i&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Lucy&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user.<span class="property">hello</span>.<span class="title function_">apply</span>(person)</span><br></pre></td></tr></table></figure>

<p>最后执行的结果是 hello, i’m Lucy, i’m 10 years old，我们就会发现，hello 方法里面的 this 居然指向了 person，也就相当于 hello 跑到了 person 对象内被执行了，是不是很神奇。</p>
<p>所以防抖函数里面为啥要用 apply？因为我们传入的 callback 的 this 不是 VueComponent，所以我们需要调用 apply 方法，将 this 修改为 VueComponent，同时还需要用 apply 方法将 arguments 传入。</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>可以看到，一个小小的防抖就涉及到这么多知识点，就是因为当时看不懂这个防抖，才去补课 this 指向问题的。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>运行时数据区概述</title>
    <url>/2022/05/27/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>从这里开始正式进入运行时数据区，运行时数据区是JVM非常核心的一部分，各种内存模型各种垃圾回收都将从这里展开。</p>
<span id="more"></span>

<h1 id="1-运行时数据区"><a href="#1-运行时数据区" class="headerlink" title="1. 运行时数据区"></a>1. 运行时数据区</h1><p>运行时数据区，非常之核心，JVM运行时大部分数据都存在运行时数据区，所以后面大部分的展开，比如各种的字符串，常量池，GC，等等等等一系列的故事都将发生在这里。</p>
<p>首先看一下运行时数据区的图：</p>
<p><img src="/images/runtime/Runtime_data_area.png" alt="runtime"></p>
<p>主要就是包含了：程序计数器、本地方法栈、虚拟机栈、堆、元空间。其中这里先介绍几个简单的，比如程序计数器和本地方法这种的，剩下的虚拟机栈和堆和元空间，都是重点中的重点。</p>
<p>同时扩展一点东西：</p>
<ul>
<li><p>PC寄存器：不涉及 Error 不涉及 GC</p>
</li>
<li><p>虚拟机栈：涉及 Error，比如 StackOverFlowError，不涉及GC，直接弹栈即可。</p>
</li>
<li><p>本地方法栈：涉及 Error，不涉及 GCasd</p>
</li>
<li><p>堆 和 方法区：都涉及 Error 和 GC</p>
</li>
</ul>
<p>这5种东西，一部分是和Java程序共存亡，随着JVM启动而启动，随着JVM销毁而销毁另外的，和线程共存亡。</p>
<p>方法区 和 堆，线程之间公用，剩下的，每一个线程都会有自己独一份的这些东西。</p>
<p>对应的对象就是 Runtime，每一个Java 应用，或者说，一个jvm就对应着一个Runtime对象。</p>
<p>其中，JVM内部还有一些线程：</p>
<ul>
<li><p>虚拟机线程，特别复杂，不说了</p>
</li>
<li><p>周期任务线程，一般用于周期性操作的调度执行</p>
</li>
<li><p>GC线程，支持不同种类的垃圾收集行为</p>
</li>
<li><p>编译线程，将字节码编译成本地代码</p>
</li>
<li><p>信号调度线程，接收信号发给JVM处理</p>
</li>
</ul>
<p>这些东西似乎就没有啥用了，应该不会用到吧。</p>
<h1 id="2-PC寄存器"><a href="#2-PC寄存器" class="headerlink" title="2. PC寄存器"></a>2. PC寄存器</h1><p>所谓PC寄存器，全称 Program Counter Register，也叫程序计数器，主要用于存储下一条要执行的指令的地址。</p>
<p>我们随便写一个程序，然后我们反编译他的 class文件，会看到如下文字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0:bipush   10  </span><br><span class="line">2:istore_1  </span><br><span class="line">3:bipush   20  </span><br><span class="line">4:istore_2</span><br></pre></td></tr></table></figure>

<p>这种的，第一列的数字就是指令地址，第二列以及后面的东西就叫指令，pc寄存器会存储下一条指令的地址，也就是 比如 0 2 这种东西，然后执行引擎会读取pc寄存器里面存储的指令地址所对应的指令，去运行这个指令。</p>
<p>具体流程下图所示：</p>
<p><img src="/images/runtime/pc_register.png" alt="pc_process"></p>
<h2 id="为什幺用PC寄存器"><a href="#为什幺用PC寄存器" class="headerlink" title="为什幺用PC寄存器"></a>为什幺用PC寄存器</h2><p>记录执行位置，并发(CPU轮转)状态下，每个线程都会抢时间片，那么抢到了就会接着执行，这个时候就需要记录当前状态下，该执行那条指令了，PC寄存器就是记录执行状态的。</p>
<p>JVM字节码解释器通过改变PC寄存器的值来记录执行状态。</p>
<h1 id="3-本地方法接口"><a href="#3-本地方法接口" class="headerlink" title="3. 本地方法接口"></a>3. 本地方法接口</h1><p>我们前面一直在说Runtime的事，我们先跳出Runtime，先来看一个东西：本地方法。</p>
<p>首先我们来看一眼JVM的整体结构：</p>
<p><img src="/images/runtime/jvm_structure.jpg" alt="jvm_stu"></p>
<p>看到右下角的两个东西了么：NativeMethodInterface和 NativeMethodLibrary，这两个东西要和 运行时数据区里面的 本地方法栈进行联系，所以我们现看这两块内容。</p>
<h2 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h2><h3 id="什么是本地方法"><a href="#什么是本地方法" class="headerlink" title="什么是本地方法"></a>什么是本地方法</h3><p>何为本地方法，Java 调用一个非Java 实现的方法的接口，这个接口就是本地方法，也就是 NativeMethod，(Native 是个关键字);</p>
<p>再简单说，本地方法就是一个Java方法，但是这个方法的具体实现并不是 Java，多数情况下是 C&#x2F;C++。本地接口的作用就是融合不同语言来为Java所用，最主要还是融合 C&#x2F;C++.</p>
<p>需要注意的是，native 方法因为它本身就是 Java 方法，所以Java 方法上有的东西他都有，比如可以进行权限控制，可以使用同步代码，可以抛出异常，可以有static 修饰等。</p>
<h3 id="为什么要用本地方法"><a href="#为什么要用本地方法" class="headerlink" title="为什么要用本地方法"></a>为什么要用本地方法</h3><p>有时Java需要和外部环境交互，比如操作系统，创建 Thread这种的，或者说有些时候需要特别在以效率，就需要用到NativeMethod</p>
<h3 id="和操作系统的交互"><a href="#和操作系统的交互" class="headerlink" title="和操作系统的交互"></a>和操作系统的交互</h3><p>JVM毕竟不是真是的操作系统，他是要依赖于本地环境，这就不可避免的有C代码，同时如果我们关注效率，也需要C，比如 创建线程，这个就是一个本地方法，调用了操作系统的api，去创建线程。</p>
<p>Sun’s Java 的解释器有一部分就是C写的，JVM内部就已经植入了一部分C代码，所以不可避免的需要和C交互。</p>
<h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>目前Java已经很少用到Native了，除非是一些底层操作，比如调用打印机这种的，还是需要用到C。</p>
<h1 id="4-本地方法栈"><a href="#4-本地方法栈" class="headerlink" title="4. 本地方法栈"></a>4. 本地方法栈</h1><p>至于本地方法栈，这个东西 简单说，似乎不怎么用。这里涉及到了一些虚拟机栈的知识，后面会说。</p>
<ul>
<li><p>Java虚拟机栈使用管理Java方法的，那么很显然本地方法栈就是用来管理本地方法的。</p>
</li>
<li><p>和虚拟机栈同理，本地方法栈也是线程独有的。</p>
</li>
<li><p>同样可以扩展本地方法栈，同样会抛出 StackOverflowError 和 OutOfMemoryError。</p>
</li>
<li><p>当某个线程调用了一个本地方法后，这个本地方法就会进入一个权限的不受虚拟机限制的世界。他和虚拟机有同样的权限。</p>
<ul>
<li><p>本地方法可以调用本地方法接口来访问虚拟机内部的运行时数据区。</p>
</li>
<li><p>可以直接使用本机处理器中的寄存器。</p>
</li>
<li><p>可以直接分配本地内存</p>
</li>
</ul>
</li>
<li><p>并不是所有的 JVM 都支持本地方法，因为虚拟机规范并没有规定本地方法的实现语言等， 所以如果虚拟机不打算使用本地方法，也就无需本地方法栈</p>
</li>
<li><p>Hotspot JVM中，直接把本地方法栈和虚拟机栈合二为一。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>底层</tag>
      </tags>
  </entry>
</search>
