<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false,"b2t":true,"scrollpercent":20},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="PtheF-Hexo-Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="PtheF-Hexo-Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="PtheF">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>PtheF-Hexo-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">PtheF-Hexo-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">有点意思</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/30/09-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hexo_avatar.jpeg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PtheF-Hexo-Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/30/09-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">09.虚拟内存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-30 11:06:45 / 修改时间：11:14:01" itemprop="dateCreated datePublished" datetime="2023-06-30T11:06:45+08:00">2023-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="1-虚拟内存概念"><a href="#1-虚拟内存概念" class="headerlink" title="1. 虚拟内存概念"></a>1. 虚拟内存概念</h1><p>传统的内存管理分为连续分配和非连续分配，共同点都是需要将全部的进程数据加载到内存中才可以运行。这就会造成两个问题：</p>
<ul>
<li>作业很大时，不能全部装入内存，导致大作业无法运行，比如各种大型游戏</li>
<li>大量作业要求运行时，由于内存无法装入所有作业，因此只有少量作业能够运行，导致多道程序并发度下降</li>
</ul>
<p>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直到作业运行结束，实际上一个时间段内只需要访问作业的一小部分数据即可正常运行，这就导致内存中驻留大量的暂时用不到的数据，浪费资源。</p>
<h2 id="1-1-局部性原理"><a href="#1-1-局部性原理" class="headerlink" title="1.1 局部性原理"></a>1.1 局部性原理</h2><p>虚拟内存就是基于局部性原理出来的，局部性分为两种：</p>
<ul>
<li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很可能再次被执行</li>
<li>空间局部性：如果访问了某个存储单元，那么附近的其他存储单元也可能被访问</li>
</ul>
<h2 id="1-2-虚拟内存定义和特征"><a href="#1-2-虚拟内存定义和特征" class="headerlink" title="1.2 虚拟内存定义和特征"></a>1.2 虚拟内存定义和特征</h2><p>基于局部性原理，当程序装入内存时，可以将程序中很快会被用到的部分装入内存，暂时用不到的部分留在外存，然后开始执行。</p>
<p>执行过程中，当访问信息不在内存中时，操作系统将所需要信息从外存调入内存，然后继续执行进程。</p>
<p>如果内存空间不够，操作系统负责将内存中暂时不到的信息换出内存。</p>
<p>所以在操作系统的管理下，用户就会觉得似乎有一个比实际内存大的多的内存空间，这个就是虚拟内存。</p>
<p>虚拟内存的三个主要特征：</p>
<ul>
<li>多次性：无需在作业运行时一次性装入内存，而是允许多次调入内存</li>
<li>对换性：在作业运行时无需一直常驻内存，而是运行在作业运行过程中将作业换入换出</li>
<li>虚拟性：在逻辑上扩充了内存容量，在用户看来内存多于实际容量</li>
</ul>
<h2 id="1-3-如何实现虚拟内存技术"><a href="#1-3-如何实现虚拟内存技术" class="headerlink" title="1.3 如何实现虚拟内存技术"></a>1.3 如何实现虚拟内存技术</h2><p>既然允许多次调入内存，那么连续分配方式就不太合适了。因此虚拟内存的前提是操作系统支持离散分配内存的管理方式。</p>
<p>传统的离散管理方式：</p>
<ul>
<li>分页式管理</li>
<li>分段式管理</li>
<li>段页式管理</li>
</ul>
<p>虚拟内存的实现方式：</p>
<ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ul>
<p>区别在于，进程执行过程中，当访问的信息不在内存时，操作系统负责将所需信息从外存调入内存，然后继续执行，操作系统需要提供请求调页功能。空间不够时，操作系统负责将内存中暂时用不到的信息换出到外存，操作系统需要提供页面置换功能。</p>
<h2 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628231408.png" alt="image.png"></p>
<h1 id="2-请求分页存储管理方式"><a href="#2-请求分页存储管理方式" class="headerlink" title="2. 请求分页存储管理方式"></a>2. 请求分页存储管理方式</h1><p>对比基本分页管理方式，主要需要提供两个功能：</p>
<ul>
<li>请求调页：发现访问的信息不在内存中，OS将所需信息从外存调入内存</li>
<li>页面置换：内存空间不够，OS负责将不需要的信息换出到外存</li>
</ul>
<h2 id="2-1-页表机制"><a href="#2-1-页表机制" class="headerlink" title="2.1 页表机制"></a>2.1 页表机制</h2><p>与基本分页管理中的页表相比，有以下区别：</p>
<ul>
<li>OS 需要知道每个页面是否已经调入内存，如果没有，也需要知道页面在外存中的位置。</li>
<li>内存不够时需要进行页面置换，OS 需要通过某些指标来决定到底换出哪个页面；有的页面没有被修改过就不需要换出，修改过的页面就需要会写到外存覆盖旧数据。</li>
</ul>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628232041.png" alt="image.png"></p>
<h2 id="2-2-缺页中断机构"><a href="#2-2-缺页中断机构" class="headerlink" title="2.2 缺页中断机构"></a>2.2 缺页中断机构</h2><p>根据上图，假设我们现在要访问页号为0的页面，结果OS发现0号页面不在内存中，就会产生一个缺页中断，然后由OS的缺页中断处理程序处理中断。</p>
<p>此时缺页的进程阻塞，放入阻塞队列，调页完成后再唤醒，放回阻塞队列。</p>
<p>在调页的过程中，如果发现内存中有空闲页框，就将页框分配给0号页，同时修改页表中的内存块号为响应的页框号。如果发现内存中没有空闲位置了，就会由页面置换算法选择一个页面淘汰，比如淘汰2号页面，发现页面被修改，则将内存块c的内容覆盖回外存z的位置，然后修改内存块号为无，修改位为0，再将内存块c分配给0号页面，修改内存块号为c。</p>
<p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生，属于内中断，可以被修复，所以属于故障。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628232837.png" alt="image.png"></p>
<h2 id="2-3-地址转换"><a href="#2-3-地址转换" class="headerlink" title="2.3 地址转换"></a>2.3 地址转换</h2><p>这个和基本的分页管理其实没啥大的不同，只是多了三步：</p>
<ol>
<li>如果发现页面不在内存则请求调页</li>
<li>如果发现没有空闲的页框则则页面置换</li>
<li>需要修改页表中的页表项</li>
</ol>
<p>完整流程如下：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628233547.png" alt="image.png"></p>
<p>这里再说一个点：如果页面被调出内存放入外存，快表中的表项会一并删除，双写一致性了属于是。</p>
<h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628233922.png" alt="image.png"></p>
<h1 id="3-页面置换算法"><a href="#3-页面置换算法" class="headerlink" title="3. 页面置换算法"></a>3. 页面置换算法</h1><p>将页面置换出外存需要额外的IO开销，所以好的页面置换算法就要追求更少的缺页率，下面介绍5个页面置换算法。</p>
<h2 id="3-1-最佳置换算法OPT"><a href="#3-1-最佳置换算法OPT" class="headerlink" title="3.1 最佳置换算法OPT"></a>3.1 最佳置换算法OPT</h2><p>每次淘汰的页面都是以后永不使用，或者最长时间内不再被访问的页面，这样可以保证最低的缺页率。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628235452.png" alt="image.png"></p>
<p>第一次缺页发生在第四列，也就是第一次访问2的时候，当前内存中有7 0 1 三个页面，然后用这三个页面挨个往后数，最后出现的那个页面，就是要被置换出去的页面，所以置换出7，将2放在内存块1的位置。往后每次缺页都按照这个方法确定置换出的页面。</p>
<p>最佳置换算法可以保证最低的缺页率，但是进程执行过程中才能知道接下来会访问到哪个位置页面。操作系统无法提前预判页面访问序列，所以这种算法实际无法实现。</p>
<h2 id="3-2-先进先出置换算法FIFO"><a href="#3-2-先进先出置换算法FIFO" class="headerlink" title="3.2 先进先出置换算法FIFO"></a>3.2 先进先出置换算法FIFO</h2><p>很好理解，每次置换出去的页面都是最早进入内存的页面。实现方法也很简单，将调入内存的页面根据调入顺序排成一个队列，需要换出页面时选择队头页面即可，队列最大长度取决于系统为进程分配了多少个内存块。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628235917.png" alt="image.png"></p>
<p>这个图十分好理解，而且很有规律，反正就是依次往后按顺序置换就是了。</p>
<p>这种置换算法可能有个异常：Belady 异常：当为进程分配的内存块增多时，缺页次数不减反增。只有FIFO 算法会出现这种异常，另外，这种算法虽然实现简单，但是算法与进程的实际运行时的规律不适应，因此算法性能很差。</p>
<h2 id="3-3-最近最久未使用置换算法LRU"><a href="#3-3-最近最久未使用置换算法LRU" class="headerlink" title="3.3 最近最久未使用置换算法LRU"></a>3.3 最近最久未使用置换算法LRU</h2><p>每次淘汰的页面都是最近最久未使用的页面。实现方法也简单，页表中加一项访问字段，该字段记录该页面自上次被访问以来所经历的时间t。每当要淘汰一个页面时，选择现有页面中t最大的。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230629064833.png" alt="image.png"></p>
<p>怎么算呢，和前面的OPT一样的思路，在访问3号页面的时候需要调入页面，此时内存中有1、8、7、2 四个页面，那就从3开始往前数，这四个数字最晚出现的那个就是最近最久未使用的，淘汰即可。这里从3往前数分别是8、1、2、7，7最后出现，所以淘汰7号页面。</p>
<p>这种算法需要专门的硬件支持，虽然算法性能很好，但是实现困难，开销大。</p>
<h2 id="3-5-时钟置换算法CLOCK"><a href="#3-5-时钟置换算法CLOCK" class="headerlink" title="3.5 时钟置换算法CLOCK"></a>3.5 时钟置换算法CLOCK</h2><p>也叫最近未用算法NRU，分为两种：简单的CLOCK算法和改进型CLOCK算法。</p>
<h3 id="3-5-1-简单的时钟置换算法"><a href="#3-5-1-简单的时钟置换算法" class="headerlink" title="3.5.1 简单的时钟置换算法"></a>3.5.1 简单的时钟置换算法</h3><p>为每个页面设置一个访问位，再将内存中的页面都通过链接指针连接成一个循环队列。当某个页被访问时，其访问位时1。当要淘汰一个页面时，只需要检查页的访问位。如果是0，则该页换出；如果是1，则将其改为0，暂不换出，继续顺着循环队列检查下一个页面。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230629065651.png" alt="image.png"></p>
<p>如果第一轮扫描所有页面的访问位都是1，第二轮扫描肯定能扫到了。</p>
<p>假设系统为某个进程分配了5个内存块，并考虑到有以下页面号引用串：1，3，4，2，5，6，3，4，7.</p>
<p>首先一上来 1，3，4，2，5 五个页面会组成一个循环链表：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230629070308.png" alt="image.png"></p>
<p>然后访问6号页面的时候就会开始选择一个页面淘汰，从1号页面扫描到5号页面，访问位都是1，全部改为0后开始第二轮扫描，发现1的访问位是0，则换出1号页面，将6号页面加载进来，访问位设为1。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230629070501.png" alt="image.png"></p>
<p>然后访问3，4，7号页面。3号和4号页面再次访问，所以给访问位设为1，访问7号页面时需要置换，则从3号页面开始扫描，3号和4号的访问位刚刚被设为1，所以暂时不淘汰并访问位设为0，最终淘汰2号页面，将7号页面加载。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230629070703.png" alt="image.png"></p>
<p>我们会发现他的淘汰策略就像时钟一样一直在转圈扫描，所以这种算法就叫时钟置换算法。</p>
<h3 id="3-5-2-改进型时钟置换算法"><a href="#3-5-2-改进型时钟置换算法" class="headerlink" title="3.5.2 改进型时钟置换算法"></a>3.5.2 改进型时钟置换算法</h3><p>这种算法还考虑了页面是否被修改过。如果淘汰的页面没有被修改过，是不需要往外存里面回写的，因此在页表里面加一个修改位，修改位&#x3D;0，说明页面没有被修改，修改位&#x3D;1则修改过。根据（访问位，修改位）来决定是否淘汰。</p>
<p>算法规则：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230629071456.png" alt="image.png"></p>
<p>还是挺好理解的。</p>
<h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230629071520.png" alt="image.png"></p>
<h1 id="4-页面分配策略"><a href="#4-页面分配策略" class="headerlink" title="4. 页面分配策略"></a>4. 页面分配策略</h1><h2 id="4-1-页面分配、置换策略"><a href="#4-1-页面分配、置换策略" class="headerlink" title="4.1 页面分配、置换策略"></a>4.1 页面分配、置换策略</h2><p>首先说一个概念：驻留集：请求分页存储管理中给进程分配的物理块的集合；说白了就是进程持有的全部内存块。</p>
<p>页面分配策略有两种：</p>
<ul>
<li>固定分配：操作系统为每个进程分配一组固定数目的物理块，进程运行期间不再改变，也就是驻留集大小不变。</li>
<li>可变分配：很好理解，进程运行期间视情况修改物理块数目，也就是驻留集大小可变。</li>
</ul>
<p>页面置换策略也有两种：</p>
<ul>
<li>局部置换：一个进程只能将自己进程的页面置换出内存</li>
<li>全局置换：操作系统可以将空闲的内存块分配给缺页进程，也可以将其他进程的内存块置换到外存，在跟配给缺页进程。</li>
</ul>
<p>两种分配、置换策略组合，得到三种模式：</p>
<table>
<thead>
<tr>
<th></th>
<th>局部置换</th>
<th>全局置换</th>
</tr>
</thead>
<tbody><tr>
<td>固定分配</td>
<td>Y</td>
<td>-</td>
</tr>
<tr>
<td>可变分配</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
<p>三种策略具体如下，太多了直接看图吧，还算好理解：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230629073646.png" alt="image.png"></p>
<h2 id="4-2-如何调入页面"><a href="#4-2-如何调入页面" class="headerlink" title="4.2 如何调入页面"></a>4.2 如何调入页面</h2><p>两种办法：</p>
<ul>
<li>预调页策略：根据局部性原理，访问一个页的话，附近的页最近也可能被访问到。所以一次调入若干个相邻的页面可能比调入一个页面更高效。但是如果预先调入的页面没有被使用，则又是低效的。因此可以预测不久后会用到的页面将他们一批调入内存，但是预测率只有50%左右。所以这种策略主要用于进程首次调入内存，由程序猿制定应该先调入哪些部分。核心是运行前调入。</li>
<li>请求调页策略：这个就是之前说的，只有在运行期间发现缺页才会将页面调入内存。这种策略调入的页面肯定会被访问到，但是每次只能调入一个页面，因此IO开销大。运行时调入。</li>
</ul>
<h2 id="4-3-从哪里调入页面"><a href="#4-3-从哪里调入页面" class="headerlink" title="4.3 从哪里调入页面"></a>4.3 从哪里调入页面</h2><p>我们之前学进程挂起的时候学过磁盘中有一块地方叫对换区，里面数据连续存储，IO速度更快，所以围绕对换区，有三种办法：</p>
<ol>
<li>如果磁盘对换区空间够的话，在进程运行前就会将数据从文件区复制到对换区，往后的调页和页面置换都会在对换区完成</li>
<li>对换区空间不够，则不会被修改的数据直接从文件区调入内存，毕竟不需要回写，下次使用仍旧从文件区调入，需要被修改的数据一开始也是从文件区调入，但是页面置换会置换到交换区，下次再从置换去调页。</li>
<li>UNIX方式：运行前所有文件放在文件区，故未使用过的页面都可以从文件区调入。若被使用过的页面需要换出，则回写到交换区，下次再从交换区调入。</li>
</ol>
<h2 id="4-4-抖动（颠簸）现象"><a href="#4-4-抖动（颠簸）现象" class="headerlink" title="4.4 抖动（颠簸）现象"></a>4.4 抖动（颠簸）现象</h2><p>刚刚调入的页面马上又被换出内存，刚刚被换出的页面马上又被调入，这种频繁的调度行为称为抖动。主要原因就是进程频繁访问的页面数目高于实际可用的物理块，简单说就是物理块分配少了。</p>
<h2 id="4-5-工作集"><a href="#4-5-工作集" class="headerlink" title="4.5 工作集"></a>4.5 工作集</h2><p>上面的问题，如果分配的物理块少，会发生抖动，如果多了，可能造成浪费，所以提出了工作集的概念。</p>
<p>和驻留集类似，驻留集：给进程分配的所有物理块的集合。工作集：在某段时间内，进程实际访问页面的集合。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230630082003.png" alt="image.png"></p>
<h2 id="4-6-总结"><a href="#4-6-总结" class="headerlink" title="4.6 总结"></a>4.6 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230630082036.png" alt="image.png"></p>
<h1 id="5-内存映射文件"><a href="#5-内存映射文件" class="headerlink" title="5. 内存映射文件"></a>5. 内存映射文件</h1><h2 id="5-1-传统文件读写方式"><a href="#5-1-传统文件读写方式" class="headerlink" title="5.1 传统文件读写方式"></a>5.1 传统文件读写方式</h2><p>传统读文件方式相当复杂，假设有一个文件 index.txt，磁盘里面都是分块存的，所以文件也被分成了好几个块放在磁盘。读取的顺序如下：</p>
<ul>
<li>open 系统调用：打开文件</li>
<li>seek 系统调用：将读写指针移到某个位置，比如移到了第二个磁盘块的位置</li>
<li>read 系统调用：从读写指针位置读入多个数据放入内存，比如将第二个磁盘块调入内存</li>
<li>然后就可以访问内存读取文件</li>
<li>如果在内存中修改文件的话，最后要使用 write 系统调用，根据读写指针将内存中的制定数据写回磁盘</li>
</ul>
<h2 id="5-2-内存映射文件"><a href="#5-2-内存映射文件" class="headerlink" title="5.2 内存映射文件"></a>5.2 内存映射文件</h2><p>内存映射文件可以让读写文件变得更简单，操作文件的时候，会将文件在磁盘中的位置映射到进程的虚拟内存上，但不会真正将文件加载到内存。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230630103536.png" alt="image.png"></p>
<p>当我们真正访问1号地址的时候，就会发生缺页异常，操作系统就会自动将磁盘中的内存调入内存。如果我们要修改文件内容，直接修改内存中的数据即可，结束后操作系统会自动将修改过的内存块回写到磁盘。</p>
<p>流程如下：</p>
<ul>
<li>open 系统调用：打开文件</li>
<li>mmap 系统调用：将文件映射到进程的虚拟地址空间</li>
</ul>
<p>然后我们就可以以访问内存的方式访问文件数据，文件数据的读入和写出都由操作系统自动完成。进程关闭文件时，操作系统自动将文件被修改的数据写回磁盘。</p>
<p>同时，内存映射文件还可以实现文件共享。两个进程访问一个文件，两个进程的虚拟存储空间都会映射这个文件，两个进程的虚拟空间会通过页表映射到同一块物理内存。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230630104129.png" alt="image.png"></p>
<h2 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230630104147.png" alt="image.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/30/08-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hexo_avatar.jpeg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PtheF-Hexo-Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/30/08-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">08.内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-30 11:06:39 / 修改时间：11:13:50" itemprop="dateCreated datePublished" datetime="2023-06-30T11:06:39+08:00">2023-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="1-内存基础知识"><a href="#1-内存基础知识" class="headerlink" title="1. 内存基础知识"></a>1. 内存基础知识</h1><h2 id="1-1-什么是内存"><a href="#1-1-什么是内存" class="headerlink" title="1.1 什么是内存"></a>1.1 什么是内存</h2><p>内存可存放数据。程序执行钱需要先放到内存中才能被 CPU 处理，以此缓和 CPU 和硬盘之间的速度矛盾。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620214937.png" alt="image.png"><br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620215209.png" alt="image.png"></p>
<h2 id="1-2-进程运行的基本原理"><a href="#1-2-进程运行的基本原理" class="headerlink" title="1.2 进程运行的基本原理"></a>1.2 进程运行的基本原理</h2><h3 id="1-2-1-指令工作原理"><a href="#1-2-1-指令工作原理" class="headerlink" title="1.2.1 指令工作原理"></a>1.2.1 指令工作原理</h3><p>假设我们现在要执行一条语句：<code>x = x + 1</code>，这条语句可能就会被编译成下面三条CPU指令：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621095105.png" alt="image.png"></p>
<ul>
<li>指令一：数据传送，将内存中 01001111 地址（X变量的位置，值为10）的数据，传送到 00000011 寄存器</li>
<li>指令二：加速指令，将寄存器 00000011 中的数据 加上 00000001</li>
<li>指令三：数据传送，将寄存器 00000011 中的数据，传送给内存 01001111 地址（将 X 的值更新到内存）</li>
</ul>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621095349.png" alt="image.png"></p>
<p>这里我们假设地址从0开始，那么指令中的所有地址都是真实的“物理地址”。那如果指令不是从 0 开始的，如何应对？</p>
<h3 id="1-2-2-逻辑地址-VS-物理地址"><a href="#1-2-2-逻辑地址-VS-物理地址" class="headerlink" title="1.2.2 逻辑地址 VS 物理地址"></a>1.2.2 逻辑地址 VS 物理地址</h3><p>为了简化理解，我们默认操作系统会给进程分配一片连续的内存空间。如果程序所在的物理地址起始位置不是0，那么指令中的地址如何修改？</p>
<p>可以这么着，指令中的地址不是真实的物理地址，而是一种相对地址，相对于当前进程在物理地址中的起始位置的一种偏移量。比如：指令要求从内存的 79 地址处拿到x，这个79是进程的起始地址往后数 79 个，而非真正的物理79。如果进程起始地址为100，那么x的位置就是 100 + 79。</p>
<h3 id="1-2-3-如何实现地址转换"><a href="#1-2-3-如何实现地址转换" class="headerlink" title="1.2.3 如何实现地址转换"></a>1.2.3 如何实现地址转换</h3><p>计算机中可执行文件也叫装入模块，将装入模块装入内存的时候如何将地址进行转换？这就涉及到三种装入方式：</p>
<p><strong>绝对装入</strong></p>
<p>在编译时，可以预知程序会被放入到哪个位置，那么编译器将产生绝对地址的目标代码，装入程序按照装入模块中的地址，将程序和数据装入内存。也就是说编译出来的可执行文件（装入模块）里面地址就已经写死了。</p>
<p>比如，我们已经知道程序会被装入到 100 的位置，那么编译的时候直接把 x 的位置修改成 179 物理地址即可，也就是绝对地址。这种方式只适合单道程序环境，换一台电脑这个可执行文件怕是就没法用了。</p>
<p><strong>可重定位装入</strong></p>
<p>也叫可重定位装入。编译，链接后装入模块的地址都是从0开始，指令地址中的地址都是相对于起始地址而言的逻辑地址。但是在装入模块被装入内存时会进行地址转换，根据装入的实际位置，将指令中的所有地址修改为物理地址。</p>
<p>这样有个要求：作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入作业。且作业一旦装入完成，运行期间作业不能移动，也不能申请新的内存空间。</p>
<p><strong>动态运行时装入</strong></p>
<p>也叫动态运行时装入，装入模块里面的指令是逻辑地址，装入内存后的指令同样是逻辑地址。然后会有一个重定位寄存器，记录着装入模块存放的起始位置，运行时只需要将指令中的逻辑地址和寄存器中的起始地址相加即可获取真实的物理地址。</p>
<h3 id="1-2-4-写程序到程序运行"><a href="#1-2-4-写程序到程序运行" class="headerlink" title="1.2.4 写程序到程序运行"></a>1.2.4 写程序到程序运行</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621101032.png" alt="image.png"></p>
<p>这里说一下：这个目标模块同样也是指令，然后里面的地址全都是逻辑地址，各个模块的逻辑地址相互独立。链接就是将这些目标模块整合起来，变成一个完整的逻辑地址，当然这些地址同时包含着你用到的一些库函数。最后装入我们之前已经说过了。</p>
<p>这里的链接同样有三种模式：</p>
<p><strong>静态链接</strong></p>
<p>和图里的意思一样，在程序运行之前，将各个目标模块已经库函数链接成一个完整的装入模块，以后不再拆开。</p>
<p><strong>装入时动态链接</strong></p>
<p>这种方式并不会一上来就链接，而是在装入内存时，边装入边链接。</p>
<p><strong>运行时动态链接</strong></p>
<p>运行时将逻辑地址转换为物理地址，需要设置重定位寄存器。如果运行时不需要某个目标模块，则不会加载。</p>
<h2 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621101659.png" alt="image.png"></p>
<h1 id="2-内存管理概念"><a href="#2-内存管理概念" class="headerlink" title="2. 内存管理概念"></a>2. 内存管理概念</h1><h2 id="2-1-内存的分配和回收"><a href="#2-1-内存的分配和回收" class="headerlink" title="2.1 内存的分配和回收"></a>2.1 内存的分配和回收</h2><p>操作系统要负责内存空间的分配与回收，操作系统如何记录哪些内存区域已经被分配出去，哪些空闲。进程结束后又如何回收内存空间。一个新进程来了，该将他放到哪片内存上，这都是问题。</p>
<h2 id="2-2-内存空间的扩展"><a href="#2-2-内存空间的扩展" class="headerlink" title="2.2 内存空间的扩展"></a>2.2 内存空间的扩展</h2><p>操作系统需要提供某种技术从逻辑上对内存空间进行扩充。</p>
<h2 id="2-3-地址转换"><a href="#2-3-地址转换" class="headerlink" title="2.3 地址转换"></a>2.3 地址转换</h2><p>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。这个我们之前已经说过了，也就是三种装入方式。</p>
<h2 id="2-4-内存保护"><a href="#2-4-内存保护" class="headerlink" title="2.4 内存保护"></a>2.4 内存保护</h2><p>操作系统在内存中有专门的一片空间专门用于保存操作系统的一些数据，如何避免其他进程非法访问，这就是内存保护。</p>
<h3 id="2-4-1-上下限寄存器"><a href="#2-4-1-上下限寄存器" class="headerlink" title="2.4.1 上下限寄存器"></a>2.4.1 上下限寄存器</h3><p>CPU 会提供一对上下限寄存器，分别存放进程的上下限地址。进程的指令要访问地址时，CPU 就会首先检查地址是否越界。</p>
<h3 id="2-4-2-重定位寄存器"><a href="#2-4-2-重定位寄存器" class="headerlink" title="2.4.2 重定位寄存器"></a>2.4.2 重定位寄存器</h3><p>和上面这个也很类似，CPU 提供两个寄存器：重定位寄存器（基址寄存器），保存进程的起始物理地址；界地址寄存器（限长寄存器），记录指令中允许的最大偏移地址。执行指令时，首先检查逻辑地址是否在最大偏移地址之内，合法则通过重定位寄存器找到真实的物理地址进行执行。</p>
<h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621102838.png" alt="image.png"></p>
<h1 id="3-覆盖与交换"><a href="#3-覆盖与交换" class="headerlink" title="3. 覆盖与交换"></a>3. 覆盖与交换</h1><h2 id="3-1-覆盖技术"><a href="#3-1-覆盖技术" class="headerlink" title="3.1 覆盖技术"></a>3.1 覆盖技术</h2><p>前朝的计算机内存通常非常的小，所以经常出现内存不够用的情况，如何将一个更大的程序装入内存成功运行？这就提出了覆盖技术。</p>
<p>简单说，内存会给进程提供固定区和覆盖区，固定区存储进程的核心部分，覆盖区存储不可能被同时访问的程序段。一个模块不用了就可以调出内存腾地方。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621103405.png" alt="image.png"></p>
<h2 id="3-2-交换技术"><a href="#3-2-交换技术" class="headerlink" title="3.2 交换技术"></a>3.2 交换技术</h2><p>核心思想和之前说到的中级调度（挂起）很像：内存空间紧张时，系统将内存中某些进程暂时换出内存，把内存中某些已具备运行条件的进程换入内存（进程在内存和磁盘间动态调度）。</p>
<p>再说一句：即便进程被挂起，PCB 也会被记录到内存的挂起队列中，PCB 会记录进程在磁盘中的挂起位置，所以 PCB 一定是常驻内存。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621103801.png" alt="image.png"></p>
<p>之前的七状态模型再拿过来看一眼。</p>
<h3 id="3-2-1-换出位置"><a href="#3-2-1-换出位置" class="headerlink" title="3.2.1 换出位置"></a>3.2.1 换出位置</h3><p>外存的什么位置用来保存被换出的进程？具有交换功能的操作系统中，通常把磁盘空间分为“文件区”和“交换区”。</p>
<p>文件区只负责存文件，主要追求存储空间的利用率，因为文件区空间的管理<font color = 'red'>采用离散分配方式</font>。而交换区主要追求的就是交换速度，所以采用<font color = 'red'>连续分配方式</font>，总之就是交换区比文件区更快。</p>
<h3 id="3-2-2-什么时候交换"><a href="#3-2-2-什么时候交换" class="headerlink" title="3.2.2 什么时候交换"></a>3.2.2 什么时候交换</h3><p>许多进程运行而且内存吃紧的时候进行交换，当系统负荷降低就暂停交换。比如：进程运行时进场发生缺页，则内存吃紧，就可以换出一些进程。如果缺页率显著下降，则暂停换出</p>
<h3 id="3-2-3-换出哪些进程"><a href="#3-2-3-换出哪些进程" class="headerlink" title="3.2.3 换出哪些进程"></a>3.2.3 换出哪些进程</h3><p>优先换出阻塞进程；优先级低的进程；为了防止优先级低的继承在被调入内存后很快又被换出，有些系统还会考虑进程在内存的驻留时间。</p>
<h2 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621104505.png" alt="image.png"></p>
<h1 id="4-连续分配管理方式"><a href="#4-连续分配管理方式" class="headerlink" title="4. 连续分配管理方式"></a>4. 连续分配管理方式</h1><p>第四和第五章开始说一下内存管理的重点：内存分配与回收。分为两类：连续分配管理和非连续分配管理。</p>
<p>连续分配指的就是：系统为用户进程分配的必须是一个连续的内存空间。其中又分为三种方式。</p>
<h2 id="4-1-单一连续分配"><a href="#4-1-单一连续分配" class="headerlink" title="4.1 单一连续分配"></a>4.1 单一连续分配</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621105053.png" alt="image.png"></p>
<h2 id="4-2-固定分区分配"><a href="#4-2-固定分区分配" class="headerlink" title="4.2 固定分区分配"></a>4.2 固定分区分配</h2><p>就是升级版的单一连续分配，将整个用户区分为多个小分区，每个小分区只能放入一个进程，或者说一道作业，这就是最早的最简单的一种可以运行多道程序的内存管理方式。内存的分区数被预先划分。</p>
<p>在某些特定场景下，分区的大小全都相等，比如炼钢厂，每个钢炉的控制程序都一样，就可以将内存分为多个大小相等的区放入控制程序。</p>
<p>分区的大小也可以不相等，增加了灵活性。根据常在系统中运行的作业大小情况来划分。可以划分多个小分区，适量中分区，少量大分区。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621105655.png" alt="image.png"></p>
<h2 id="4-3-动态分区分配"><a href="#4-3-动态分区分配" class="headerlink" title="4.3 动态分区分配"></a>4.3 动态分区分配</h2><p>也叫可变分区分配，这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态建立分区，让分区的大小正好适合进程的需要，因此系统分区的大小和数目可变。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621110137.png" alt="image.png"><br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621110210.png" alt="image.png"></p>
<p>最后一个问题：如何分配和回收。</p>
<p>这个其实很简单，就是要更新空闲分区表或者空闲分区链。分配的时候看有没有填满某个空闲分区，以此决定是更新该分区的参数还是直接删除该空闲分区。回收的时候，看前后是否有相邻的空闲分区，以此来决定是合并空闲分区还是添加空闲分区。如果是要增加一个空闲分区，这个空闲分区排在哪个位置由动态分区分配算法来决定。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621110917.png" alt="image.png"></p>
<p>紧凑技术就是把内存中的各个进程往紧拼一拼，将外部碎片整理起来。</p>
<p>说一下第二个问题：</p>
<ul>
<li>肯定是要用动态运行时装入方式，那么肯定要用到重定位寄存器</li>
<li>紧凑之后，肯定要修改进程的起始地址，这个地址原本是存在重定位寄存器中，但是在进程调度的时候之前说过，会将各种寄存器保存到 PCB 中。所以这个时候进程的起始地址肯定是在 PCB 里面，我们只需要修改 PCB 中的起始地址即可。</li>
</ul>
<h2 id="4-5-分配方式总结"><a href="#4-5-分配方式总结" class="headerlink" title="4.5 分配方式总结"></a>4.5 分配方式总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230621111411.png" alt="image.png"></p>
<h2 id="4-6-动态分区分配算法"><a href="#4-6-动态分区分配算法" class="headerlink" title="4.6 动态分区分配算法"></a>4.6 动态分区分配算法</h2><p>这个东西比较多，所以单独放一起。上面说过了动态分区分配策略，里面有一个空闲分区表，现在一个新的进程来了，该把他放在哪个空闲分区？这就是分配算法要解决的问题。</p>
<h3 id="4-2-1-首次适应算法"><a href="#4-2-1-首次适应算法" class="headerlink" title="4.2.1 首次适应算法"></a>4.2.1 首次适应算法</h3><p>这个很简单，空闲表或者空闲链会根据地址从低到高排列，一个新的进程来了以后，会从头开始，依次寻找满足条件的空闲分区，一旦找到直接分配。分配完成以后修改空闲分区结构。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623111452.png" alt="image.png"></p>
<p>看图可知，空闲表和空闲链就是按照内存从上到下维护空闲空间。</p>
<h3 id="4-2-2-最佳适应算法"><a href="#4-2-2-最佳适应算法" class="headerlink" title="4.2.2 最佳适应算法"></a>4.2.2 最佳适应算法</h3><p>因为动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片空间。所以为了保证“大进程”来了以后有足够的空间分配，所以该算法会尽可能优先使用小空闲分区。</p>
<p>空闲分区表或者链会按照空闲分区的大小从小到大依次排列，当一个进程来了以后同样是从头开始找，第一个满足条件的分区就会是最小分区。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623111907.png" alt="image.png"></p>
<p>缺点：内存中会遗留很多非常小的外部碎片，这些外部碎片很难被利用。</p>
<h3 id="4-2-3-最坏适应算法"><a href="#4-2-3-最坏适应算法" class="headerlink" title="4.2.3 最坏适应算法"></a>4.2.3 最坏适应算法</h3><p>和最佳相反，为了不留下很多难以利用的外部碎片，这种算法会优先分配大的空闲分区。</p>
<p>空闲分区数据结构按照空闲分区大小从大到小排列，进程来了以后也是从头开始找，分配第一个满足要求的分区。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623112131.png" alt="image.png"></p>
<p>这种的缺点就显而易见了：大进程来了以后可能就会导致内存分区不够用。</p>
<h3 id="4-2-4-邻近适应算法"><a href="#4-2-4-邻近适应算法" class="headerlink" title="4.2.4 邻近适应算法"></a>4.2.4 邻近适应算法</h3><p>这种算法是为了解决首次适应算法的一个小问题：首次适应算法优先将低地址空闲分区分配出去，这就会导致低地址部分出现很多小的外部碎片。而下一次分配还会扫描低地址的这些碎片，没有必要。</p>
<p>所以临近适应算法就会从上一次分配的位置开始往下找，而不是从开头。数据结构仍然是按照地址从低到高排序，如果是空闲分区链的话可以设计成一个双向循环链表。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623112644.png" alt="image.png"></p>
<p>现在要分配一个 5M 的进程，就会从链头开始找，发现 6 这个空闲分区可以分配，然后进行分配空间，将链表修改为 4 -&gt; 1 -&gt; 10 -&gt; 4。</p>
<p>下一次一个3M的进程来了，就会从 1 的位置开始找，然后找到了 10 这个空闲分区，进行分配，修改链表为 4 -&gt; 1 -&gt; 7 -&gt; 4。</p>
<p>这样的一个优点就是：空闲分区表不需要重新排列。缺点就是降低了低地址部分小分区的利用率，不利于保存高地址部分的大分区。</p>
<h3 id="4-2-4-总结"><a href="#4-2-4-总结" class="headerlink" title="4.2.4 总结"></a>4.2.4 总结</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623113100.png" alt="image.png"></p>
<h1 id="5-非连续分配管理方式"><a href="#5-非连续分配管理方式" class="headerlink" title="5. 非连续分配管理方式"></a>5. 非连续分配管理方式</h1><h2 id="5-1-基本分页存储管理"><a href="#5-1-基本分页存储管理" class="headerlink" title="5.1 基本分页存储管理"></a>5.1 基本分页存储管理</h2><p>将内存分为一个个大小相等的分区，假设每个分区4kb，每个分区就是一个<font color = 'red'>页框（页帧，内存快，物理块，物理页）</font>。然后每一个页框都会给编上号，这个号就叫<font color='red'>页框号</font>。从 0 开始。</p>
<p>每个进程的逻辑地址空间（也就是存放指令的那一部分）也会被划分为大小相等的一个个分区，每个分区就叫<font color='red'>页（页面）</font>。同理有一个编号：<font color='red'>页号</font>。从 0 开始。</p>
<p>操作系统就会以页框为单位给各个进程分配内存空间。进程的每个页面分别放入一个页框中，进程的页面和内存的页框一一对应。整个进程在内存中对应的页框不一定会连续存储。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623114108.png" alt="image.png"></p>
<p>对应的，操作系统为了知道每个进程的页面在内存中的存放位置，就会给每个进程创建一张 <font color = 'red'>页表</font>。页表通常也会存在 PCB 中。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623114348.png" alt="image.png"></p>
<h3 id="5-1-1-页表占用空间大小"><a href="#5-1-1-页表占用空间大小" class="headerlink" title="5.1.1 页表占用空间大小"></a>5.1.1 页表占用空间大小</h3><p>假设内存 4GB，每个页框4KB，那么：</p>
<p>$$ 4GB &#x3D; 2^2 * 2^{20} &#x3D; 2 ^ {32} $$</p>
<p>$$ 4KB &#x3D; 2 ^ 2 * 2 ^ {10} &#x3D; 2 ^ {12} $$<br>$$ 4GB &#x2F; 4KB &#x3D; 2^{20} $$</p>
<p>所以内存中总共有 2 ^ 20 个内存块，想要编号就需要 24bit 也就是 3Byte 来存储页框号。</p>
<p>页号呢？页号不需要占用空间，因为页号从0开始，类似于数组下标，所以是隐藏的。因此，每个表项占 3B，存储整个表就需要 3 * (n+1) 字节。但是，页表中记录的仅仅是页框号，而不是页框的物理地址，如果想要得到物理地址还需要 页框号 * 页框大小。</p>
<h3 id="5-1-2-如何地址转换"><a href="#5-1-2-如何地址转换" class="headerlink" title="5.1.2 如何地址转换"></a>5.1.2 如何地址转换</h3><p>之前说：进程如果在内存中被连续分配，那么指令中的地址就可以是相对于当前内存的一个偏移量。而在页存储中，如何记录指令中的地址？虽然各个页面是离散存放的，但是页面内部是连续的，所以指令中的逻辑地址A，就需要：</p>
<ul>
<li>确定逻辑地址A对应的页号P</li>
<li>确定P号页面在内存中的其实地址（需要查找页表，也就是页框号 * 页框大小）</li>
<li>确定逻辑地址A的页内偏移量 W</li>
</ul>
<p>然后，逻辑地址A对应的物理地址 &#x3D; P号页面在内存中的起始地址 + 页内偏移量 W。</p>
<p><strong>如何确定逻辑地址对应的页号和页内偏移量？</strong></p>
<p>假设：页面大小 50B。进程的逻辑地址空间是 200B，则逻辑地址110对应的页号和页内偏移量是多少？</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623121352.png" alt="image.png"></p>
<p>如果页面大小是2的整数次方的话，这个事就会变的比较简单。比如，一个页面的大小是 4KB，计算机用 32 个比特位来表示逻辑地址。那么 4KB &#x3D; 2^12 B，需要12个比特位来表示这些存储单元（每个存储单元一个Byte），则：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0号页面逻辑地址范围 0 - 4095：</span><br><span class="line">00000000000000000000｜000000000000 - 00000000000000000000｜111111111111</span><br><span class="line"></span><br><span class="line">1号页面逻辑地址范围 4096 - 8191：</span><br><span class="line">00000000000000000001｜000000000000 - 00000000000000000001｜111111111111</span><br><span class="line"></span><br><span class="line">2号页面逻辑地址范围 8192 - 12287：</span><br><span class="line">00000000000000000010｜000000000000 - 00000000000000000010｜111111111111</span><br></pre></td></tr></table></figure>
<p>我们就可以发现，多少号逻辑地址，就是把它化成二进制，然后前20位就是他的页号，后12位就是他的页内偏移量。</p>
<p>然后，逻辑地址要转化成物理地址，如果这个计算机的物理地址也适用32个bit来表示的话，那么页框的划分就和上面几乎一样，比如一条逻辑地址在一号页面，偏移地址为000000000011，一号页面分配对应九号页框，9的二进制是 1001，那么这条逻辑地址的物理地址就是：<code>00000000000000001001｜000000000011</code>。也就是页框号的二进制直接拼接页内偏移地址。</p>
<p>如果不满足这种特性的话，就需要去算页框的起始地址。</p>
<p>综上说的，我们可以吧逻辑地址看作这种结构：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623160805.png" alt="image.png"></p>
<h3 id="5-1-3-总结"><a href="#5-1-3-总结" class="headerlink" title="5.1.3 总结"></a>5.1.3 总结</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623160851.png" alt="image.png"></p>
<h2 id="5-2-基本地址变换机构"><a href="#5-2-基本地址变换机构" class="headerlink" title="5.2 基本地址变换机构"></a>5.2 基本地址变换机构</h2><p>这个机构是顺着上一部分说的，上面说到了逻辑地址转化为物理地址可以怎么转，这里就是说具体哪个部件负责干这个事儿。</p>
<p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。通常会在系统中设置一个<strong>页表寄存器（PRT）</strong>，存放页表的内存中的起始地址F和页表长度M。进程未执行时，页表的起始地址和页表长度存放在PCB 中，当进程被调度时，操作系统内核会把他们放到页表寄存器。</p>
<h3 id="5-2-1-地址转换流程"><a href="#5-2-1-地址转换流程" class="headerlink" title="5.2.1 地址转换流程"></a>5.2.1 地址转换流程</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623161519.png" alt="image.png"></p>
<p>文字说一下：</p>
<ol>
<li>首先要计算逻辑地址A在哪一页的哪个偏移量上，这个上一节就说过了。得出页号 P 和偏移量 W。</li>
<li>比较页号 P 和 页表长度 M。M就是说页表总共有几项，如果发现 P &gt;&#x3D; M，则发生越界中断，否则继续执行（如果 P &#x3D;= M 也不行）</li>
<li>根据页表寄存器中的页表起始地址 F 和页号 P 就可以访问到页表：<code>页表项地址 = 页表起始地址 F + 页号 P * 页表项长度（页框号所占字节）</code>，这个地址就可以得到 b。</li>
<li>顺着 b 就可以算出具体的地址：逻辑地址A的物理地址 &#x3D; b * 页面大小 + 页面偏移量。</li>
</ol>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623162703.png" alt="image.png"></p>
<h3 id="5-2-2-页表项长度"><a href="#5-2-2-页表项长度" class="headerlink" title="5.2.2 页表项长度"></a>5.2.2 页表项长度</h3><p>这个之前讲过了，如果内存 4G，一个页是 4K，总共就有2^20 个页框，也就需要20个bit来表示页框号，所以操作系统会给页框号划分 3B。</p>
<p>页表这个结构最后也是会存储在内存的页框中的，一个页框4K，但是一个页表项3B，那么一个页框可以存储1365个页表项， 4096 % 3 &#x3D; 1，也就是说最后这个页框会产生 1B 的内部碎片。</p>
<p>如果我们要计算1365号页表项的话，由于上面产生了1B的碎片，所以1365号页表项的地址就要在计算结果的基础上 + 1。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623163426.png" alt="image.png"></p>
<p>解决办法就是，页表项也就是页框号，我们直接给他划 4B 的空间，让页表能把页框填满。如果题目中要问最小的页表项可以是多少，还按 3B 来。</p>
<h3 id="5-2-3-总结"><a href="#5-2-3-总结" class="headerlink" title="5.2.3 总结"></a>5.2.3 总结</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623163653.png" alt="image.png"></p>
<p>这里提到一个概念：页式管理中地址是一维的，就是说 CPU 想要知道逻辑地址对应的物理地址，只需要知道逻辑地址的值即可。</p>
<h2 id="5-3-快表"><a href="#5-3-快表" class="headerlink" title="5.3 快表"></a>5.3 快表</h2><p>快表就是基本地址变换结构的改进版本，可以让地址转换更快。快表也叫联想寄存器（TLB），是一种访问速度比内存快很多的高速缓存（注意，这可不是内存，而是在 CPU 内部的一种缓存），用来存放最近访问的页表项的副本，可以加快地址变换的速度。因为访问高速缓存比访问内存块，所以叫快表，对应的内存中的页表常叫慢表。</p>
<p>由于快表成本高，存储空间小，所以不能存放完整的页表。</p>
<h3 id="5-3-1-地址变换流程"><a href="#5-3-1-地址变换流程" class="headerlink" title="5.3.1 地址变换流程"></a>5.3.1 地址变换流程</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623164440.png" alt="image.png"></p>
<p>这玩意儿，就是一种缓存，具体流程如下：</p>
<ol>
<li>第一次访问 0-0 地址，除去基本流程外，会去看快表里面有没有页号为0的记录，发现没有，未命中。</li>
<li>按照慢表的思路，去内存里面找到页表，然后发现页号0对应页框600，然后将 0-600 复制到快表中一份。然后访问物理地址。</li>
<li>第二次访问0-4地址，去看快表，发现有了0号页表的记录，0号页表指向600号页框，那他就会拿着600直接去和偏移量拼接得到真实的物理地址，然后访问。</li>
<li>第三次访问0-8，同样的道理，不说了。</li>
</ol>
<p>如果快表存满了，会按照一种算法进行替换，这种算法后面会说。由于局部性原理，快表的命中率可以达到 90% 以上。假设访问一次快表1us，访问一次内存100us，那么平均访问内存时间 ：</p>
<p>$$<br>(1 + 100) * 0.9 + (1 + 100 + 100) * 0.1 &#x3D; 111us<br>$$</p>
<p>1 + 100 就是访问快表然后访问页框，1 + 200 就是先访问快表没命中，然后访问慢表，再访问页框。有些系统支持快表慢表同时访问，那么 （1+100+100）可以优化成 （100 + 100），最后的时间就是 110.9us。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623170308.png" alt="image.png"></p>
<h3 id="5-3-2-局部性原理"><a href="#5-3-2-局部性原理" class="headerlink" title="5.3.2 局部性原理"></a>5.3.2 局部性原理</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623170418.png" alt="image.png"></p>
<h3 id="5-3-3-总结"><a href="#5-3-3-总结" class="headerlink" title="5.3.3 总结"></a>5.3.3 总结</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623170441.png" alt="image.png"></p>
<h2 id="5-4-两级页表"><a href="#5-4-两级页表" class="headerlink" title="5.4 两级页表"></a>5.4 两级页表</h2><p>假设内存 4GB，页面大小 4KB，页表项长度 4B。则系统会将内存划分为 2^20 个页框，相应的用户进程最多有 2^20页，进而一个进程的页表中，最多有2^20个页表项，一个页表最大需要 2^22 B，共需要2^10个页框存储该页表。</p>
<p>然后，虽然说进程所对应的页框不一定要连续存放，但是表页却需要连续存放，因为我们要顺着页表找页框号，所以内存就需要给这个页表分配 1024 个页框。而且，进程在一段时间内，只需要用到几个页框，其他页框可能并不需要。</p>
<p>所以问题：</p>
<ul>
<li>页表必须连续存放，如果页表很大，则需要占用很多连续的页框</li>
<li>没有必要让页表常驻内存，因为一段时间内可能只需要访问某几个特定的页框。</li>
</ul>
<h3 id="5-4-1-两级页表设计"><a href="#5-4-1-两级页表设计" class="headerlink" title="5.4.1 两级页表设计"></a>5.4.1 两级页表设计</h3><p>为了解决上面的第一个问题，就出现了两级页表。之前，我们是将进程的逻辑内存空间按照页划分，这回我们将页表按同样的形式进行划分。</p>
<p>如果计算机内存 4GB，页表项 4B，页面大小 4KB，则一个页面可以装入 1024 个页表项，我们就可以按照1024将页表进行划分，然后将这些小页表离散的存储到内存中。然后，为这些小页表建立上层的页目录表（顶级页表或者叫外层页表）：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623214709.png" alt="image.png"></p>
<h3 id="5-4-2-如何地址变换"><a href="#5-4-2-如何地址变换" class="headerlink" title="5.4.2 如何地址变换"></a>5.4.2 如何地址变换</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623215054.png" alt="image.png"></p>
<p>这个顺着图看就行了：</p>
<ol>
<li>根据一级页号 0 去页目录表中找到了页框号3，也就是说二级页表存在了3号页框也就是起始地址为12KB的位置。</li>
<li>读取三号页框，得到了二级页表，根据二级页号 1 找到了页框号4，就是说我们要访问的地址在4号页框。</li>
<li>然后 4号页框的起始地址 4 x 4KB 加上偏移地址 111111111111 也就是 1023 得到了最终的物理地址。</li>
</ol>
<p>或者我们也可以把二级页号的哪个值理解成页框号在二级页表所在的页框中的偏移量。所以说，这里一个页面可以存 2^10 个页表项，那么二级页号就需要 10bit 来存储。</p>
<h3 id="5-4-3-如何按需访问页表"><a href="#5-4-3-如何按需访问页表" class="headerlink" title="5.4.3 如何按需访问页表"></a>5.4.3 如何按需访问页表</h3><p>这个是为了解决上面的第二个问题，这里涉及到虚拟存储技术，以后再说。可以在页表项中添加一个标志为，用于表示该页面是否已经调入内存。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623215457.png" alt="image.png"></p>
<h3 id="5-4-4-多级页表"><a href="#5-4-4-多级页表" class="headerlink" title="5.4.4 多级页表"></a>5.4.4 多级页表</h3><p>是一个例题：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623220447.png" alt="image.png"></p>
<p>这里解释一下为啥弄三级页表：题目规定各级页表的大小不能超过一个页面，一个页面只能存 1024 个页表项，也就需要 10bit 来表示偏移量。</p>
<p>假设我们让他是二级页表结构，则28bit的页号就分为了 18bit的一级页表和 10bit 的二级页表，则一级页表理论上就可以储存最多 2^18个页表项，一个页面显然存不下了，所以需要再给这个一级页表按页分层，然后上层设计更高级的目录。</p>
<h3 id="5-4-5-总结"><a href="#5-4-5-总结" class="headerlink" title="5.4.5 总结"></a>5.4.5 总结</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623220419.png" alt="image.png"></p>
<h2 id="5-5-基本分段存储管理"><a href="#5-5-基本分段存储管理" class="headerlink" title="5.5 基本分段存储管理"></a>5.5 基本分段存储管理</h2><p>这个是从进程本身出发，根据程序的自身逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序猿使用段名来编程），每段从0开始编址。进程的每个段可以在内存中不连续，但是段内是连续的。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623221313.png" alt="image.png"></p>
<p>分了段之后如何访问地址？</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623221515.png" alt="image.png"></p>
<p>系统为了找到程序的每个段在内存中的物理地址，就设计出了段表：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623221633.png" alt="image.png"></p>
<h3 id="5-5-1-地址变换"><a href="#5-5-1-地址变换" class="headerlink" title="5.5.1 地址变换"></a>5.5.1 地址变换</h3><p>这个和之前的分页存储很像，分段式系统里面同样会提供一个段表寄存器，里面存放段表地址F和段表长度M，这个东西也是存在PCB中，然后进程上 CPU 之后被放入寄存器。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623222346.png" alt="image.png"></p>
<p>这里所说的段表长度就是段长C和基址b所占的字节数。</p>
<h3 id="5-5-2-分段、分页对比"><a href="#5-5-2-分段、分页对比" class="headerlink" title="5.5.2 分段、分页对比"></a>5.5.2 分段、分页对比</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623222714.png" alt="image.png"></p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623222930.png" alt="image.png"></p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623223002.png" alt="image.png"></p>
<h3 id="5-5-3-总结"><a href="#5-5-3-总结" class="headerlink" title="5.5.3 总结"></a>5.5.3 总结</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230623223110.png" alt="image.png"></p>
<h2 id="5-6-段页式存储管理"><a href="#5-6-段页式存储管理" class="headerlink" title="5.6 段页式存储管理"></a>5.6 段页式存储管理</h2><p>其实就是分段和分页式管理，先给进程分段，然后给每个段分页，将分好的页填到内存的页框中。按照这种方法的话，逻辑地址的设计如下：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628094725.png" alt="image.png"></p>
<ul>
<li>段号规定当前地址在哪个段，同时段号的位数也规定了这个进程最多可以分多少段</li>
<li>页号规定当前地址在段内的哪个页上，页号位数规定了一个段可以分出来多少页</li>
<li>页内偏移量好理解。同时位数规定了页面大小、内存快大小</li>
</ul>
<p>所以上面这图，进程可以分2^16个段，每个段可以分4个页，每个页 2^12页就是4K大小。对于程序员来说，段是程序猿决定的。</p>
<h3 id="5-6-1-段表、页表"><a href="#5-6-1-段表、页表" class="headerlink" title="5.6.1 段表、页表"></a>5.6.1 段表、页表</h3><p>同理，系统也会给进程维护一个段表，同时每个段还要分页，所以每个段自己还有一个页表。所以段表的结构就是：段号-页表长度-当前段的页表所在的页框号。根据页框号，就可以得到这个段自己的页表，然后页表里面记录 页号-内存页框号，再得到段里面页的实际物理地址。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628095607.png" alt="image.png"></p>
<p>一个进程对应一个段表，但是每个段都会对应一个页表。</p>
<h3 id="5-6-2-地址变换"><a href="#5-6-2-地址变换" class="headerlink" title="5.6.2 地址变换"></a>5.6.2 地址变换</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628095944.png" alt="image.png"></p>
<p>我们会发现这个寻址过程，三种内存管理方式都大差不差，一个套路。</p>
<ul>
<li>首先，肯定都会提供一个寄存器，什么段表寄存器，什么页表寄存器，他们的作用就是记录这个表的起始位置和每一个表项的大小，只要有了段号或者页号，就可以根据这两个数值访问到具体的表项。</li>
<li>拿到表项以后根据需求不同的到具体的段地址或者页地址，或者是这种情况得到的是段页表。</li>
</ul>
<h3 id="4-6-3-总结"><a href="#4-6-3-总结" class="headerlink" title="4.6.3 总结"></a>4.6.3 总结</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230628100408.png" alt="image.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/30/07-%E6%AD%BB%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hexo_avatar.jpeg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PtheF-Hexo-Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/30/07-%E6%AD%BB%E9%94%81/" class="post-title-link" itemprop="url">07.死锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-30 11:06:33 / 修改时间：11:13:46" itemprop="dateCreated datePublished" datetime="2023-06-30T11:06:33+08:00">2023-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="1-死锁的概念"><a href="#1-死锁的概念" class="headerlink" title="1. 死锁的概念"></a>1. 死锁的概念</h1><p>前面的哲学家进餐就是一个典型的死锁，每个进程要申请其他进程锁住的临界资源，同时自己还占着别的进程的临界资源，就会发生死锁。</p>
<p>然后需要和饥饿，死循环区分一下：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620105802.png" alt="image.png"></p>
<h1 id="2-死锁产生的必要条件"><a href="#2-死锁产生的必要条件" class="headerlink" title="2. 死锁产生的必要条件"></a>2. 死锁产生的必要条件</h1><p>字太多了，懒得打：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620110257.png" alt="image.png"></p>
<h1 id="3-什么时候会发生死锁"><a href="#3-什么时候会发生死锁" class="headerlink" title="3. 什么时候会发生死锁"></a>3. 什么时候会发生死锁</h1><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620110332.png" alt="image.png"></p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620110439.png" alt="image.png"></p>
<h1 id="4-死锁的处理策略"><a href="#4-死锁的处理策略" class="headerlink" title="4. 死锁的处理策略"></a>4. 死锁的处理策略</h1><h2 id="4-1-静态-预防死锁"><a href="#4-1-静态-预防死锁" class="headerlink" title="4.1 静态-预防死锁"></a>4.1 静态-预防死锁</h2><p>上面说了死锁产生的四个条件：互斥条件，不剥夺条件，请求和保持条件，循环等待条件。预防就是依次把这些条件给他破坏了就行。</p>
<h3 id="4-1-1-破坏互斥条件"><a href="#4-1-1-破坏互斥条件" class="headerlink" title="4.1.1 破坏互斥条件"></a>4.1.1 破坏互斥条件</h3><p>只有对必须互斥使用的资源的争抢才会导致死锁。如果把这些互斥资源改造成共享资源，则系统不会进入死锁状态。比如后面要说到的一个 SPOOLing技术，将独占的设备改造成逻辑上共享的设备。这样的话在进程看起来请求资源会被立即接收处理，无需等待。</p>
<p>缺点就是为了保证系统的安全，某些设备必须要被设计成互斥的。</p>
<h3 id="4-1-2-破坏不剥夺条件"><a href="#4-1-2-破坏不剥夺条件" class="headerlink" title="4.1.2 破坏不剥夺条件"></a>4.1.2 破坏不剥夺条件</h3><p>正常情况下，进程获得资源以后，只有使用完成才会释放资源，其他人不能剥夺他的资源。如果其他人可以强制让他释放资源也就不会发生死锁。</p>
<p>方案一：进程请求信资源得不到满足的时候，就会立即释放他持有的资源，等以后需要的时候重新申请，其实就是他自己发现自己活干不了了就主动躺平了。</p>
<p>方案二：如果发现自己要的资源被其他进程占用了，可以让操作系统出面调解，强行剥夺其他进程持有的资源。这种方式需要考虑优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）。</p>
<p>破坏不剥夺条件的缺点：</p>
<ul>
<li>实现复杂</li>
<li>释放已经获得的资源可能会导致前面的工作作废，所以这种办法适合那种易于保存和恢复的资源，比如CPU。</li>
<li>反复申请和释放资源会增加系统开销，降低系统吞吐量。</li>
<li>方式一的话可能会导致饥饿。</li>
</ul>
<h3 id="4-1-3-破坏请求和保持条件"><a href="#4-1-3-破坏请求和保持条件" class="headerlink" title="4.1.3 破坏请求和保持条件"></a>4.1.3 破坏请求和保持条件</h3><p>这个条件本身说的是：进程已经保持了至少一个资源，同时还提出了新的资源<strong>请求</strong>，而该罪案又被其他进程占用，此时请求进程阻塞，仍<strong>保持</strong>着自己已有的资源。</p>
<p>可以使用静态分配方法，进程在运行前一次性申请完他所需要的资源，如果没有申请到，那就不让他运行。一旦运行资源就会一直归他所有，根本上避免进程申请别的资源。</p>
<p>缺点：资源浪费，资源利用率低，可能导致饥饿。</p>
<h3 id="4-1-4-破坏循环等待条件"><a href="#4-1-4-破坏循环等待条件" class="headerlink" title="4.1.4 破坏循环等待条件"></a>4.1.4 破坏循环等待条件</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620112309.png" alt="image.png"></p>
<h3 id="4-1-5-总结"><a href="#4-1-5-总结" class="headerlink" title="4.1.5 总结"></a>4.1.5 总结</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620112338.png" alt="image.png"></p>
<h2 id="4-2-动态-避免死锁"><a href="#4-2-动态-避免死锁" class="headerlink" title="4.2 动态-避免死锁"></a>4.2 动态-避免死锁</h2><h3 id="4-2-1-安全序列"><a href="#4-2-1-安全序列" class="headerlink" title="4.2.1 安全序列"></a>4.2.1 安全序列</h3><p>假设现在有个银行发放贷款，然后各个企业向银行借钱，这些企业会有个借贷总金额的上限，借贷次数可以是多次。现在规定，如果某一次不能满足企业的借贷需求，之前借出去的钱也就要不回来了。</p>
<p>现在问：按照什么顺序给企业发放贷款可以满足全部需求？</p>
<p>假设你有100亿，B企业最多借70亿，A企业最多借40亿，T企业最多借50亿。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620162845.png" alt="image.png"></p>
<p>那如果，借完第一波，A企业又想借30亿，敢借么？如果借出去的话，B或者T企业在来要钱就没了，就不能满足需求。</p>
<p>所以，按照什么顺序依次给这些企业放贷，就是“银行家问题”，得到的这个序列，就是“安全序列”。如果按照安全序列分配资源，每个进程都能顺利完成，那么系统就会处在“安全状态”。如果我们没有按照安全序列分配资源，系统就进入了“不安全状态”，就可能产生死锁问题，如果这个时候某些资源归还了资源，系统就有可能回到“安全状态”。</p>
<h3 id="4-2-2-寻找安全序列"><a href="#4-2-2-寻找安全序列" class="headerlink" title="4.2.2 寻找安全序列"></a>4.2.2 寻找安全序列</h3><p>其实很简单，就是打表然后挨个对比，假设现在有5个进程，每个进程都要申请三种资源，现在已经给他们分配了一部分：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620165403.png" alt="image.png"></p>
<p>现在还剩余（3，3，2），然后用这个和P0-P4挨个对比，看看能满足谁，就给谁分配，分配完了以后进程结束会归还之前的资源，然后重新计算剩余资源数，再去挨个对比。</p>
<p>这里，（3，3，2）可以满足P1，所以把 P1 加入安全队列，P1 使用完资源以后归还之前的资源（2，0，0）和（1，2，2），剩余资源变成（5，3，2）。然后再用（5，3，2）去挨个对比，发现P3可以满足，然后将P3放入安全队列…..一次类推。</p>
<p>手算的话可以简单一点，一上来（3，3，2）可以满足P1和P3，直接把P1和P3加入安全队列就行了，然后加上他们之前持有的资源，然后循环比对。</p>
<p>最后尽可能将所有进程都添加到安全队列中。</p>
<h3 id="4-2-3-银行家算法"><a href="#4-2-3-银行家算法" class="headerlink" title="4.2.3 银行家算法"></a>4.2.3 银行家算法</h3><p>Dijkstra为银行系统设计的一种算法，确保银行放贷的时候可以满足所有客户的需求。在操作系统上，就是提前预知系统会不会进入不安全状态，以此解决资源分配请求，这就是算法的核心思想。银行家算法代码实现的逻辑如下：</p>
<p>系统中有n个进程m种资源。</p>
<p>每个进程都需要先声明对各种资源的最大需求利郎，可以用一个 n * m 的矩阵来表示各种：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620170704.png" alt="image.png"></p>
<p>同时用 Available &#x3D; （3，3，2） 来表示当前剩余的资源量。假设 P0 现在发起请求 Req0 &#x3D; （2，1，1）也就是要申请这么多资源我们就可以这么着：</p>
<ul>
<li>判断 Req &lt;&#x3D; Need，如果不满足认为出错，不给分配资源</li>
<li>判断 Req &lt;&#x3D; Available，如果不满足说明资源紧张，当前进程等待</li>
<li>系统会试探的将资源分配给P0，根据 Available 修改 P0 的 Allocation 和 Need 矩阵。</li>
<li>系统执行安全性算法，根据当前修改寻找安全队列，判断系统是否可以进入安全状态。如果安全，则真正的将资源分配给 P0。</li>
</ul>
<p>这里所谓的安全性算法就是前面的寻找安全队列。</p>
<h2 id="4-3-死锁的检测和解除"><a href="#4-3-死锁的检测和解除" class="headerlink" title="4.3 死锁的检测和解除"></a>4.3 死锁的检测和解除</h2><h3 id="4-3-1-死锁检测"><a href="#4-3-1-死锁检测" class="headerlink" title="4.3.1 死锁检测"></a>4.3.1 死锁检测</h3><p>要检测死锁，就需要做两件事：</p>
<ul>
<li>用某种数据结构来保存资源的请求和分配信息。</li>
<li>提供一种算法，利用上述信息来检测系统是否已经进入死锁状态。</li>
</ul>
<p>数据结构如下：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620212656.png" alt="image.png"></p>
<p>P1 和 P2 两个进程，蓝色的箭头代表他们分别要申请什么资源。R1 和 R2 代表两种资源，里面的点代表资源个数，绿色箭头代表已经给进程分配了多少资源，注意是已经分配的。</p>
<p>然后根据图来分析，P1 进程 要申请1一个R2，R2 已经给了P2一个资源还剩一个资源，所以就可以正常分配给 P1，P1执行结束后，返还资源，也就是将 P1 连着的边全部消除。证明 P1 执行完成并释放资源。同样的方法看 P2，最后也可以消边，最终这个图里面就不存在边，只剩各个节点，则称这个图<font color='red'>可完全简化</font>。</p>
<p>如果一个图可以完全简化，那么此时一定没有发生死锁，其实就相当于我们根据这个图找到了一个安全序列。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620213210.png" alt="image.png"></p>
<p>如果是这种情况，P3 可以正常消边，P1 和 P2 根据分析发现完全没法动，则说明该图不能完全简化，那么就发生了死锁。</p>
<p><strong>具体检测方法</strong></p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620213940.png" alt="image.png"></p>
<h3 id="4-3-2-死锁解除"><a href="#4-3-2-死锁解除" class="headerlink" title="4.3.2 死锁解除"></a>4.3.2 死锁解除</h3><p>根据上面的方法检测到死锁以后，如何解除？</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620214029.png" alt="image.png"></p>
<p>我们再根据以下指标来判断对谁开刀：</p>
<ul>
<li>进程优先级</li>
<li>已经执行多长时间</li>
<li>还要多久完成</li>
<li>进程已经使用了多少资源</li>
<li>进程是交互式的还是批处理式的</li>
</ul>
<h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620214230.png" alt="image.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/30/06-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hexo_avatar.jpeg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PtheF-Hexo-Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/30/06-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/" class="post-title-link" itemprop="url">06.同步与互斥</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-30 11:06:27 / 修改时间：11:13:42" itemprop="dateCreated datePublished" datetime="2023-06-30T11:06:27+08:00">2023-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="1-进程同步"><a href="#1-进程同步" class="headerlink" title="1. 进程同步"></a>1. 进程同步</h1><p>同步说的就是如何解决进程异步的问题，众所周知操作系统的各个进程异步执行，谁先谁后不可预知，但是有些时候我们又需要控制进程的执行顺序，比如在管道通信中，写肯定得发生在读之前，这就是进程同步要解决的问题。</p>
<h1 id="2-进程互斥"><a href="#2-进程互斥" class="headerlink" title="2. 进程互斥"></a>2. 进程互斥</h1><p>在一个时间段内只允许一个进程使用的资源我们称之为临界资源，比如打印机这种资源，一个进程用了另一个进程就不能用了。</p>
<p>对于临界资源的访问必须互斥的进行。互斥，或者称为间接制约关系。进程互斥指的就是访问临界资源时，另一个想要访问该临界资源的进程必须等待。</p>
<p>对临界资源的访问，可以在逻辑上分为下面四个部分：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619155340.png" alt="image.png"></p>
<p>如果一个进程暂时不能进入临界区，那么该进程是否应该一直占着处理机？这个进程有没有可能一直进不了临界区？这都是互斥要考虑的东西。需要遵循下面四个原则：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619155551.png" alt="image.png"></p>
<p>总结：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619155612.png" alt="image.png"></p>
<h1 id="3-互斥的软件实现"><a href="#3-互斥的软件实现" class="headerlink" title="3. 互斥的软件实现"></a>3. 互斥的软件实现</h1><p>如果两个进程使用打印机，但是不上锁，不涉及到互斥，会出现的问题就是，进程A使用打印机打印了一半时间片用完，然后CPU就去处理进程B，进程B也会获得打印机资源开始打印，然后A和B打印的东西就混在一起了。</p>
<p>为了解决这个问题，可以在代码层面实现互斥。</p>
<h2 id="3-1-单标志法"><a href="#3-1-单标志法" class="headerlink" title="3.1 单标志法"></a>3.1 单标志法</h2><p>核心思想：代码会规定现在只能哪个进程来访问临界区（注意：是访问临界区代码，执行临界区代码的时候肯定已经拿到了临界资源的锁），指定的进程访问完临界资源后，会把临界区的访问权限给另一个进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前只有0进程可以执行临界区</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1进程</span></span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P2 进程</span></span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>

<p>如果进程P2先上处理机，就会卡死在while循环，因为发现turn 确实不等于1，说明自己不能访问临界资源，等到P2的时间片用完了，P1执行，P1就不会卡while，而是会往下执行，最后将 turn 改为1，供P2执行。</p>
<p>这个算法体现了一个谦让的思路，两个进程其中一个只要执行完了临界区，就会把临界区的访问权谦让出去。但是如果P2谦让给了P1，P1因为某种原因迟迟不执行临界区，那么P2也就没发使用临界区，这就<strong>违背了空闲让进</strong>的原则。</p>
<h2 id="3-2-双标志先检查"><a href="#3-2-双标志先检查" class="headerlink" title="3.2 双标志先检查"></a>3.2 双标志先检查</h2><p>核心思想：设置一个布尔型数组 flag[]，数组中各个元素用来表示<strong>各个进程想要进入临界区的意愿</strong>，比如 <code>flag[0] = true</code> 就表示0号进程想要访问临界区。那么每个进程访问临界区之前都要先检查当前其他进程有没有想要进入临界区的意思，如果没有，把自己的 flag 设置为true，然后开始访问临界区。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619161255.png" alt="image.png"></p>
<p>4 和 8 就是退出区。</p>
<p>但是有个问题，就是这种算法的进入区代码分两步：检查和上锁，是非原子性的，并发情况下很可能出现错误，导致两个进程全都进入了临界区。违反了忙则等待。</p>
<h2 id="3-3-双标志后检查"><a href="#3-3-双标志后检查" class="headerlink" title="3.3 双标志后检查"></a>3.3 双标志后检查</h2><p>这个和前面的几乎一样，只是进入区的代码有调整，之前是先检查后上锁，结果会出现锁失效，那么这里就让他先上锁后检查：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619161837.png" alt="image.png"></p>
<p>结果这会更完蛋，每个进程先上锁，然后检查，如果检查发现不能进入临界区他也不会释放锁，这就会导致死锁了。违背了 “空闲让进”和“有限等待”，会产生饥饿。</p>
<h2 id="3-4-Peterson-算法"><a href="#3-4-Peterson-算法" class="headerlink" title="3.4 Peterson 算法"></a>3.4 Peterson 算法</h2><p>这种算法是单标志法和双标志法的结合。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619162402.png" alt="image.png"></p>
<p>就是说一个线程想要进入临界区首先要加锁，加完锁以后还要客气一下执行谦让动作，表明可以让对方进程优先进入。如果这个时候因为并发的原因另一个进程也加了锁，并且也谦让了，相当于该进程的临界区使用权就被让回来了，就可以正常进入临界区。</p>
<p>可以这么理解，谁最后谦让了，谁就会失去行动的优先权。对方进程就会进入临界区。</p>
<p>算法的前三句是进入区。遵循了前三个原则，但是没有遵循<strong>让权等待</strong>。也就是进程会不停的检查自己有没有进入临界区的资格，会占用CPU。</p>
<h2 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619163002.png" alt="image.png"></p>
<h1 id="4-互斥的硬件实现"><a href="#4-互斥的硬件实现" class="headerlink" title="4. 互斥的硬件实现"></a>4. 互斥的硬件实现</h1><h2 id="4-1-中断屏蔽方法"><a href="#4-1-中断屏蔽方法" class="headerlink" title="4.1 中断屏蔽方法"></a>4.1 中断屏蔽方法</h2><p>这个就是使用“关&#x2F;开中断指令”实现，之前说过，执行了关中断指令，后面的指令就不会执行例行检查，所以就一定不会发生进程切换，可以保证原子性。</p>
<p>可以咋办？先执行关中断指令，然后访问临界区，最后执行开中断指令，这样就不会被打断。</p>
<p>优点：简单，高效。</p>
<p>缺点：不适合多核处理机；只适合操作系统内核进程，不适合用户进程。</p>
<h2 id="4-2-TestAndSet指令"><a href="#4-2-TestAndSet指令" class="headerlink" title="4.2 TestAndSet指令"></a>4.2 TestAndSet指令</h2><p>简称TS指令，也叫 TestAndSetLock，或者TSL指令。该指令用硬件实现，执行的过程不允许被中断，只能一气呵成。用C语言表达的话就是：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619163913.png" alt="image.png"></p>
<p>TSL 指令就是说给lock上锁（不管锁原本啥样），同时返回原来的锁状态。当一个进程要访问一个加了锁的资源时，执行TSL指令就会得到true，就不能进入临界区。当另一个进程释放了锁，让lock&#x3D;false时，再执行TSL指令就会得到false，同时自己也会给它上锁。</p>
<p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境。</p>
<p>缺点：不满足让权等待，进程会不停的检查锁的状态，占用CPU。</p>
<h2 id="4-3-Swap-指令"><a href="#4-3-Swap-指令" class="headerlink" title="4.3 Swap 指令"></a>4.3 Swap 指令</h2><p>也叫Exchange指令，其实就是交换，也是由硬件实现，而且也是原子性的指令。思想就是：通过这个原子性的指令，将锁的状态给它换出来，然后检查，如果发现换出来个false，说明锁被释放，自己就可以进入临界区。同时也会将true给换进去，代表加锁。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619164705.png" alt="image.png"></p>
<p>当条件允许，也就是lock为false时，old为true，交换后old为false，lock为true，就相当于自己进程持有了锁。</p>
<h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619164818.png" alt="image.png"></p>
<h1 id="5-互斥锁"><a href="#5-互斥锁" class="headerlink" title="5. 互斥锁"></a>5. 互斥锁</h1><p>这个好像不是个重点，截个图完事儿：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619165144.png" alt="image.png"></p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619165217.png" alt="image.png"></p>
<h1 id="6-信号量机制"><a href="#6-信号量机制" class="headerlink" title="6. 信号量机制"></a>6. 信号量机制</h1><p>之前的方法里面，比如双标志先检查法，进入区的检查和上锁两步不能一气呵成，就导致两个进程可能会同时进入。而且，所有的解决方案都无法实现让权等待。</p>
<p>为了解决这几个问题，就提出了信号量机制。</p>
<p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而可以很方便的实现了进程互斥、进程同步。</p>
<p>信号量其实就是一个变量（可以是整数，也可以是很复杂的记录行变量），可以<font color='red'>用一个信号量来表示系统中某种资源的数量</font>，比如：系统中只有一台打印机，就可以给打印机设置初始值为1的信号量。</p>
<p>操作系统提供了一对原语：wait(S)和signal(S)，可以类比成两个函数，信号量S就是传入的一个参数。</p>
<p>wait和signal操作常被简称为 PV操作，因此也经常把 wait(S) 和 signal(S) 写作P(S) 和 V(S)。</p>
<h2 id="6-1-整型信号量"><a href="#6-1-整型信号量" class="headerlink" title="6.1 整型信号量"></a>6.1 整型信号量</h2><p>用一个整数型变量作为信号量，用来表示系统中某种资源的数量。普通的整数可以进行运行，而整数型信号量只能做三个操作：初始化、P操作、V操作。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619170359.png" alt="image.png"></p>
<p>我们会发现它其实就是先检查后上锁，但是原子性的，所以更安全。但是这种仍旧是自旋锁，不满足“让权等待”，会发生忙等。</p>
<p>这里有个问题，就是wait原语里面一直自旋，难道不会一直占用CPU？我们姑且认为不会。</p>
<h2 id="6-2-记录型信号量"><a href="#6-2-记录型信号量" class="headerlink" title="6.2 记录型信号量"></a>6.2 记录型信号量</h2><p>为了解决忙等的问题，人们又提出了“记录行信号量”，用记录型数据结构表示信号量。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619170747.png" alt="image.png"></p>
<p>就是说如果发现资源不够不能上锁，就会主动阻塞当前进程，将其挂在信号量的阻塞队列上。等其他进程调用V操作释放资源的时候会主动去唤醒之前阻塞的进程，就不会发生忙等，符合“让权等待”。很有monitor那味。</p>
<h2 id="6-3-总结"><a href="#6-3-总结" class="headerlink" title="6.3 总结"></a>6.3 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619172000.png"></p>
<h1 id="7-信号量机制实现互斥、同步、前驱"><a href="#7-信号量机制实现互斥、同步、前驱" class="headerlink" title="7. 信号量机制实现互斥、同步、前驱"></a>7. 信号量机制实现互斥、同步、前驱</h1><h2 id="7-1-进程互斥"><a href="#7-1-进程互斥" class="headerlink" title="7.1 进程互斥"></a>7.1 进程互斥</h2><p>这个很简单，初始化一个为1的信号量mutex，每个进程要访问临界区都要执行P（wait）操作，成功进入临界区并执行完以后，需要执行V操作释放mutex。</p>
<p>这个mutex就可以理解成进程临界区的名额只能有一个，P了以后就占用了这个名额。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般默认的都是记录型信号量</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 做题的话就用这种方式定义信号量就行了</span></span><br><span class="line"></span><br><span class="line">P1() &#123;</span><br><span class="line">	P(mutex);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	V(mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2() &#123;</span><br><span class="line">	P(mutex);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	V(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-进程同步"><a href="#7-2-进程同步" class="headerlink" title="7.2 进程同步"></a>7.2 进程同步</h2><p>我们要控制几个进程的执行顺序，比如：P1 要执行code 1 2 3 ，P2要执行 code 4 5 6，我们要求P2必须在P1执行完code2之后执行，怎么做？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">P1() &#123;</span><br><span class="line">	code <span class="number">1</span>;</span><br><span class="line">	code <span class="number">2</span>;</span><br><span class="line">	V(s);</span><br><span class="line">	code <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2() &#123;</span><br><span class="line">	V(s);</span><br><span class="line">	code <span class="number">4</span>;</span><br><span class="line">	code <span class="number">5</span>;</span><br><span class="line">	code <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里千万注意，信号量要初始化为0，要是初始化为1的话，P2执行 value–，然后发现 value &#x3D;&#x3D; 0 满足 value &gt;&#x3D; 0，P2直接就进去了。</p>
<p>简单说，前操作之后执行V，后操作之前执行P。</p>
<h2 id="7-3-前驱关系"><a href="#7-3-前驱关系" class="headerlink" title="7.3 前驱关系"></a>7.3 前驱关系</h2><p>就是更为复杂的前驱关系，多个进程需要协同前进。其实非常的简单，每一种前驱关系都设定一个信号量，然后两两成对的前V后P即可。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619173559.png" alt="image.png"></p>
<h2 id="7-4-总结"><a href="#7-4-总结" class="headerlink" title="7.4 总结"></a>7.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619173733.png" alt="image.png"></p>
<h1 id="8-相关问题"><a href="#8-相关问题" class="headerlink" title="8. 相关问题"></a>8. 相关问题</h1><h2 id="8-1-生产者-消费者"><a href="#8-1-生产者-消费者" class="headerlink" title="8.1 生产者-消费者"></a>8.1 生产者-消费者</h2><p>这个问题很经典啊，就是说有一个缓冲区，生产者往缓冲区写数据，消费者从缓冲区读数据。如果缓冲区满了，生产者阻塞，如果缓冲区空了，消费者阻塞。同时，生产者和消费者不为一，所以各个角色都要互斥的访问缓冲区。</p>
<p>分析：这就是我们之前说的进程同步，缓冲区没空，然后消费者拿数据；反过来，缓冲区没满，则生产者放数据。这就是两个信号量，生产者生产数据，则缓冲区没空，生产者V，消费者P；消费者获取数据，证明缓冲区没满，消费者V，生产者P。这里的没空和没满，就是两个信号量，两个信号量full和empty分别记录缓冲区中数据的个数和缓冲区空位个数。</p>
<p>进程内如何判空？信号量同时记录着资源的剩余数量，所以释放锁的时候给信号量+1，就可以代表缓冲区内的数据个数，同理，获取锁的时候信号量-1，如果&lt;0，证明缓冲区里面没有数据了，阻塞。</p>
<p>不要考虑什么时候阻塞，而是考虑不阻塞时，先干什么，后干什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line">semaphore empty = n;</span><br><span class="line"></span><br><span class="line">Producer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(empty);</span><br><span class="line"></span><br><span class="line">		P(mutex);</span><br><span class="line">		<span class="comment">// 生产数据</span></span><br><span class="line">		V(mutex);</span><br><span class="line"></span><br><span class="line">		V(full);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(full);</span><br><span class="line"></span><br><span class="line">		P(mutex);</span><br><span class="line">		<span class="comment">// 获取数据</span></span><br><span class="line">		V(mutex);</span><br><span class="line"></span><br><span class="line">		V(empty);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619195303.png" alt="image.png"></p>
<h2 id="8-2-多生产-多消费"><a href="#8-2-多生产-多消费" class="headerlink" title="8.2 多生产-多消费"></a>8.2 多生产-多消费</h2><p>多个生产者生产不同类型的消息，多个消费者对应的消费不同类型的消息，举个例子：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619225251.png" alt="image.png"></p>
<p>分析：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619225436.png" alt="image.png"></p>
<p>实现：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619225644.png" alt="image.png"></p>
<p>这里有个点：即便是不设置 mutex互斥信号量，依然可以正常运作。因为 apple orange 和 plate 三个同步信号量在同一时间只能有一个是1，所以各个进程一上来的P操作就可以防止其他线程进入临界区。如果plate的值是2，也就是盘子可以放两个水果的话，dad和mom可就有可能同时操作盘子了。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619230248.png" alt="image.png"></p>
<h2 id="8-3-吸烟者问题"><a href="#8-3-吸烟者问题" class="headerlink" title="8.3 吸烟者问题"></a>8.3 吸烟者问题</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619230421.png" alt="image.png"></p>
<p>将桌子看作一个缓冲区，容量为1，原材料两两为一个组合，同时要注意轮流这个事儿，他给的解决办法是设置一个i让他%更新。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230619231036.png" alt="image.png"></p>
<h2 id="8-4-读者-写者问题"><a href="#8-4-读者-写者问题" class="headerlink" title="8.4 读者-写者问题"></a>8.4 读者-写者问题</h2><p>这个玩意是真的难，说一下：有一个共享文件，写进程（可以是多个）往文件里写，读进程（可以是多个）从文件里读，如何实现同步互斥。</p>
<p>说一下要求：</p>
<ul>
<li>读进程之间不需要互斥，多个读进程可以同时访问文件</li>
<li>写进程之间需要互斥，否则可能会导致覆盖</li>
<li>写进程写完之前不允许读进程读，还得让所有已有的读写进程退出。</li>
</ul>
<h3 id="8-4-1-简单实现"><a href="#8-4-1-简单实现" class="headerlink" title="8.4.1 简单实现"></a>8.4.1 简单实现</h3><p>最简单的就是弄个文件的信号量进行同步：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore file = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">writer() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(file);</span><br><span class="line">		<span class="comment">// write...</span></span><br><span class="line">		V(file);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(file);</span><br><span class="line">		<span class="comment">// read...</span></span><br><span class="line">		V(file);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样无法让读进程同时进入，读进程之间也会阻塞，咋办？可以这样，让第一个进来的reader上锁，后来的reader可以跳过上锁，让最后一个reader释放锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">0</span>) P(file);</span><br><span class="line">		count++;</span><br><span class="line">		<span class="comment">// read...</span></span><br><span class="line">		count--;</span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">0</span>) V(file);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这又有个问题：代码的进入区有三条语句，判断，上锁，count自增，不保证原子性，就有可能发生冲突，咋办？那就让他保证原子性，给这三条语句上互斥锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(mutex);</span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">0</span>) P(file);</span><br><span class="line">		count++;</span><br><span class="line">		V(mutex);</span><br><span class="line">		<span class="comment">// read...</span></span><br><span class="line">		P(mutex);</span><br><span class="line">		count--;</span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">0</span>) V(file);</span><br><span class="line">		V(mutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-2-写优先"><a href="#8-4-2-写优先" class="headerlink" title="8.4.2 写优先"></a>8.4.2 写优先</h3><p>上面这种又会出现一个问题，如果有源源不断的读进程，那么file就一直不会被释放，锁进程就会饥饿，如何解决饥饿的问题？</p>
<p>再弄一个信号量，实现“写优先”（并不是真正的写优先，只是暂时能解决问题）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">semaphore w = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">writer() &#123; <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	P(w);  <span class="comment">// 获取w锁，表明现在有writer要写，新来的reader先等等。   </span></span><br><span class="line">	P(file);</span><br><span class="line">	<span class="comment">// write...</span></span><br><span class="line">	V(file);</span><br><span class="line">	V(w); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		P(w); <span class="comment">// 读之前看看有没有writer正在写或者想要写</span></span><br><span class="line">		mutex&#123; <span class="comment">// 只是省事儿这么写，考试别这么写</span></span><br><span class="line">			<span class="keyword">if</span>(count == <span class="number">0</span>) P(file);</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		V(w);  <span class="comment">// 在read之前释放w，保证reader进程并发</span></span><br><span class="line">		<span class="comment">// read...</span></span><br><span class="line">		mutex&#123;</span><br><span class="line">			count--;</span><br><span class="line">			<span class="keyword">if</span>(count == <span class="number">0</span>) V(file);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这回就变成啥了？首先如果是两个reader进来，reader1获取了w，然后reader2阻塞，reader1在读之前释放了w，然后reader2就会唤醒，可以同时read。</p>
<p>如果是一个writer多个reader的话，reader1经过了前面正在进行read，这个时候writer进来，持有了w锁，然后准备写（但是不能写，因为reader1还持有file锁），然后reader2也来了，尝试获取w失败，就会阻塞，count就不会自增，相当于强制reader读完以后释放file锁，然后writer写，写完了唤醒reader2去读。</p>
<p>这种算法并不能真正实现写优先，而是相对公平的先来先服务原则，这种算法也叫读写公平法。</p>
<h2 id="8-5-哲学家进餐"><a href="#8-5-哲学家进餐" class="headerlink" title="8.5 哲学家进餐"></a>8.5 哲学家进餐</h2><h1 id="9-管程"><a href="#9-管程" class="headerlink" title="9. 管程"></a>9. 管程</h1><p> 这个东西就是一种比较牛逼的数据结构，它里面提供了进程安全（线程安全）的一些方法，比如insert方法，往队列中插入元素，remove方法，从队列中拿出元素等，完了里面还提供了 condition 条件变量，简单说就是阻塞队列。<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620104904.png" alt="image.png"></p>
<p>感觉这个管程也不是重点，提一句得了。<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230620104938.png" alt="image.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/30/05-%E8%B0%83%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hexo_avatar.jpeg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PtheF-Hexo-Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/30/05-%E8%B0%83%E5%BA%A6/" class="post-title-link" itemprop="url">05.调度</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-30 11:06:18 / 修改时间：11:13:39" itemprop="dateCreated datePublished" datetime="2023-06-30T11:06:18+08:00">2023-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="1-调度概念"><a href="#1-调度概念" class="headerlink" title="1. 调度概念"></a>1. 调度概念</h1><p>有一堆任务要处理，但是由于资源有限，这些事情没法同时处理。这就需要确定<strong>某种规则</strong>来决定处理这些任务的顺序，这就是”调度“研究的问题。</p>
<h1 id="2-调度三层次"><a href="#2-调度三层次" class="headerlink" title="2. 调度三层次"></a>2. 调度三层次</h1><h2 id="2-1-高级调度"><a href="#2-1-高级调度" class="headerlink" title="2.1 高级调度"></a>2.1 高级调度</h2><p>也叫作业调度，作业就是一个具体的任务，用户向系统提交一个作业 约等于 用户让操作系统启动一个程序（来处理一个具体的任务），这个时候这个程序还在磁盘里面呢。所以高级调度是从磁盘到内存的调度。</p>
<p>我们要启动好几个程序，就需要将这些程序放入内存，但有的时候内存空间有限，无法放入内存。所以高级调度就是：按照一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入时会创建PCB，调出时会撤销PCB。</p>
<h2 id="2-2-低级调度"><a href="#2-2-低级调度" class="headerlink" title="2.2 低级调度"></a>2.2 低级调度</h2><p>也就是进程调度或者叫处理机调度：按照某种策略从就绪队列中选取一个进程，将处理机分配给他。也就是我们之前说的进程的时间片轮转。</p>
<p>进程调度时操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度，而且进程调度的频率很高，一般几十毫秒一次。</p>
<h2 id="2-3-中级调度"><a href="#2-3-中级调度" class="headerlink" title="2.3 中级调度"></a>2.3 中级调度</h2><p>也叫内存调度，内存不够时，可以将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。</p>
<p>暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列。</p>
<p>所以总的来说，中级调度就是按照某种策略决定将哪个处于挂起状态的进程重新调入内存。同样是磁盘到内存。</p>
<h2 id="2-4-七状态模型"><a href="#2-4-七状态模型" class="headerlink" title="2.4 七状态模型"></a>2.4 七状态模型</h2><p>之前我们说的进程状态是5个，开始、结束、就绪、运行、阻塞。现在有了挂起，那么就可以多两种状态：就绪挂起和阻塞挂起。</p>
<ul>
<li>就绪挂起：进程本来是就绪态，但是被挂起了，那就变成就绪挂起，有的时候运行态的进程发现内存没有地方了，也会直接被设为就绪挂起。</li>
<li>阻塞挂起：好理解，就是阻塞的时候内存不够了，这个进程被挂起，就会进入阻塞挂起，阻塞挂起不能直接回到就绪，当阻塞结束时，他会先变为就绪挂起，然后再回到就绪态。</li>
</ul>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618103739.png" alt="image.png"></p>
<p>这种408可能不会考。</p>
<h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618103931.png" alt="image.png"><br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618104043.png" alt="image.png"></p>
<h1 id="3-进程调度的时机"><a href="#3-进程调度的时机" class="headerlink" title="3. 进程调度的时机"></a>3. 进程调度的时机</h1><p>注意，这里可是叫进程调度，也就是对应前面的低级调度。</p>
<p>进程调度的时机就是什么时候可以进行进程调度，什么时候不能进行调度。</p>
<h2 id="3-1-可以进程调度"><a href="#3-1-可以进程调度" class="headerlink" title="3.1 可以进程调度"></a>3.1 可以进程调度</h2><p>两种情况可以进行进程调度：</p>
<ul>
<li>当前运行的进程主动放弃处理机：进程正常终止，或者运行过程中发成异常，或者进程正在等待某事发生阻塞。</li>
<li>当前运行的进程被动放弃处理机：时间片到了，有更紧急的事儿需要处理（比如IO中断），或者有更高优先级的进程进入就绪队列。</li>
</ul>
<h2 id="3-2-不能进程调度"><a href="#3-2-不能进程调度" class="headerlink" title="3.2 不能进程调度"></a>3.2 不能进程调度</h2><ul>
<li>处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在处理中断的过程中进行进程切换</li>
<li>进程在<font color = 'red'>操作系统内核程序临界区</font>中</li>
<li>在原子操作过程中，比如原语。原子操作需要一气呵成，中间不能调度。</li>
</ul>
<h2 id="3-3-临界区"><a href="#3-3-临界区" class="headerlink" title="3.3 临界区"></a>3.3 临界区</h2><p>前面说到了操作系统内核临界区，这里解释一下：</p>
<p>首先说一下临界资源：一个时间段内只允许一个进程使用的资源。各个进程需要互斥地访问临界资源。临界区：访问临界资源的那段代码。</p>
<p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列。根据我学JUC和MySQL 的经验，比如进程要操作就绪队列，就绪队列就属于临界资源，那么操作队列的这段代码就是临界区，为了实现互斥效果，操作队列之前就会给队列上锁，但是这个锁不能老上着啊，一直持有锁不释放很有可能发生BUG，所以这个时候就不能进程调度，而是让当前进程赶紧用完队列赶紧释放锁。</p>
<p>但是还有一种情况，就是程序处在普通临界区，比如程序正在操作打印机，这个时候是没事的。</p>
<h1 id="4-进程调度的方式"><a href="#4-进程调度的方式" class="headerlink" title="4. 进程调度的方式"></a>4. 进程调度的方式</h1><h2 id="4-1-非剥夺调度方式"><a href="#4-1-非剥夺调度方式" class="headerlink" title="4.1 非剥夺调度方式"></a>4.1 非剥夺调度方式</h2><p>也叫非抢占方式。只允许进程主动放弃处理机。在运行过程中即使有更近剖的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动阻塞。</p>
<p>这种方式开销小，但是无法及时执行紧急任务。</p>
<h2 id="4-2-剥夺调度方式"><a href="#4-2-剥夺调度方式" class="headerlink" title="4.2 剥夺调度方式"></a>4.2 剥夺调度方式</h2><p>也叫抢占方式。当一个进程正在处理机上时，如果有一个更重要或者更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要的进程。</p>
<p>可以优先处理更紧急的进程，也可以让各个进程按照时间片轮流执行。适合于分时操作系统和实时操作系统。</p>
<h1 id="5-进程的切换与过程"><a href="#5-进程的切换与过程" class="headerlink" title="5. 进程的切换与过程"></a>5. 进程的切换与过程</h1><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618110321.png" alt="image.png"></p>
<h1 id="6-调度器-x2F-调度程序"><a href="#6-调度器-x2F-调度程序" class="headerlink" title="6. 调度器&#x2F;调度程序"></a>6. 调度器&#x2F;调度程序</h1><p>调度器或者说调度程序（Scheduler）就是具体执行调度的东西，调度器来执行进程从就绪态到运行态的转变。具体调度程序需要决定：</p>
<ul>
<li>让谁来运行：调度算法</li>
<li>运行多长时间：时间片大小</li>
</ul>
<p>而我们之前说的调度时机，其实就是什么事件会出发”调度程序“：</p>
<ul>
<li>创建新进程</li>
<li>进程推出</li>
<li>运行进程阻塞</li>
<li>IO中断发生（可能唤醒某些阻塞的进程）</li>
<li>非抢占式调度策略，只有运行进程发生阻塞或者退出才会触发调度程序工作</li>
<li>抢占式调度策略，每个时钟中断或K个时钟中断会触发调度程序工作</li>
</ul>
<p>对于不支持内核线程的操作系统，调度程序的处理对象就是进程。而对于支持内核线程的操作系统，调度程序的处理对象就是内核线程。因为线程是调度的基本单位。</p>
<h1 id="7-闲逛进程"><a href="#7-闲逛进程" class="headerlink" title="7. 闲逛进程"></a>7. 闲逛进程</h1><p>调度程序的备胎，如果没有其他就绪进程的话，就会运行闲逛进程（Idle）。</p>
<p>Idle 的特性：</p>
<ul>
<li>优先级最低：单反有一个就绪的进程都不会运行他</li>
<li>可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）：就是说这个指令不需要访问CPU啥的</li>
<li>能耗低</li>
</ul>
<h1 id="8-评价调度算法的指标"><a href="#8-评价调度算法的指标" class="headerlink" title="8. 评价调度算法的指标"></a>8. 评价调度算法的指标</h1><h2 id="8-1-CPU利用率"><a href="#8-1-CPU利用率" class="headerlink" title="8.1 CPU利用率"></a>8.1 CPU利用率</h2><p>$$<br>CPU利用率&#x3D;\frac{CPU忙碌时间}{总时间}<br>$$</p>
<p>考研的时候往往会考察多道程序并发执行的情况，可以用“甘特图”来辅助计算。</p>
<h2 id="8-2-系统吞吐量"><a href="#8-2-系统吞吐量" class="headerlink" title="8.2 系统吞吐量"></a>8.2 系统吞吐量</h2><p>指的就是单位时间内完成作业的数量。</p>
<p>$$<br>所以吞吐量&#x3D;\frac{总共完成了多少道作业}{总共花了多少时间}<br>$$</p>
<h2 id="8-3-周转时间"><a href="#8-3-周转时间" class="headerlink" title="8.3 周转时间"></a>8.3 周转时间</h2><p>指的是作业被提交给系统开始，到作业完成为止的这段时间间隔。包括四个部分：</p>
<ul>
<li>作业在外存后备队列上等待作业调度（高级调度）的时间</li>
<li>进程在就绪队列上等待进程调度（低级调度）的时间</li>
<li>进程在CPU上执行的时间</li>
<li>进程等待IO操作完成的时间。</li>
</ul>
<p>后面三项在作业整个处理过程中可能发生多次。</p>
<p>$$<br>周转时间 &#x3D; {作业完成时间} - {作业提交时间}<br>$$</p>
<p>$$<br>平均周转时间 &#x3D; \frac{各作业周转时间和}{作业数}<br>$$</p>
<p>两个作业虽然周转时间相同，但是实际运行时间可能不同，导致的感受也不同，所以又提出了带权周转时间：</p>
<p>$$<br>带权周转时间 &#x3D; \frac{作业周转时间}{作业实际运行时间} &#x3D; \frac{作业完成时间 - 作业提交时间}{作业实际运行时间}<br>$$</p>
<p>带权周转时间必然 &gt;&#x3D; 1，带权周转时间和周转时间都是越小越好。</p>
<p>然后还有一个平均带权周转时间，就是各个作业带权周转时间的和除以作业数，不说了。</p>
<h2 id="8-4-等待时间"><a href="#8-4-等待时间" class="headerlink" title="8.4 等待时间"></a>8.4 等待时间</h2><p>指的是进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p>
<p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待IO完成的期间其实进程也是被服务的，所以不计入等待时间（也就是说打印机工作的时间不算）。</p>
<p>对于作业来说，不仅要考虑建立进程后等待的时间，还要加上作业在外存后备队列中等待的时间。</p>
<p>一个作业总共需要被CPU服务多久，被IO设备服务多久一般是确定不变的，因此调度算法其实只会影响作业&#x2F;进程的等待时间。</p>
<p>$$<br>等待时间 &#x3D; 周转时间 - 运行时间（如果使用了IO设备，还需要减去IO设备使用时间）<br>$$</p>
<h2 id="8-5-响应时间"><a href="#8-5-响应时间" class="headerlink" title="8.5 响应时间"></a>8.5 响应时间</h2><p>指的就是用户提交请求到首次产生响应所需要的时间。</p>
<h2 id="8-6-总结"><a href="#8-6-总结" class="headerlink" title="8.6 总结"></a>8.6 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618145437.png" alt="image.png"></p>
<h1 id="9-调度算法"><a href="#9-调度算法" class="headerlink" title="9. 调度算法"></a>9. 调度算法</h1><h2 id="9-1-先来先服务"><a href="#9-1-先来先服务" class="headerlink" title="9.1 先来先服务"></a>9.1 先来先服务</h2><p>很好理解，就是越先来的进程越先被服务。一般也就是按照时间顺序依次往后执行。核心思想就是“公平”，且属于非抢占式调度算法，除非任务主动放弃或者阻塞，不会强制让任务下线。用于作业调度时，考虑哪个作业先到达后备队列；用于进程调度时，考虑哪个进程先到达就绪队列。</p>
<p>优点：公平、算法实现简单</p>
<p>缺点：排在长作业后面的短作业需要等待很长时间，从指标来看就是带权周转时间非常长，这个体验就是非常不好了。</p>
<p>这种算法不会导致饥饿，所以任务都会有序的被服务。</p>
<h2 id="9-2-短作业优先"><a href="#9-2-短作业优先" class="headerlink" title="9.2 短作业优先"></a>9.2 短作业优先</h2><p>追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间。算法规则就是：最短的作业&#x2F;进程优先得到服务（最短指的是要求服务时间最短）。既可以用于作业调度，也可以用在进程调度。用于进程调度时称为“短进程优先（SPF）算法”。</p>
<p>优点就是“最短的”平均等待时间、平均周转时间。</p>
<p>缺点：不太公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业&#x2F;进程的运行时间是由用户提供的，并已定真实，不一定能做到真正的短作业优先</p>
<p>然而短作业优先又分两种：抢占式和非抢占式：</p>
<h3 id="9-2-1-非抢占式短作业优先"><a href="#9-2-1-非抢占式短作业优先" class="headerlink" title="9.2.1 非抢占式短作业优先"></a>9.2.1 非抢占式短作业优先</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618151318.png" alt="image.png"></p>
<h3 id="9-2-2-抢占式短作业优先"><a href="#9-2-2-抢占式短作业优先" class="headerlink" title="9.2.2 抢占式短作业优先"></a>9.2.2 抢占式短作业优先</h3><p>这种算法也叫“最短剩余时间优先算法（SRNT）”，每次一个任务来了以后，他就会根据任务的剩余时间来重新调度。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618151344.png"></p>
<h3 id="9-2-3-细节"><a href="#9-2-3-细节" class="headerlink" title="9.2.3 细节"></a>9.2.3 细节</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618151642.png" alt="image.png"></p>
<h2 id="9-3-高响应比优先"><a href="#9-3-高响应比优先" class="headerlink" title="9.3 高响应比优先"></a>9.3 高响应比优先</h2><p>是一种非抢占式的算法，就是每次要重新调度的时候，我都看看谁等的时间长了而且活比较简单，优先让这类作业先上处理机。因此也不会饥饿。<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618152410.png" alt="image.png"></p>
<h2 id="9-4-总结"><a href="#9-4-总结" class="headerlink" title="9.4 总结"></a>9.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618152556.png" alt="image.png"></p>
<h2 id="9-5-时间片轮转"><a href="#9-5-时间片轮转" class="headerlink" title="9.5 时间片轮转"></a>9.5 时间片轮转</h2><p>比较常用的算法，只用于进程调度，伴随着分时操作系统引入的一种算法。所以这种算法更注重响应时间。</p>
<p>如果时间片设置太大，使得每个进程都可以在一个时间片内完成，则算法就会退化成先来先服务算法，并且会增大进程响应时间。另一方面，如果进程切换过于频繁，就会导致系统会花费大量的时间来处理进程切换，从而导致进程执行的时间比例减少。一般来说，进程开销占比不少过1%。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618153559.png" alt="image.png"></p>
<p>这里说一下算法规则：任务一定是按照顺序进入就绪队列中，所以调度的时候也是按顺序进行调度。如果时间片内任务没做完，则重新放回队列末尾。如果同一时间又有新任务加入，时间片也用完了旧任务要回队，我们默认旧任务排在新任务后面。</p>
<h2 id="9-6-优先级调度算法"><a href="#9-6-优先级调度算法" class="headerlink" title="9.6 优先级调度算法"></a>9.6 优先级调度算法</h2><p>就是说每个任务来的时候都会有个优先数代表着优先级（优先级越高可不一定优先数越大，分情况讨论），每次调度都会选择最高优先级的任务先上处理机。</p>
<p>同样有抢占式的和非抢占式的，非抢占式的好理解，抢占式的就是每次就绪队列发生变化都要重新调度一下，看看有没有新的任务优先级更高，就优先执行哪个。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618154812.png" alt="image.png"></p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618154718.png" alt="image.png"></p>
<h2 id="9-7-多级反馈队列调度算法"><a href="#9-7-多级反馈队列调度算法" class="headerlink" title="9.7 多级反馈队列调度算法"></a>9.7 多级反馈队列调度算法</h2><p>这个算法可就优点复杂了。<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618155507.png" alt="image.png"><br>看图看不懂，来上个例子：</p>
<p>现在有三个任务：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>到达时间</th>
<th>运行时间</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>0</td>
<td>8</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>P3</td>
<td>5</td>
<td>1</td>
</tr>
</tbody></table>
<p>多级反馈队列会提供多个队列，每个队列有自己的时间片，优先级越高的队列对应的时间片越低：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618160550.png" alt="image.png"></p>
<p>当P1进入，因为是先到达，所以首先进入一级队列，对应的时间片是1，所以执行1个时间，执行完以后，由于时间片没有被打断切P1没有完成，P1就会进入第二级队列，同时，P2来了，就会先进入一级队列。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618160746.png" alt="image.png"></p>
<p>然后操作系统会优先执行优先级高的队列，所以就会优先执行一级队列中的P2，同样是执行一个时间，然后和P1一样进入二级队列。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618160913.png" alt="image.png"></p>
<p>然后二级队列就会按照顺序执行P1，P1同样没有被打断而且没有执行完，那么P1就会进入三级队列，之后继续执行P2任务。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618161034.png" alt="image.png"></p>
<p>P2执行了一个时间时，P3来了，这个时候就会重新调度，相当于P2执行被打断，如果执行被打断，就不会流向下一级队列，而是会重新返回当前队列等待执行。同时P3进入一级队列。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618161214.png" alt="image.png"></p>
<p>操作系统又会优先执行高优先级队列，所以优先执行P3，P3执行完以后执行P2，P2执行了二个时间后执行完成，不会进入三级队列。最后执行P1，因为是最低级队列，即便是时间片内没有执行完，也会重新回到当前队列重新执行。</p>
<h2 id="9-8-总结"><a href="#9-8-总结" class="headerlink" title="9.8 总结"></a>9.8 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618155620.png" alt="image.png"></p>
<h2 id="9-9-多级队列调度"><a href="#9-9-多级队列调度" class="headerlink" title="9.9 多级队列调度"></a>9.9 多级队列调度</h2><p>这个他们就是提了一句，感觉也不是很难。就是说设计好几个任务队列，每个任务队列都有自己的功能划分，所以队列自己就有优先级。各个队列也可以分别设置不同的调度策略。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618163040.png" alt="image.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/30/04-%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hexo_avatar.jpeg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PtheF-Hexo-Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/30/04-%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">04.线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-30 11:06:13 / 修改时间：11:13:35" itemprop="dateCreated datePublished" datetime="2023-06-30T11:06:13+08:00">2023-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="1-什么是线程"><a href="#1-什么是线程" class="headerlink" title="1. 什么是线程"></a>1. 什么是线程</h1><p>有的进程可能需要“同时”做很多事情，而传统的进程只能穿性的执行一系列程序。为此引入了“线程”，来增加并发度。可以吧线程理解成“轻量级进程”</p>
<p>传统的进程是程序执行流的最小单位，引入线程后，线程成为了程序执行流的最小单位，线程是一个基本的CPU执行单元，进程内的各个线程也可以并发，从而进一步提高了系统并发度。</p>
<h1 id="2-线程带来的变化"><a href="#2-线程带来的变化" class="headerlink" title="2. 线程带来的变化"></a>2. 线程带来的变化</h1><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618093531.png" alt="image.png"></p>
<p>这里再提一句，这个进程运行环境在上一章专门说过，也就是CPU里面寄存器那些东西，这些东西需要保存到PCB中，切换进程就需要将当前进程的环境保存到PCB，然后将下一个进程的PCB数据读入，开销会比较大。</p>
<h1 id="3-线程的属性"><a href="#3-线程的属性" class="headerlink" title="3. 线程的属性"></a>3. 线程的属性</h1><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618093825.png" alt="image.png"></p>
<h1 id="4-线程的实现方式"><a href="#4-线程的实现方式" class="headerlink" title="4. 线程的实现方式"></a>4. 线程的实现方式</h1><h2 id="4-1-用户级线程"><a href="#4-1-用户级线程" class="headerlink" title="4.1 用户级线程"></a>4.1 用户级线程</h2><p>早起的操作系统（比如 Unix）只支持进程不支持线程。当时的“线程”是由线程库实现的。比如说我们要写一个程序，这个程序要同时处理文字聊天，视频，文件传输，我们就可以在代码层面这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span>) &#123; 文字聊天 &#125;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">1</span>) &#123; 视频 &#125;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">2</span>) &#123; 文件传输 &#125;</span><br><span class="line">		i = (i + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码我们就简单实现了三个线程，很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能。</p>
<p>说明几个问题：</p>
<ul>
<li>线程的管理工作由用户来完成，操作系统感知不到线程的存在</li>
<li>线程切换不需要CPU变态，因为进程没变</li>
</ul>
<p>这种线程的实现在用户空间即可完成，不需要CPU切换到核心态，所以管理的系统开销小，效率高。但是从代码角度看，如果一个线程被阻塞，整个程序都会被阻塞，并发度不高。同时因为CPU感知不到线程，多个线程不可以在多核处理机上并行运行。</p>
<h2 id="4-2-内核级线程"><a href="#4-2-内核级线程" class="headerlink" title="4.2 内核级线程"></a>4.2 内核级线程</h2><p>这种就是操作系统层面上支持线程，线程的管理工作如线程调度、切换等由操作系统内核完成，所以内核级线程的切换必须要在核心态下才能完成。</p>
<p>和进程类似，操作系统会为每个内核级线程创建相应的TCB（Thread Control Block），通过对TCB来管理线程。“内核级线程”就是“从操作系统内核角度能看到的线程”。</p>
<p>这么做的优点就是当一个线程被阻塞后，别的线程还可以继续执行，并发能力强，而且多个线程就可以被分配到多个处理机上并行执行。而缺点就是一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理成本高。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618095730.png" alt="image.png"></p>
<h1 id="5-多线程模型"><a href="#5-多线程模型" class="headerlink" title="5. 多线程模型"></a>5. 多线程模型</h1><p>如果将用户线程和内核线程结合起来，将用户线程映射到内核线程上，就会有下面这么三种多线程模型。</p>
<h2 id="5-1-一对一模型"><a href="#5-1-一对一模型" class="headerlink" title="5.1 一对一模型"></a>5.1 一对一模型</h2><p>每个用户线程映射到一个内核线程。每个用户进程有与用户线程同数量的内核线程。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618100033.png" alt="image.png"></p>
<p>当一个线程被阻塞后，别的线程还可以继续运行，并发能力强。多线程可以在多核处理机上并行。但是一个用户进程占用多个内核线程，线程管理开销大。</p>
<h2 id="5-2-多对一模型"><a href="#5-2-多对一模型" class="headerlink" title="5.2 多对一模型"></a>5.2 多对一模型</h2><p>多个用户及线程映射到一个内核级线程。且一个进程只分配一个内核级线程。这个东西就是退化回去了，优点和之前一样，线程转换不需要切换到核心态，线程管理开销小。但是线程一旦被阻塞整个进程就会被阻塞，并发度不高。多个线程也不能在多核处理机上并行。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618100426.png" alt="image.png"></p>
<p>切记：<font color='red'> 操作系统只“看得见”内核级线程，因此只有内核线程才是处理机分配的单位。</font></p>
<h2 id="5-3-多对多模型"><a href="#5-3-多对多模型" class="headerlink" title="5.3 多对多模型"></a>5.3 多对多模型</h2><p>N个用户线程映射到M个内核线程上（N&gt;M）。每个用户进程对应M个内核线程。克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核线程，开销太大的缺点。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618100601.png" alt="image.png"></p>
<p>这里用户线程和核心线程的关系：</p>
<ul>
<li>用户线程是“代码逻辑”的载体</li>
<li>内核线程是”运行机会“的载体</li>
</ul>
<p>一端代码逻辑只有获得了运行机会才能被CPU执行。比如三个功能，视频聊天，文字聊天，文件传输，其中视频聊天比较占用资源，就可以给视频聊天的用户线程单独分配一个核心线程，然后文字聊天和文件传输共用另一个核心线程。</p>
<h1 id="6-线程的状态与转换"><a href="#6-线程的状态与转换" class="headerlink" title="6. 线程的状态与转换"></a>6. 线程的状态与转换</h1><p>这个就十分的简单了，和前面的进程几乎是一毛一样，我们只需要着重关注三个状态：就绪、运行、阻塞。线程首先进入就绪状态然后等待CPU分配时间片，然后运行，时间片用完以后就会返回就绪状态。如果在运行的时候等待某件事，就会进入阻塞，等待结束返回就绪态。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618101420.png" alt="image.png"></p>
<h1 id="7-线程的组织与控制"><a href="#7-线程的组织与控制" class="headerlink" title="7. 线程的组织与控制"></a>7. 线程的组织与控制</h1><p>这个和进程也是很类似，操作系统为了管理线程就会为每个线程创建一个TCB线程控制块：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230618101912.png" alt="image.png"></p>
<p>这里只说两个东西：</p>
<ul>
<li>其他寄存器：这个东西和之前的进程运行状态类似，就是CPU在执行这个线程的时候寄存器的值</li>
<li>堆栈指针：这个玩意如果学过JVM的话就好理解了，就是指向虚拟机栈的指针，然后这个栈用来记录函数调用情况。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/30/03-%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hexo_avatar.jpeg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PtheF-Hexo-Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/30/03-%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">03.进程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-30 11:06:07 / 修改时间：11:13:31" itemprop="dateCreated datePublished" datetime="2023-06-30T11:06:07+08:00">2023-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="1-进程概念"><a href="#1-进程概念" class="headerlink" title="1. 进程概念"></a>1. 进程概念</h1><p>程序就是磁盘上的可执行文件，而进程就是动态的执行。</p>
<p>如果我们一次打开多个进程，操作系统怎么知道哪个是哪个？</p>
<h1 id="2-进程的组成"><a href="#2-进程的组成" class="headerlink" title="2. 进程的组成"></a>2. 进程的组成</h1><p>先说结论，进程实体由PCB、程序段、数据段 组成：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617214531.png" alt="image.png"></p>
<h2 id="2-1-PCB-程序控制块"><a href="#2-1-PCB-程序控制块" class="headerlink" title="2.1 PCB-程序控制块"></a>2.1 PCB-程序控制块</h2><p>操作系统会为每个进程分配一个ID——PID，同时操作系统还会记录当前这个进程的所属用户UID，还要记录给这个进程分配了多少资源；以及记录进程的运行情况，比如 CPU 使用时间，磁盘使用情况等。</p>
<p>操作系统需要为一个进程维护这么多信息，这些信息就会统一的保存在一个数据结构中——PCB（Process Control Block），也就是<strong>进程控制块</strong>，操作系统需要对各个并发运行的进程进行管理，单发管理时所需要的信息，都会放在PCB中。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617213809.png" alt="image.png"></p>
<h2 id="2-2-程序段和数据段"><a href="#2-2-程序段和数据段" class="headerlink" title="2.2 程序段和数据段"></a>2.2 程序段和数据段</h2><p>这个其实好理解，一个可执行文件，运行的时候就会把指令放在内存中供CPU读取执行，那么这些内存中的指令，就是程序段。而执行过程中肯定会产生不少数据，这些数据也会存在内存中，这么用来存数据的部分，就是这个进程的数据段。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617214306.png" alt="image.png"></p>
<h1 id="3-进程的特征"><a href="#3-进程的特征" class="headerlink" title="3. 进程的特征"></a>3. 进程的特征</h1><p>一张图：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617214648.png" alt="image.png"></p>
<h1 id="4-进程状态"><a href="#4-进程状态" class="headerlink" title="4. 进程状态"></a>4. 进程状态</h1><h2 id="4-1-进程的各个状态"><a href="#4-1-进程的各个状态" class="headerlink" title="4.1 进程的各个状态"></a>4.1 进程的各个状态</h2><p>这个和线程状态感觉特别像。</p>
<p><strong>创建态</strong></p>
<p>当进程被创建时，它的状态就是“创建态”，这个阶段操作系统会给她分配资源，初始化PCB。</p>
<p><strong>就绪态</strong></p>
<p>当进程创建完成后，就会进入“就绪态”，处于就绪态的进程已经具备了运行条件，但是由于CPU比较忙，所以还不能运行这个进程。</p>
<p><strong>运行态</strong></p>
<p>等CPU空闲了，就会拿过来一个处于就绪态的进程去运行，那么这个被运行的进程就处于“运行态”。</p>
<p><strong>阻塞态</strong></p>
<p>假设这个进程就是WPS，他要让打印机进行打印，然后CPU就会给这个进程分配打印机资源，但是这个打印机正在干活，没空为这个进程服务，那么这个进程就会进入“阻塞态”。总的来说，进程运行时，可能会请求等待某个事件的发生，这里就是等待打印机空闲，在这个事件发生之前，操作系统就会让这个进程下CPU，并让他进入“阻塞态”。</p>
<p>等到打印机空闲了，这个进程就会重新回到就绪态，然后等待被调度上CPU。</p>
<p><strong>终止态</strong></p>
<p>使用完打印机，这个进程就该结束了，然后进程就会执行 exit 系统调用，请求操作系统终止该进程。此时进程就会进入“终止态”，操作系统就会让这个进程下CPU，并回收内存空间等资源，最后回收这个进程的PCB。</p>
<h2 id="4-2-进程状态的转换"><a href="#4-2-进程状态的转换" class="headerlink" title="4.2 进程状态的转换"></a>4.2 进程状态的转换</h2><p>这个转换和线程的状态转换也是非常像：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617220127.png" alt="image.png"></p>
<h2 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h2><p>看图：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617220107.png" alt="image.png"></p>
<h1 id="5-进程的组织"><a href="#5-进程的组织" class="headerlink" title="5. 进程的组织"></a>5. 进程的组织</h1><p>这个说的就是操作系统如何管理各个进程的PCB，这里说两个组织方式：</p>
<h2 id="5-1-链接方式"><a href="#5-1-链接方式" class="headerlink" title="5.1 链接方式"></a>5.1 链接方式</h2><p>操作系统提供几个指针来指向不同的PCB：</p>
<ul>
<li>执行指针：指向当前运行的进程PCB</li>
<li>就绪队列指针：将所有就绪的进程PCB放入队列，优先级高的进程放在队头，然后指针指向队头</li>
<li>阻塞队列指针：和上面类似。</li>
</ul>
<p>阻塞队列指针有的时候会分开，比如进程1 3 5 等待打印机，就会把PCB1 3 5 放入打印机的阻塞队列，进程 2 4 6 等待磁盘，就会把PCB 2 4 6 放入磁盘的阻塞队列。</p>
<h2 id="5-2-索引方式"><a href="#5-2-索引方式" class="headerlink" title="5.2 索引方式"></a>5.2 索引方式</h2><p>也会提供指针，但是指针不会直接指向PCB。</p>
<ul>
<li>执行指针：也是指向当前运行进程的PCB</li>
<li>就绪表指针：指向了一个记录就绪进程表的指针，表里面记录了PCB的位置</li>
<li>阻塞表指针：同理</li>
</ul>
<p>看看图就理解了：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617220726.png" alt="image.png"></p>
<h2 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617220803.png" alt="image.png"></p>
<h1 id="6-进程控制"><a href="#6-进程控制" class="headerlink" title="6. 进程控制"></a>6. 进程控制</h1><p>前面重点说了进程的状态以及操作系统如何组织PCB，这里就说说操作系统具体如何实现各个进程的转换，也就是进程控制。</p>
<h2 id="6-1-如何实现进程控制"><a href="#6-1-如何实现进程控制" class="headerlink" title="6.1 如何实现进程控制"></a>6.1 如何实现进程控制</h2><p>这里首先复习一下，前面说过一个词——“原语”，这个东西是操作系统内核的组成部分，非常重要。我们这里先给结论：进程控制需要使用原语来实现。</p>
<p>一个进程从阻塞态变为就绪态需要干两件事：将这个进程的PCB的state改为2，此时这个PCB在阻塞队列里；然后将PCB放入就绪队列中。这两件事儿一定要一起执行，如果中断，就会导致PCB的state和所处队列不一致，可能就会出现BUG。</p>
<p>之前说过，原语的执行具有原子性，执行原语的过程中不允许被打断，和上面说的就非常吻合，所以就要用原语来实现进程控制。</p>
<h2 id="6-2-原语为啥原子性"><a href="#6-2-原语为啥原子性" class="headerlink" title="6.2 原语为啥原子性"></a>6.2 原语为啥原子性</h2><p>一般情况下，CPU每执行完一个指令，就会去检查有没有外部的中断信号，如果有就会中断，去执行中断处理程序。为了变面外中断干扰，CPU提供了两条特权指令：</p>
<ul>
<li>关中断指令：CPU执行这条指令后，往后面的指令都不会检查外部中断，一定会往下执行</li>
<li>开中断指令：CPU执行后，恢复到以前的执行完检查外中断的模式，往后就不能保证原子性</li>
</ul>
<p>依靠这两条指令就可以实现原子性：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617222120.png" alt="image.png"></p>
<p>图中，指令a 和 指令b 一起执行，这两条指令就有了原子性。</p>
<h2 id="6-3-进程控制相关原语"><a href="#6-3-进程控制相关原语" class="headerlink" title="6.3 进程控制相关原语"></a>6.3 进程控制相关原语</h2><h3 id="6-3-1-创建原语"><a href="#6-3-1-创建原语" class="headerlink" title="6.3.1 创建原语"></a>6.3.1 创建原语</h3><p>也就是涉及到创建进程的原语：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617222353.png" alt="image.png"><br>这里提一句：这个作业调度里面的作业，指的就是外存里面的程序，把外存里面的程序读入内存，就是作业调度。</p>
<h3 id="6-3-2-撤销原语"><a href="#6-3-2-撤销原语" class="headerlink" title="6.3.2 撤销原语"></a>6.3.2 撤销原语</h3><p>让进程结束要用到的原语：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617222743.png" alt="image.png"></p>
<h3 id="6-3-3-阻塞和唤醒"><a href="#6-3-3-阻塞和唤醒" class="headerlink" title="6.3.3 阻塞和唤醒"></a>6.3.3 阻塞和唤醒</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617222901.png" alt="image.png"></p>
<h3 id="6-3-4-切换原语"><a href="#6-3-4-切换原语" class="headerlink" title="6.3.4 切换原语"></a>6.3.4 切换原语</h3><p>这个原语是干嘛的？就是说时间片轮转嘛，一个进程的时间片到了，他就需要从运行态返回就绪态，然后另一个进程上CPU，从就绪态变成运行态。切换原语就是干这个的：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617223007.png" alt="image.png"></p>
<h3 id="6-3-5-进程的运行环境"><a href="#6-3-5-进程的运行环境" class="headerlink" title="6.3.5 进程的运行环境"></a>6.3.5 进程的运行环境</h3><p>前面说要把进程的运行环境保存到PCB中，进程的运行环境是啥？</p>
<p>首先说一下：CPU里面有两个比较重要的寄存器，PC和IR，PC也就是程序计数器，它指向了下一条要执行的指令；IR是当前正在执行的指令。然后还有一些别的寄存器就不说了。</p>
<p>如果现在只有一个进程在运行，有指令 1 2 3 4，那很好解释，CPU将指令1存入IR，PC指向指令2，然后执行IR中的指令。然后CPU根据PC找到指令2，将指令2存入IR，然后PC接着指向指令3，然后CPU执行指令2，以此类推。</p>
<p>但是如果要进行时间片轮转，执行到指令2之后要下CPU了，咋办？下次再上CPU，CPU如何恢复这些IR和PC？操作系统就会把CPU这些寄存器的数据存到PCB中，等下一次再将PCB读会到CPU。那么这些寄存器的数据，就是这个进程的运行环境信息。</p>
<h2 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617224219.png" alt="image.png"></p>
<h1 id="7-进程通讯"><a href="#7-进程通讯" class="headerlink" title="7. 进程通讯"></a>7. 进程通讯</h1><p>首先，进程之间通讯需要操作系统进行支持。进程是分配系统资源的单位（包括内存地址空间），因此各个进程拥有的内存地址空间相互独立。为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p>
<p>所以，操作系统为进程通讯提供了三种方式：共享存储、消息传递、管道通讯。</p>
<h2 id="7-1-共享存储"><a href="#7-1-共享存储" class="headerlink" title="7.1 共享存储"></a>7.1 共享存储</h2><p>这个很好理解，一个进程需要对外暴露共享，他就可以在内存中再申请一片空间，共享数据往这片空间写就行了，然后别的进程来这片空间读即可。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617225020.png" alt="image.png"></p>
<p>互斥这里注意一下就行了，为了避免两个进程都往共享区里面写，操作系统会让写这个操作为互斥操作。</p>
<p>共享存储又分出来两种：基于存储区和基于数据结构。基于存储区的共享，操作系统只负责在内存中划分出来一块共享存储区，数据的形式、存放位置都是通过通信简称控制，而不是操作系统。这种共享方式速度很快，是一种<strong>高级通信</strong>方式。</p>
<p>而基于数据结构的共享，就是操作系统规定，共享空间只能放一个 int[10]，这种共享方式速度慢，限制多，是一种<strong>低级通信</strong>方式。</p>
<p>将内存区域映射到进程的虚拟地址空间，这个先有个印象，往后会详细说。</p>
<h2 id="7-2-消息传递"><a href="#7-2-消息传递" class="headerlink" title="7.2 消息传递"></a>7.2 消息传递</h2><p>进程间的数据交换以<strong>格式化消息</strong>（Message） 为单位。进程通过操作系统提供的“发送消息&#x2F;接收消息”两个<strong>原语</strong>进行数据交换。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617230026.png" alt="image.png"></p>
<h3 id="7-2-1-直接通讯"><a href="#7-2-1-直接通讯" class="headerlink" title="7.2.1 直接通讯"></a>7.2.1 直接通讯</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617230239.png" alt="image.png"></p>
<ul>
<li>首先进程P写一个消息，肯定是在P的地址空间写消息，然后执行发送原语，将消息发出。</li>
<li>进程Q的PCB在操作系统内核空间，PCB内部都有一个消息队列，进程P发来的消息就会挂到这个队列上</li>
<li>然后进程Q执行接收原语，就会在PCB的消息队列上找，哪个是进程P发来的消息</li>
<li>找到消息以后，将这个消息从内核空间PCB上，复制到进程Q的地址空间。</li>
</ul>
<p>所谓的直接通讯，也就是在发送和接收消息的时候指名道姓的说，我这个消息是发给哪个进程的。</p>
<h3 id="7-2-2-间接通信"><a href="#7-2-2-间接通信" class="headerlink" title="7.2.2 间接通信"></a>7.2.2 间接通信</h3><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617230752.png" alt="image.png"></p>
<p>这个也很好理解：</p>
<ul>
<li>进程P同样在自己的地址空间填写消息，但是不再发送给进程Q，而是发送给信箱A。</li>
<li>进程Q会使用接收原语，从信箱A获取这个消息，同样是将消息复制到Q的地址空间。</li>
</ul>
<p>这个就可以多个进程往信箱中发送消息。</p>
<h2 id="7-3-管道通讯"><a href="#7-3-管道通讯" class="headerlink" title="7.3 管道通讯"></a>7.3 管道通讯</h2><p>所谓管道就是特殊的共享文件，又名 pipe 文件。其实就是在内存中开辟一个大小固定的内存缓冲区。这个管道单向传递数据，而且必须按顺序读取数据，类似循环队列。</p>
<p>进程P和进程Q建立pipe，进程P只能往pipe里写，进程Q只能从pipe里读。而且，进程Q只能读最前面未读取的数据，不能像前面共享存储那样，随心所欲想读哪读哪。</p>
<p>重点：</p>
<ul>
<li>管道只能采取半双工通信，也就是在某一时间只能实现单向传输。传输完了以后pipe的方向可以改。如果想要同时进行两个方向的传输，需要设置两个管道。</li>
<li>各个进程要护齿的访问管道，由操作系统实现</li>
<li>当管道写满时，写进程将阻塞，直到读进程将数据取走，即可唤醒写进程</li>
<li>当管道为空时，读进程将阻塞，直到写进程写入数据，即可唤醒读进程。</li>
<li>数据被读走后就会彻底消失。因此如果多个进程同时读一个pipe时，可能会造成混乱。解决方案是：1-一个管道允许多个写进程，一个读进程；2-允许多个写进程多个读进程，但是读进程会轮流读取数据（Linux做法）</li>
</ul>
<p>如果是考试的话，就按多个写进程，一个读进程来就行了。还有，只要pipe没空，读进程就可以读，不用非等pipe满了以后才读，反过来也一样。</p>
<h2 id="7-4-总结"><a href="#7-4-总结" class="headerlink" title="7.4 总结"></a>7.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230617232207.png" alt="image.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/30/02-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hexo_avatar.jpeg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PtheF-Hexo-Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/30/02-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">02.操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-30 11:06:00 / 修改时间：11:13:27" itemprop="dateCreated datePublished" datetime="2023-06-30T11:06:00+08:00">2023-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="1-操作系统运行机制"><a href="#1-操作系统运行机制" class="headerlink" title="1. 操作系统运行机制"></a>1. 操作系统运行机制</h1><h2 id="1-1-两种程序"><a href="#1-1-两种程序" class="headerlink" title="1.1 两种程序"></a>1.1 两种程序</h2><p>两种程序分为：应用程序和内核程序。</p>
<p>应用程序很好理解，就是跑在OS上的程序，比如QQ，微信，程序猿开发的一些程序等等。而开发操作系统的开发人员，开发的就是内核程序，很多的内核程序组成了操作系统内核，或者简称内核（Kernel），内核是OS最重要最核心的部分，也是最接近硬件的部分，甚至可以说一个OS只需要内核就够了，比如 Docker，一个 Linux 容器可以只包含了 Linux 内核。</p>
<h2 id="1-2-两种指令"><a href="#1-2-两种指令" class="headerlink" title="1.2 两种指令"></a>1.2 两种指令</h2><p>首先明确一个概念，指令指的是CPU执行的二进制的那一串一串的玩意，详细的可以在计算机组成原理里面学到，而我们执行的那些 cd ls 啥的都是我们之前说的命令接口。</p>
<p>CPU有一些比较牛逼的指令比如清空内存这类的，这类功能肯定不是谁想用谁就用的，只能是OS的管理者——操作系统内核才有资格执行这种指令。所以CPU就分了两种指令：特权指令和非特权指令。普通应用程序只能使用“非特权指令”，比如加减指令这些。而更危险的特权指令只能由内核程序来发送。</p>
<p>但是CPU只负责一条一条的执行指令，CPU出厂的时候就已经定好了特权指令，他确实可以分辨特权指令，但是他怎么知道这个指令是内核发来的还是应用程序发来的？</p>
<h2 id="1-3-CPU-两种状态"><a href="#1-3-CPU-两种状态" class="headerlink" title="1.3 CPU 两种状态"></a>1.3 CPU 两种状态</h2><p>CPU有两种状态，“内核态” 与 “用户态”，用户态时，CPU只能执行非特权指令，内核态时，CPU就可以执行特权指令了。</p>
<p>同时，CPU里面有一个寄存器叫 <strong>程序状态字寄存器（PSW）</strong>，其中又个二进制位，1表示当前时内核态，0表示用户态。</p>
<p>两种状态还有个别名：内核态 &#x3D; 核心态 &#x3D; 管态； 用户态 &#x3D; 目态。</p>
<h2 id="1-4-CPU状态切换"><a href="#1-4-CPU状态切换" class="headerlink" title="1.4 CPU状态切换"></a>1.4 CPU状态切换</h2><p>流程如下：</p>
<ul>
<li>刚开机时，CPU状态是内核态，操作系统的内核程序先上CPU运行</li>
<li>开完机以后，内核程序会向CPU发送一条特权指令，将PSW从1改成0，进而变成用户态，操作系统就会让出CPU的使用权。</li>
<li>然后就可以执行其他的应用程序。</li>
<li>假设，这个应用程序被黑了，被植入了一条特权指令，CPU读取到这个特权指令后，检查PSW发现自己是用户态，不能执行该指令，就引发一个<strong>中断信号</strong>。</li>
<li>CPU检测到中断信号后，会立即变成<strong>核心态</strong>，并停止运行当前的应用程序，转而运行处理中断信号的内核程序。也就是<strong>中断</strong>会使操作系统重新夺回CPU的控制权。</li>
<li>操作系统处理完了中断时间后，再将CPU使用权交给别的应用程序。</li>
</ul>
<p>两种状态切换：</p>
<ul>
<li>内核态-&gt;用户态：执行一条特权指令即可，操作系统会让出CPU使用权</li>
<li>用户态-&gt;内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号以为着操作系统将强行夺回CPU的使用权。</li>
</ul>
<h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h2><p>一张图：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616163352.png" alt="image.png"></p>
<h1 id="2-中断和异常"><a href="#2-中断和异常" class="headerlink" title="2. 中断和异常"></a>2. 中断和异常</h1><h2 id="2-1-中断的作用"><a href="#2-1-中断的作用" class="headerlink" title="2.1 中断的作用"></a>2.1 中断的作用</h2><p>上面就说过了，操作系统内核程序是整个操作系统的管理者，在合适的情况下，操作系统会将CPU使用权让给应用程序，“中断”则是<strong>让操作系统内核夺回CPU使用权</strong>的唯一途径。</p>
<p>如果没有“中断”机制，CPU就会一直运行一个程序，还怎么并发？</p>
<h2 id="2-2-中断的分类"><a href="#2-2-中断的分类" class="headerlink" title="2.2 中断的分类"></a>2.2 中断的分类</h2><p>分为两类：内中断和外中断。</p>
<p><strong>内中断</strong></p>
<p>上面说的黑客例子就是一个内中断，CPU在用户态接收了一个特权指令进而引发内中断。CPU如果执行的指令是非法的，或者指令的某些参数是非法的，比如除以0，就会引发内中断。</p>
<p>另一种情况就是，我们的应用程序要调用操作系统的一些功能，就需要发送一条特殊的指令——<strong>陷入指令</strong>，意味着应用程序主动将CPU控制权还给操作系统内核，让操作系统帮我干一些事儿。陷入指令也会引发内中断。当然需要注意的是，陷入指令并不是特权指令。</p>
<p><strong>外中断</strong></p>
<p>中断和CPU当前的指令没有关系，中断信号来源于CPU<strong>外部</strong>。比如时钟中断，这个东西就是实现了CPU时间片轮转。现在有两个程序A和B，程序A执行了50ms了，时钟一看差不多该转了，就会给CPU发送一个始终中断信号，然后CPU就会切换到内核态执行时钟中断的内核程序，这个内核程序就可以让CPU待会去执行程序B而非程序A。</p>
<p>其他的比如IO设备，打印机。打印完成后打印机就会发送一个中断信号，这个来源于CPU外部，也属于外中断。</p>
<p>用一张图来说明：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616165006.png" alt="image.png"></p>
<p>这里可以看到，异常也就是内中断，而如果我们直接说中断，大部分情况下说的都是外中断。</p>
<h2 id="2-3-中断机制的基本原理"><a href="#2-3-中断机制的基本原理" class="headerlink" title="2.3 中断机制的基本原理"></a>2.3 中断机制的基本原理</h2><p>不同的中断信号，需要不同的中断处理程序来处理，比如时钟中断，就得用相应的处理程序去进行时间片轮转。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616165337.png" alt="image.png"></p>
<h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616165425.png" alt="image.png"></p>
<h1 id="3-系统调用"><a href="#3-系统调用" class="headerlink" title="3. 系统调用"></a>3. 系统调用</h1><h2 id="3-1-什么是系统调用"><a href="#3-1-什么是系统调用" class="headerlink" title="3.1 什么是系统调用"></a>3.1 什么是系统调用</h2><p>我们之前说过：操作系统向上提供了一些简单易用的服务。主要包括命令接口和程序接口。其中程序接口由一组系统调用组成。</p>
<p>”系统调用“是操作系统提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong>。</p>
<p>编程语言的库函数和系统调用的区别：系统调用向上层提供服务，让上层程序可以请求内核服务，这个上层程序有可能就是库函数，很多库函数就使用了系统调用，然后进行封装，让我们调用的更加方便。</p>
<p>但是并不是所有的库函数都用了系统调用，比如C语言的 abs 函数就没用，其他的一些比如创建一个新文件这类的函数，肯定就会用到系统调用。<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616170342.png" alt="image.png"></p>
<h2 id="3-2-系统调用重要性"><a href="#3-2-系统调用重要性" class="headerlink" title="3.2 系统调用重要性"></a>3.2 系统调用重要性</h2><p>这么个场景：用 WPS 和 office 同时打印论文，如果两个进程都可以直接调用IO设备，并发的使用打印机，那么两个论文就会混在一起了。</p>
<p>所以，将这类共享资源交给操作系统内核进行统一管理，并向上提供“系统调用”，用户进程想要使用打印机，只能通过系统调用向操作系统内核发出请求，然后内核再对哥哥请求进行协调处理，该阻塞阻塞。</p>
<h2 id="3-3-什么功能要用到系统调用"><a href="#3-3-什么功能要用到系统调用" class="headerlink" title="3.3 什么功能要用到系统调用"></a>3.3 什么功能要用到系统调用</h2><p>很简单，凡是与共享资源有关的操作（存储分配、IO操作、文件管理），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616170934.png" alt="image.png"></p>
<h2 id="3-4-系统调用过程"><a href="#3-4-系统调用过程" class="headerlink" title="3.4 系统调用过程"></a>3.4 系统调用过程</h2><p>这个就很有意思了，假设我们的C语言要开辟一个新进程：</p>
<ul>
<li>首先，向CPU发送一条指令，将fork存到CPU的寄存器中</li>
<li>然后，再向CPU发送一条指令，将具体的参数存到寄存器中</li>
<li>发送陷入指令（trap），CPU一看trap指令就会发生内中断，然后调用处理trap的内核程序，这个内核程序就会将寄存器中存的参数取出来，一看，奥，你要执行fork，然后具体参数是多少多少，然后内核程序给你执行</li>
<li>执行完了以后，回到用户态。</li>
</ul>
<p>需要注意的是，陷入指令是用户态执行的，然后立即引发一个内中断，CPU进入内核态；发送系统调用请求是在用户态，而对系统调用的相应处理是在核心态下进行。</p>
<p>顺带：陷入指令 &#x3D; trap 指令 &#x3D; 访管指令</p>
<h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616171751.png" alt="image.png"></p>
<h1 id="4-操作系统体系结构"><a href="#4-操作系统体系结构" class="headerlink" title="4. 操作系统体系结构"></a>4. 操作系统体系结构</h1><h2 id="4-1-内核结构"><a href="#4-1-内核结构" class="headerlink" title="4.1 内核结构"></a>4.1 内核结构</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616172203.png" alt="image.png"></p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616172333.png" alt="image.png"><br>上面的三种东西，时钟，中断，原语，这三个东西和硬件最为紧密，是一定要放在内核中的。但是下面三个 进程、存储器、设备，不会直接涉及到硬件，所以有些操作系统并不会将他们放到内核中。</p>
<p>这就引出两种操作系统设计方法；</p>
<ul>
<li>将所有内容包含在内核中，包括 进程、寄存器、设备管理，就叫大内核。</li>
<li>只保留时钟，中断，原语等核心功能，这种设计就叫微内核。</li>
</ul>
<p>微内核情况下，核心功能跑在内核态，其他的进程管理、寄存器管理、设备管理就会跑在用户态。</p>
<h2 id="4-2-两种内核的区别"><a href="#4-2-两种内核的区别" class="headerlink" title="4.2 两种内核的区别"></a>4.2 两种内核的区别</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616172949.png" alt="image.png"></p>
<p>主要就是变态这块有点区别，剩下的没啥。</p>
<h2 id="4-3-大小内核总结"><a href="#4-3-大小内核总结" class="headerlink" title="4.3 大小内核总结"></a>4.3 大小内核总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616173054.png" alt="image.png"></p>
<h2 id="4-4-分层结构"><a href="#4-4-分层结构" class="headerlink" title="4.4 分层结构"></a>4.4 分层结构</h2><p>这个和Java的什么三层架构很像，操作系统分为多个层，每层可单向调用更低一层提供接口：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616175224.png" alt="image.png"></p>
<p>好处就是易于调试，而且想要在两层之间加一层的话也是比较简单的。</p>
<p>但是缺点就是，层与层的划分有的时候并不明确，比如进程管理和内存管理，两种功能相互调用，在分层结构中就比较难办。同时，A层不能直接调用D层，而是需要依次向下传递调用，效率会比较慢。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616175454.png" alt="image.png"></p>
<h2 id="4-5-模块化结构"><a href="#4-5-模块化结构" class="headerlink" title="4.5 模块化结构"></a>4.5 模块化结构</h2><p>将操作系统按照功能划分为若干个具有一定独立性的模块。每个模块具有某方面的管理功能，并会定好个模块之间的接口，使各模块之间能通过接口进行通信。还可以进一步将各模块细分为若干个具有一定功能的自模块，同样也规定好各自模块之间的接口。将这种设计方法称为模块-接口法：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616175731.png" alt="image.png"><br>这里面内核包括主模块和加载模块，主模块包含最主要的功能，没有主模块没法启动，加载模块非必需，可以按照需求动态添加。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616180219.png" alt="image.png"></p>
<h2 id="4-6-大小内核"><a href="#4-6-大小内核" class="headerlink" title="4.6 大小内核"></a>4.6 大小内核</h2><p>这个就是之前重点在说的，直接看图就行了：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616180256.png" alt="image.png"></p>
<h2 id="4-7-外核"><a href="#4-7-外核" class="headerlink" title="4.7 外核"></a>4.7 外核</h2><p>一般情况下，OS给用户分配的都是虚拟的资源，比如虚拟的内存空间，我们看到的内存是连续的，但其实在物理上压根不是连续的。外存就是跳过了虚拟这一步，外存讲究不虚拟，不抽象，直接调用硬件资源给你，让资源管理更加灵活，同时外核也负责保证这些硬件资源的安全。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616180900.png" alt="image.png"></p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616180834.png" alt="image.png"></p>
<h1 id="5-操作系统引导"><a href="#5-操作系统引导" class="headerlink" title="5. 操作系统引导"></a>5. 操作系统引导</h1><p>简单说就是怎么开机，我们买回来一块硬盘，装在电脑上，然后分完区，将系统装在C盘上，磁盘就会出现一个东西叫主引导记录：里面记录的磁盘的引导程序和磁盘的分区表。</p>
<p>同时电脑的内存分为两类：RAM和ROM，ROM断电后是不会消失的，然后我们来看看电脑是怎么开机的。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616181654.png" alt="image.png"></p>
<ul>
<li>通电以后，CPU开始工作，CPU执行ROM中的引导程序，主要就是自检，同时指示CPU将磁盘中的主引导记录导入内存</li>
<li>CPU开始执行磁盘引导程序，磁盘引导程序会根据分区表去判断C盘的位置，然后就可以将C盘的第一部分数据读入内存，也就是引导记录PBR</li>
<li>这个PBR本质上也是个程序，CPU执行这个PBR，就会找到C盘根目录中的启动管理程序，然后这个程序负责初始化操作系统。</li>
</ul>
<h1 id="6-虚拟机"><a href="#6-虚拟机" class="headerlink" title="6. 虚拟机"></a>6. 虚拟机</h1><p>虚拟机：使用虚拟化技术，将一台物理机器虚拟化为堕胎虚拟机起，每个虚拟机起都可以独立运行一个操作系统。</p>
<p>同义术语：虚拟机管理程序&#x2F;虚拟机监控程序&#x2F;Virtual Machine Monitor（VMM）&#x2F; Hypervisor</p>
<h2 id="6-1-第一类虚拟机"><a href="#6-1-第一类虚拟机" class="headerlink" title="6.1 第一类虚拟机"></a>6.1 第一类虚拟机</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616183023.png" alt="image.png"></p>
<p>虚拟机管理程序直接运行在硬件上，然后将硬件资源分配给上层的各个虚拟机。但是这里有个问题，虚拟机以为自己是真实的机器，所以他们也会有虚拟的内核态，就会向真实CPU发送特权指令，但是整个虚拟机其实都是真实机的用户态，怎么办？</p>
<p>简单，VMM会截获虚拟机发送过来的特权指令，然后将特权指令进行等价转化，让虚拟机以为自己的特权指令执行成功。</p>
<h2 id="6-2-第二类虚拟机"><a href="#6-2-第二类虚拟机" class="headerlink" title="6.2 第二类虚拟机"></a>6.2 第二类虚拟机</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616183342.png" alt="image.png"></p>
<h2 id="6-3-两类虚拟机区别"><a href="#6-3-两类虚拟机区别" class="headerlink" title="6.3 两类虚拟机区别"></a>6.3 两类虚拟机区别</h2><p>直接看图吧，没啥说的了：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616184114.png" alt="image.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/30/01-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hexo_avatar.jpeg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PtheF-Hexo-Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/30/01-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">01.操作系统基础概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-30 11:05:47 / 修改时间：11:13:18" itemprop="dateCreated datePublished" datetime="2023-06-30T11:05:47+08:00">2023-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>

<h1 id="1-操作系统的定义"><a href="#1-操作系统的定义" class="headerlink" title="1. 操作系统的定义"></a>1. 操作系统的定义</h1><p>操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的借口和环境；她是计算机系统中最基本的系统软件。</p>
<h1 id="2-操作系统的功能和目标"><a href="#2-操作系统的功能和目标" class="headerlink" title="2. 操作系统的功能和目标"></a>2. 操作系统的功能和目标</h1><h2 id="2-1-向上层提供方便易用的服务"><a href="#2-1-向上层提供方便易用的服务" class="headerlink" title="2.1 向上层提供方便易用的服务"></a>2.1 向上层提供方便易用的服务</h2><p>操作系统的主要功能和目标就是向上层提供方便易用的服务，这里用qq视频为例：</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616151323.png" alt="image.png"></p>
<p>总体如下：<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616152019.png" alt="image.png"><br>这里稍微解释一下联机命令接口和脱机命令接口。</p>
<ul>
<li>联机命令接口就是我说一句系统做一句，其实就是我直接输入的类似 ls 的这种指令。</li>
<li>脱机命令接口就是批处理指令，一大堆命令写的指令集。<br>程序接口就是程序里面用的，比如C语言的printf，底层就掉用了很多操作系统提供的接口，这种就是程序接口。<br>然后命令接口和程序接口也可以统称为用户接口。</li>
</ul>
<h2 id="2-2-作为最接近硬件的层次"><a href="#2-2-作为最接近硬件的层次" class="headerlink" title="2.2 作为最接近硬件的层次"></a>2.2 作为最接近硬件的层次</h2><p>这个也好理解，操作系统离硬件最近，可以拓展硬件的功能，比如可以在操作系统的层面上实现虚拟机。</p>
<h1 id="3-操作系统的特征"><a href="#3-操作系统的特征" class="headerlink" title="3. 操作系统的特征"></a>3. 操作系统的特征</h1><h2 id="3-1-并发"><a href="#3-1-并发" class="headerlink" title="3.1 并发"></a>3.1 并发</h2><p>这个非常熟悉了，宏观上是同时发生的，但是微观上是交替发生的。对应的是并行，并行就是在同一时间确实是同时发生的。</p>
<p>而在操作系统的层面上来说，并发性指的是计算机系统中“同时”运行着多个程序，这些程序宏观上是同时运行的，而围观上是交替运行的。操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的。</p>
<p>并发性是操作系统一个最基本的特性。</p>
<h2 id="3-2-共享"><a href="#3-2-共享" class="headerlink" title="3.2 共享"></a>3.2 共享</h2><p>共享就是资源共享，指系统中的资源可供内容中的多个并罚执行的进程共同使用。</p>
<p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616153156.png" alt="image.png"></p>
<p>这里所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的，也就是分时共享。</p>
<h2 id="3-3-并发和共享的关系"><a href="#3-3-并发和共享的关系" class="headerlink" title="3.3 并发和共享的关系"></a>3.3 并发和共享的关系</h2><p>并发性指同时存在着多个运行着的程序<br>共享性指系统中的资源可供能存中的多个并罚执行的进程共同使用。</p>
<p>这里举个例子：qq和微信同时发送文件，qq发送文件A，微信发送文件B。qq和微信两个进程并发执行，如果失去了并发性，则系统中只有一个程序正在运行，则共享性失去了意义。两个进程共享的访问硬盘资源，如果失去了共享性，则qq和微信不能同时访问磁盘，则无法并发。</p>
<p>所以并发性和共享性互为<strong>存在条件</strong>。</p>
<h2 id="3-4-虚拟"><a href="#3-4-虚拟" class="headerlink" title="3.4 虚拟"></a>3.4 虚拟</h2><p>这个东西有个概念就行了，往后会重点说，大致就是，我的电脑只有4g内存，我打开一个gta5就用了4g内存，但是我还可以同时打开其他的软件，难道内存不会爆么？这里就涉及虚拟存储器技术的“空分复用技术”。</p>
<p>再比如，一个单核CPU的计算机，但是用户可以打开很多软件，为啥？这里队赢了虚拟处理器技术，更详细的就是“时分复用技术”，微观上处理剂在各个微笑的时间段内加集体的为各个进程服务。</p>
<p>显然，如果失去了并发性，虚拟性也就没有意义了。</p>
<h2 id="3-5-异步"><a href="#3-5-异步" class="headerlink" title="3.5 异步"></a>3.5 异步</h2><p>在多道程序环境中，允许多个程序并发执行，但是由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是异步性，其实说白了就是阻塞，学Java并发的时候很清楚了。</p>
<h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h2><p><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616154733.png" alt="image.png"></p>
<p>并发和共享互为存在条件，没有并发和共享，就谈不上虚拟和异步，所以并发和共享是操作系统的两个最基本的特征。</p>
<h1 id="4-OS的发展和分类"><a href="#4-OS的发展和分类" class="headerlink" title="4. OS的发展和分类"></a>4. OS的发展和分类</h1><h2 id="4-1-手工操作阶段"><a href="#4-1-手工操作阶段" class="headerlink" title="4.1 手工操作阶段"></a>4.1 手工操作阶段</h2><p>这个玩意很反人类，就是最早的纸带，程序员把程序通过打孔的方式写到纸带上，然后把纸带给计算机，计算机计算后将结果大打回到纸带上，然后程序猿再去研究纸带。</p>
<p>这种方式最主要就是资源利用率差，程序猿研究纸带就很浪费时间，而计算机计算又非常快。而且同一时间只有一个程序猿可以使用计算机，总的来说就是资源利用率极低。</p>
<h2 id="4-2-单道批处理系统"><a href="#4-2-单道批处理系统" class="headerlink" title="4.2 单道批处理系统"></a>4.2 单道批处理系统</h2><p>一定程度上解决了上面的问题，程序猿把自己的纸带一块交给一个叫外围机的机器，这个机器会把所有的纸带数据录入到磁带上，然后将磁带交给计算机进行计算，再将结果返回给磁带。</p>
<p>好处就是磁带的读写速度比纸带快很多，计算机的利用率就上来了。但是速度仍然很差，一段时间内只有一个程序在运行。</p>
<h2 id="4-3-多道批处理系统"><a href="#4-3-多道批处理系统" class="headerlink" title="4.3 多道批处理系统"></a>4.3 多道批处理系统</h2><p>这里操作系统就真正的诞生了，计算机可以从内容（也就是磁带）中读取多道程序，然后并发的执行，将结果返回给磁带，优点就是多道程序并发执行，共享计算机资源。资源利用率大幅提高，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616155831.png" alt="image.png"></p>
<h2 id="4-4-分时操作系统"><a href="#4-4-分时操作系统" class="headerlink" title="4.4 分时操作系统"></a>4.4 分时操作系统</h2><p>这里就有了时间片，计算机以时间片为单位轮流为各个用户&#x2F;作业进行服务，各个用户可以通过终端与计算机交互。</p>
<p>主要优点：用户请求可以即时被响应，解决了人机交互的问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p>
<p>主要缺点：不能及时处理一些紧急的任务。</p>
<h2 id="4-5-实时操作系统"><a href="#4-5-实时操作系统" class="headerlink" title="4.5 实时操作系统"></a>4.5 实时操作系统</h2><p>这种可以优先响应一些紧急任务，某些紧急任务不需要时间片排队。在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在<strong>严格的时限内处理完事件</strong>。实施操作系统的主要特点是<strong>及时性和可靠性</strong>。<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616160422.png" alt="image.png"></p>
<h2 id="4-6-其他操作系统"><a href="#4-6-其他操作系统" class="headerlink" title="4.6 其他操作系统"></a>4.6 其他操作系统</h2><p>这里看看图就行了，不多说。<br><img src="https://gitee.com/pthef/imgrepo/raw/master/20230616160520.png" alt="image.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/19/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hexo_avatar.jpeg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PtheF-Hexo-Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/19/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">网站部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-19 17:11:20 / 修改时间：18:52:55" itemprop="dateCreated datePublished" datetime="2022-10-19T17:11:20+08:00">2022-10-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%83%A8%E7%BD%B2/" itemprop="url" rel="index"><span itemprop="name">部署</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近写了个小网站，用于给别人的大创项目结项，同时自己也练练技术，本着大学最后一次做应用项目的原因，打算把这个项目做的正式一点，所以开发，部署，dns，备案 一串工作全做了，挺费劲。这里总结一下这次部署网站的流程。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/10/19/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Author"
      src="/images/hexo_avatar.jpeg">
  <p class="site-author-name" itemprop="name">Author</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/PtheF" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PtheF" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Author</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
